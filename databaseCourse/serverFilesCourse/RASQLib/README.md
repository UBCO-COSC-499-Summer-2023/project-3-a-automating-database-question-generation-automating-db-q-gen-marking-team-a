# RASQLib

This library was created to aid in the generation and grading of random RelaX and SQL questions.


## __init__

Python libraries require an `__init__.py` file to be recognized as a library. The file is blank since it is only required to be present such that this folder is recognized as a library.


## Text Files

Text files include all the .txt files one directory level down, so all files in any of the following folders:
- noisyData
- randomTableData
- randomTables
Such text files are used to aid in random question generation. These files are read during `pl-sql-element.py`'s `prepare()` function when this library is invoked. The files hold lists of example data, where items are randomly chosen to create "clean" looking data. The `noisyData` file contains common values for strings/VARCHAR datatypes; `randomTableData` contains names for tables, columns (with specifications for both RelaX and SQL table metadata), and a file that maps a column name to the appropriate file in `noisyData`; and, `randomTables` contains table DDL statements for various tables, but this is only used in difficulty-type questions for autogenerate CREATE questions.


## noisyData

This Python file generates random data given an SQL data type. If the column name matches against a list, a random value is drawn from the appropriate text file; this is done to generate human-readable random data. Otherwise, if the column name does not match, "noisy" random data is generated instead. This noisy data is worse than gibberish for data types such as VARCHAR or CHAR (since generating human-readable gibberish is difficult), but are generated from constrained ranges for data types such as INTEGER or DATETIME (and as such are human-readable).


### generateNoisyData(table, key, qty=1)

When an array of random data is desired, this function is called and it is responsible for calling the appropriate data-generating function. The `table` and `key` (a.k.a. column) parameters are used to determine the data-type of the column as well as whether or not to enforce distinct values. This function also checks if the column (`key`) is mapped to a file in the `noisyData` folder and, if so, grabbing values from said folder.


### generateNoisyDataNoFile(table, key, qty=1, unique=False)

If the key was not mapped to a file in `noisyData`, as determined by `generateNoisyData()`, then this function checks whether or not the table is a RelaX table or an SQL table, calling the next function as appropriate.


### generateNoisyDataNoFileSQL(table, key, qty=1, unique=False)

If the key was not mapped to a file in `noisyData`, as determined by `generateNoisyData()`, and the table was found to be an SQL table, as determined by `generateNoisyDataNoFile()`, then this function obtains the data-type and the data-type's metadata to determine which specific data-generating function to call.  
The possible data-types are: INTEGER, DECIMAL, CHAR, VARCHAR, DATE, and DATETIME.


### generateNoisyDataNoFileRelaX(table, key, qty=1, unique=False)

If the key was not mapped to a file in `noisyData`, as determined by `generateNoisyData()`, and the table was found to be a RelaX table, as determined by `generateNoisyDataNoFile()`, then this function obtains the data-type and the data-type's metadata to determine which specific data-generating function to call.
The possible data-types are: NUMBER, DATE, and STRING.  
In the case that the data-type is NUMBER and the key is `price`, then this function will return a float/decimal value. Otherwise, when the data-type is NUMBER, it will return an integer.


### generateNoisyInteger(unique, qty)

This function generates and returns an array of integers of size `qty` from the range [1, 1000].  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyDecimal(unique, qty, unitOther)

This function generates and returns an array of floats of size `qty`. `unitOther` is of the form `x,y` where `x` is the total number of digits and `y` is the decimal precision; this floats generated by this function range from `[1, 10 ^ (x - y) + 1)`. While `y` may be any number smaller than `x`, in practice `y` is always 2 since the numbers are automatically rounded to two decimals places when displayed. `x - y` is enforced to be no larger than 3, such that the greatest values generated it about 1000, since larger numbers are unwieldly for the purpose of queries.  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyChar(unique, qty, unitOther)

This function generates and returns an array of strings of size `qty` that contain all uppercase letters and the ten deicmal digits. Each string generated will be of exactly `unitOther` length.  
If `unique` is true, then the returned array is guaranteed to contain only unique values. There is a counter that increments each time a value is generated. If this counter reaches a certain value and the value generated is not unique, it will instead add the string `NULL` to the array. This is done to prevent timeouts when `unitOther` is small compared to quantity and to speed up data generation when few unique values remain.


### generateNoisyVarchar(unique, qty, unitOther)

This function generates and returns an array of strings of size `qty`. The lenght of each string ranges from (1, unitOther). This function calls `generateNoisyChar()` with a `qty` of 1 and a random `unitOther` in a range (1, `unitOther`).  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyDate(unique, qty)

This function generates and returns an array of strings of size `qty` of the form `yyyy-mm-dd`. The month is randomly chosen from (1, 12) and the day is chosen from a range suitable frm the month; this function can never generate a 29th day in February. The year is chosen from the range (1955, 2023).  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyDateTime(unique, qty)

This function generates and returns an array of strings of size `qty` of the form `yyyy-mm-dd hh:mm:ss`. The date portion is obtained through a call of `generateNoisyData` and the hour is random integers from the appropriate range. The minute is generated to be an increment of five and the seconds are always zero; this is done to make the generated DATETIMEs less cumbersome.  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateFromFile(qty, choices, choose)

This funciton is called by `generateNoisyData()` when the key corresponds to a file; the values from the file are placed into the `choices` parameter. It returns an array of size `qty` of values from the array `choices` where the function `choose` is called to determine whether to pick values with or without replacement. `choose` is either the `popRandom()` or `selectRandom()` function. If `popRandom()` is called then the values are unique, otherwise they are not unique.


### generateColumns(table, qty=1)

This function returns a dictionary where each key is a column of the table and the values are an array of size `qty` of data whose data-type matches the column's unit. The table's columns are iterated over and for each column the `generateNoisyData()` function is called.


### relativeFilePath(file)

This function returns the path the file called `file` in the `noisyData` folder. To obtain the path, this function calls `absoluteDirectoryPath()`.


### absoluteDirectoryPath()

This function obtains the path to the current directory. If the `/RASQLib` is in this path, the path is returned. Otherwise the path is travelled up to the parent of the `/elements` directory then down into `/RASQLib`; this new path is returned.  
This function is necessary since PrairieLearn changes the directory layout at runtime. In order to run test on DroneCI, the filepath needs to be changed from what it would be on PrairieLearn.


### readLines(fileName)

Given the name of a file from `noisyData`, this function opens that file and returns an array the file's lines, excluding whitespace lines.  
The `fileName` should not include an extension. The extension is assumed to be `.txt`.


### getColumnToFileMap(path=f"{absoluteDirectory}/randomTableData/columnToFile.txt")

This function reads and parses the file `columnToFile` and returns a dictionary whose key is a column name and the value in the file in `noisyData` that contains the appropriate values.


### isUnique(table, key)

This function checks whether or not a given column of a table may only contain unique values.  
The columns that may only contain unique values are primary key columns, foreign key columns, or columns with the UNIQUE clause.


### popRandom(values, weights=[])

This function will pop a random value of the the array `values` and return it. If `weights` are provided, the array must be of the same dimensions as the `values` array; they will increase the likelihood of the value of the weight's matching index to be popped. If `weights` are not provided, all values have an equal likelihood of being popped.  
A popped item is removed from the array. If this function is called multiple times on the same array, then it cannot select duplicate values.  
If the `values` array is emtpty, this function returns `NULL`.


### selectRandom(values, weights=[])

This function will select a random value of the the array `values` and return it. If `weights` are provided, the array must be of the same dimensions as the `values` array; they will increase the likelihood of the value of the weight's matching index to be selected. If `weights` are not provided, all values have an equal likelihood of being selected.  
A selected item is not removed from the array. If this function is called multiple times on the same array, then it may select duplicate values.  
If the `values` array is emtpty, this function returns `NULL`.


## noisyData_test

This file contains a suite of tests for the `noisyData.py` file.


## textDatabaseHandler

The text database handler models a simplified database and table system, used to assist random question generation. Its functionality focuses on a group table as a set of columns and a set of rows as well as converting text file-stored values into memory. It is also responsible for calling functions to generate data to populate the various table's rows, ensuring the rows conform to foreign key constraints, providing dictionaries that allow easy parsing on the structure of the databse, and loading the database's tables' columns and rows into memory.


## textDatabaseHandler_test

This file contains a suite of tests for the `textDatabaseHandler.py` file.