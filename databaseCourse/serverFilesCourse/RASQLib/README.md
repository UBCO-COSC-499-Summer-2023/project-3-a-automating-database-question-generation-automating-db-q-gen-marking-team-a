# RASQLib

This library was created to aid in the generation and grading of random RelaX and SQL questions.


## __init__

Python libraries require an `__init__.py` file to be recognized as a library. The file is blank since it is only required to be present such that this folder is recognized as a library.


## Text Files

Text files include all the .txt files one directory level down, so all files in any of the following folders:
- noisyData
- randomTableData
- randomTables
Such text files are used to aid in random question generation. These files are read during `pl-sql-element.py`'s `prepare()` function when this library is invoked. The files hold lists of example data, where items are randomly chosen to create "clean" looking data. The `noisyData` file contains common values for strings/VARCHAR datatypes; `randomTableData` contains names for tables, columns (with specifications for both RelaX and SQL table metadata), and a file that maps a column name to the appropriate file in `noisyData`; and, `randomTables` contains table DDL statements for various tables, but this is only used in difficulty-type questions for autogenerate CREATE questions.


## noisyData

This Python file generates random data given an SQL data type. If the column name matches against a list, a random value is drawn from the appropriate text file; this is done to generate human-readable random data. Otherwise, if the column name does not match, "noisy" random data is generated instead. This noisy data is worse than gibberish for data types such as VARCHAR or CHAR (since generating human-readable gibberish is difficult), but are generated from constrained ranges for data types such as INTEGER or DATETIME (and as such are human-readable).


### generateNoisyData(table, key, qty=1)

When an array of random data is desired, this function is called and it is responsible for calling the appropriate data-generating function. The `table` and `key` (a.k.a. column) parameters are used to determine the data-type of the column as well as whether or not to enforce distinct values. This function also checks if the column (`key`) is mapped to a file in the `noisyData` folder and, if so, grabbing values from said folder.


### generateNoisyDataNoFile(table, key, qty=1, unique=False)

If the key was not mapped to a file in `noisyData`, as determined by `generateNoisyData()`, then this function checks whether or not the table is a RelaX table or an SQL table, calling the next function as appropriate.


### generateNoisyDataNoFileSQL(table, key, qty=1, unique=False)

If the key was not mapped to a file in `noisyData`, as determined by `generateNoisyData()`, and the table was found to be an SQL table, as determined by `generateNoisyDataNoFile()`, then this function obtains the data-type and the data-type's metadata to determine which specific data-generating function to call.  
The possible data-types are: INTEGER, DECIMAL, CHAR, VARCHAR, DATE, and DATETIME.


### generateNoisyDataNoFileRelaX(table, key, qty=1, unique=False)

If the key was not mapped to a file in `noisyData`, as determined by `generateNoisyData()`, and the table was found to be a RelaX table, as determined by `generateNoisyDataNoFile()`, then this function obtains the data-type and the data-type's metadata to determine which specific data-generating function to call.
The possible data-types are: NUMBER, DATE, and STRING.  
In the case that the data-type is NUMBER and the key is `price`, then this function will return a float/decimal value. Otherwise, when the data-type is NUMBER, it will return an integer.


### generateNoisyInteger(unique, qty)

This function generates and returns an array of integers of size `qty` from the range [1, 1000].  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyDecimal(unique, qty, unitOther)

This function generates and returns an array of floats of size `qty`. `unitOther` is of the form `x,y` where `x` is the total number of digits and `y` is the decimal precision; this floats generated by this function range from `[1, 10 ^ (x - y) + 1)`. While `y` may be any number smaller than `x`, in practice `y` is always 2 since the numbers are automatically rounded to two decimals places when displayed. `x - y` is enforced to be no larger than 3, such that the greatest values generated it about 1000, since larger numbers are unwieldly for the purpose of queries.  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyChar(unique, qty, unitOther)

This function generates and returns an array of strings of size `qty` that contain all uppercase letters and the ten deicmal digits. Each string generated will be of exactly `unitOther` length.  
If `unique` is true, then the returned array is guaranteed to contain only unique values. There is a counter that increments each time a value is generated. If this counter reaches a certain value and the value generated is not unique, it will instead add the string `NULL` to the array. This is done to prevent timeouts when `unitOther` is small compared to quantity and to speed up data generation when few unique values remain.


### generateNoisyVarchar(unique, qty, unitOther)

This function generates and returns an array of strings of size `qty`. The lenght of each string ranges from (1, unitOther). This function calls `generateNoisyChar()` with a `qty` of 1 and a random `unitOther` in a range (1, `unitOther`).  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyDate(unique, qty)

This function generates and returns an array of strings of size `qty` of the form `yyyy-mm-dd`. The month is randomly chosen from (1, 12) and the day is chosen from a range suitable frm the month; this function can never generate a 29th day in February. The year is chosen from the range (1955, 2023).  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyDateTime(unique, qty)

This function generates and returns an array of strings of size `qty` of the form `yyyy-mm-dd hh:mm:ss`. The date portion is obtained through a call of `generateNoisyData` and the hour is random integers from the appropriate range. The minute is generated to be an increment of five and the seconds are always zero; this is done to make the generated DATETIMEs less cumbersome.  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateFromFile(qty, choices, choose)

This funciton is called by `generateNoisyData()` when the key corresponds to a file; the values from the file are placed into the `choices` parameter. It returns an array of size `qty` of values from the array `choices` where the function `choose` is called to determine whether to pick values with or without replacement. `choose` is either the `popRandom()` or `selectRandom()` function. If `popRandom()` is called then the values are unique, otherwise they are not unique.


### generateColumns(table, qty=1)

This function returns a dictionary where each key is a column of the table and the values are an array of size `qty` of data whose data-type matches the column's unit. The table's columns are iterated over and for each column the `generateNoisyData()` function is called.


### relativeFilePath(file)

This function returns the path the file called `file` in the `noisyData` folder. To obtain the path, this function calls `absoluteDirectoryPath()`.


### absoluteDirectoryPath()

This function obtains the path to the current directory. If the `/RASQLib` is in this path, the path is returned. Otherwise the path is travelled up to the parent of the `/elements` directory then down into `/RASQLib`; this new path is returned.  
This function is necessary since PrairieLearn changes the directory layout at runtime. In order to run test on DroneCI, the filepath needs to be changed from what it would be on PrairieLearn.


### readLines(fileName)

Given the name of a file from `noisyData`, this function opens that file and returns an array the file's lines, excluding whitespace lines.  
The `fileName` should not include an extension. The extension is assumed to be `.txt`.


### getColumnToFileMap(path=f"{absoluteDirectory}/randomTableData/columnToFile.txt")

This function reads and parses the file `columnToFile` and returns a dictionary whose key is a column name and the value in the file in `noisyData` that contains the appropriate values.


### isUnique(table, key)

This function checks whether or not a given column of a table may only contain unique values.  
The columns that may only contain unique values are primary key columns, foreign key columns, or columns with the UNIQUE clause.


### popRandom(values, weights=[])

This function will pop a random value of the the array `values` and return it. If `weights` are provided, the array must be of the same dimensions as the `values` array; they will increase the likelihood of the value of the weight's matching index to be popped. If `weights` are not provided, all values have an equal likelihood of being popped.  
A popped item is removed from the array. If this function is called multiple times on the same array, then it cannot select duplicate values.  
If the `values` array is emtpty, this function returns `NULL`.


### selectRandom(values, weights=[])

This function will select a random value of the the array `values` and return it. If `weights` are provided, the array must be of the same dimensions as the `values` array; they will increase the likelihood of the value of the weight's matching index to be selected. If `weights` are not provided, all values have an equal likelihood of being selected.  
A selected item is not removed from the array. If this function is called multiple times on the same array, then it may select duplicate values.  
If the `values` array is emtpty, this function returns `NULL`.


## noisyData_test

This file contains a suite of tests for the `noisyData.py` file.


## textDatabaseHandler

The text database handler models a simplified database and table system, used to assist random question generation. Its functionality focuses on a group table as a set of columns and a set of rows as well as converting text file-stored values into memory. It is also responsible for calling methods to generate data to populate the various table's rows, ensuring the rows conform to foreign key constraints, providing dictionaries that allow easy parsing on the structure of the databse, and loading the database's tables' columns and rows into memory.


### Database class

This class is responsible for keeping track of all the tables as well as performing operations on all tables. It also keeps track whether they are RelaX or SQL tables.  
The connections between RelaX tables are structured as a tree with a depth of `depth`. SQL tables are a tree with a depth of one; in other words, the root table is the only table to contain references.


#### generateRows(self, qty)

This method determines whether the database contains RelaX or SQL tables and then call the appropirate method. After this method is called, the tables are all filled with rows of randomly generated data.


#### generateRowsSQL(self, qty)

This method first generates for the root table (a.k.a. the primary table) by calling the table's `generateRows()` method then it calls the same method on all the referenced tables. At this point, foreign key constraints are violated. The method then iterates over all rows in the primary table that are a foreign key and override the referenced column in the referenced table to match the column of the primary table, thereby enforcing foreign key constraints.


#### addRowsBackend(self, conditionalValues)

This method adds the values from `conditionalValues` into the backend rows of the tables. `conditionalValues` is a dictionary whose key is a column and whose value is some random data whose data-type matches the column's unit. For each value in `conditionalValues`, this method will create a row that includes the value and the other columns of the row contain random data; each row is added to the appropriate table's backend rows.


#### generateRowsBackend(self, qty=0)

This method generates a number of rows for each table's backend rows equal to `qty` minus that table's current count of backend rows such that each table will have `qty` number of rows regardless of how many starting rows the table had. For each table, this funciton calls the table's `generateRowsBackend()` method with a `qty` a previously determined. After all the backend rows are generated, it enforces foreign key constraints by overriding foreign columns.


#### loadColumns(self, data)

This method loads each table's CREATE statement into the data variable. The CREATE statements are placed in `data['params']['db_initialize_create']`.  
This method first loads the referenced tables and then the root (a.k.a primary) table. This order prevents foreign key constraint violations.


#### loadRows(self, data)

This method loads each table's INSERT statements for all its rows into the data variable. The INSERT statements are placed in `data['params']['db_initialize_insert_frontend']`. This method only loads the rows for the frontend database, the one the users will directly access.  
This method first loads the referenced tables and then the root (a.k.a primary) table. This order prevents foreign key constraint violations.


#### loadRowsBackend(self, data)

This method loads each table's INSERT statements for all its rows into the data variable. The INSERT statements are placed in `data['params']['db_initialize_insert_backend']`. This method only loads the rows for the backend database, the one the users will not directly access but their results will be graded against.  
This method first loads the referenced tables and then the root (a.k.a primary) table. This order prevents foreign key constraint violations.


#### loadDatabase(self, data)

This method calls all the necessary functions to load each table and all their rows, both rows for the frontend and the backend.


#### getTableMap(self)

The table map returned is a dictionary whose key is the name of the foreign key column and whose value is the referenced table. There is also a key that is the root (a.k.a primary) table's name and whose value is the root table.


#### getColumnMap(self, tableName=True)

The column map returned is a dictionary whose key is a column name and whose value is the table to which that column belongs.  
Is `tableNames` is set to true, then the dictionary's value is the string name of the table. If `tableNames` is false, then the value is the table object.


#### __str__(self)

The database's to-string method returns a string of each table's CREATE statement. This function should not be used to load the databases into the data variable since the order of the CREATE statements will cause a foreign key constraint error.


### Table class


## textDatabaseHandler_test

This file contains a suite of tests for the `textDatabaseHandler.py` file.