# RASQLib

This library was created to aid in the generation and grading of random RelaX and SQL questions.


## __init__

Python libraries require an `__init__.py` file to be recognized as a library. The file is blank since it is only required to be present such that this folder is recognized as a library.


## Text Files

Text files include all the .txt files one directory level down, so all files in any of the following folders:
- noisyData
- randomTableData
- randomTables
Such text files are used to aid in random question generation. These files are read during `pl-sql-element.py`'s `prepare()` function when this library is invoked. The files hold lists of example data, where items are randomly chosen to create "clean" looking data. The `noisyData` file contains common values for strings/VARCHAR datatypes; `randomTableData` contains names for tables, columns (with specifications for both RelaX and SQL table metadata), and a file that maps a column name to the appropriate file in `noisyData`; and, `randomTables` contains table DDL statements for various tables, but this is only used in difficulty-type questions for autogenerate CREATE questions.


## noisyData

This Python file generates random data given an SQL data type. If the column name matches against a list, a random value is drawn from the appropriate text file; this is done to generate human-readable random data. Otherwise, if the column name does not match, "noisy" random data is generated instead. This noisy data is worse than gibberish for data types such as VARCHAR or CHAR (since generating human-readable gibberish is difficult), but are generated from constrained ranges for data types such as INTEGER or DATETIME (and as such are human-readable).


### generateNoisyData(table, key, qty=1)

When an array of random data is desired, this function is called and it is responsible for calling the appropriate data-generating function. The `table` and `key` (a.k.a. column) parameters are used to determine the data-type of the column as well as whether or not to enforce distinct values. This function also checks if the column (`key`) is mapped to a file in the `noisyData` folder and, if so, grabbing values from said folder.


### generateNoisyDataNoFile(table, key, qty=1, unique=False)

If the key was not mapped to a file in `noisyData`, as determined by `generateNoisyData()`, then this function checks whether or not the table is a RelaX table or an SQL table, calling the next function as appropriate.


### generateNoisyDataNoFileSQL(table, key, qty=1, unique=False)

If the key was not mapped to a file in `noisyData`, as determined by `generateNoisyData()`, and the table was found to be an SQL table, as determined by `generateNoisyDataNoFile()`, then this function obtains the data-type and the data-type's metadata to determine which specific data-generating function to call.  
The possible data-types are: INTEGER, DECIMAL, CHAR, VARCHAR, DATE, and DATETIME.


### generateNoisyDataNoFileRelaX(table, key, qty=1, unique=False)

If the key was not mapped to a file in `noisyData`, as determined by `generateNoisyData()`, and the table was found to be a RelaX table, as determined by `generateNoisyDataNoFile()`, then this function obtains the data-type and the data-type's metadata to determine which specific data-generating function to call.
The possible data-types are: NUMBER, DATE, and STRING.  
In the case that the data-type is NUMBER and the key is `price`, then this function will return a float/decimal value. Otherwise, when the data-type is NUMBER, it will return an integer.


### generateNoisyInteger(unique, qty)

This function generates and returns an array of integers of size `qty` from the range [1, 1000].  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyDecimal(unique, qty, unitOther)

This function generates and returns an array of floats of size `qty`. `unitOther` is of the form `x,y` where `x` is the total number of digits and `y` is the decimal precision; this floats generated by this function range from `[1, 10 ^ (x - y) + 1)`. While `y` may be any number smaller than `x`, in practice `y` is always 2 since the numbers are automatically rounded to two decimals places when displayed. `x - y` is enforced to be no larger than 3, such that the greatest values generated it about 1000, since larger numbers are unwieldly for the purpose of queries.  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyChar(unique, qty, unitOther)

This function generates and returns an array of strings of size `qty` that contain all uppercase letters and the ten deicmal digits. Each string generated will be of exactly `unitOther` length.  
If `unique` is true, then the returned array is guaranteed to contain only unique values. There is a counter that increments each time a value is generated. If this counter reaches a certain value and the value generated is not unique, it will instead add the string `NULL` to the array. This is done to prevent timeouts when `unitOther` is small compared to quantity and to speed up data generation when few unique values remain.


### generateNoisyVarchar(unique, qty, unitOther)

This function generates and returns an array of strings of size `qty`. The lenght of each string ranges from (1, unitOther). This function calls `generateNoisyChar()` with a `qty` of 1 and a random `unitOther` in a range (1, `unitOther`).  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyDate(unique, qty)

This function generates and returns an array of strings of size `qty` of the form `yyyy-mm-dd`. The month is randomly chosen from (1, 12) and the day is chosen from a range suitable frm the month; this function can never generate a 29th day in February. The year is chosen from the range (1955, 2023).  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateNoisyDateTime(unique, qty)

This function generates and returns an array of strings of size `qty` of the form `yyyy-mm-dd hh:mm:ss`. The date portion is obtained through a call of `generateNoisyData` and the hour is random integers from the appropriate range. The minute is generated to be an increment of five and the seconds are always zero; this is done to make the generated DATETIMEs less cumbersome.  
If `unique` is true, then the returned array is guaranteed to contain only unique values.


### generateFromFile(qty, choices, choose)

This funciton is called by `generateNoisyData()` when the key corresponds to a file; the values from the file are placed into the `choices` parameter. It returns an array of size `qty` of values from the array `choices` where the function `choose` is called to determine whether to pick values with or without replacement. `choose` is either the `popRandom()` or `selectRandom()` function. If `popRandom()` is called then the values are unique, otherwise they are not unique.


### generateColumns(table, qty=1)

This function returns a dictionary where each key is a column of the table and the values are an array of size `qty` of data whose data-type matches the column's unit. The table's columns are iterated over and for each column the `generateNoisyData()` function is called.


### relativeFilePath(file)

This function returns the path the file called `file` in the `noisyData` folder. To obtain the path, this function calls `absoluteDirectoryPath()`.
The `fileName` should not include an extension. The extension is assumed to be `.txt`.


### absoluteDirectoryPath()

This function obtains the path to the current directory. If the `/RASQLib` is in this path, the path is returned. Otherwise the path is travelled up to the parent of the `/elements` directory then down into `/RASQLib`; this new path is returned.  
This function is necessary since PrairieLearn changes the directory layout at runtime. In order to run test on DroneCI, the filepath needs to be changed from what it would be on PrairieLearn.


### readLines(fileName)

Given the name of a file from `noisyData`, this function opens that file and returns an array the file's lines, excluding whitespace lines.  
The `fileName` should not include an extension. The extension is assumed to be `.txt`.


### getColumnToFileMap(path=f"{absoluteDirectory}/randomTableData/columnToFile.txt")

This function reads and parses the file `columnToFile` and returns a dictionary whose key is a column name and the value in the file in `noisyData` that contains the appropriate values.


### isUnique(table, key)

This function checks whether or not a given column of a table may only contain unique values.  
The columns that may only contain unique values are primary key columns, foreign key columns, or columns with the UNIQUE clause.


### popRandom(values, weights=[])

This function will pop a random value of the the array `values` and return it. If `weights` are provided, the array must be of the same dimensions as the `values` array; they will increase the likelihood of the value of the weight's matching index to be popped. If `weights` are not provided, all values have an equal likelihood of being popped.  
A popped item is removed from the array. If this function is called multiple times on the same array, then it cannot select duplicate values.  
If the `values` array is emtpty, this function returns `NULL`.


### selectRandom(values, weights=[])

This function will select a random value of the the array `values` and return it. If `weights` are provided, the array must be of the same dimensions as the `values` array; they will increase the likelihood of the value of the weight's matching index to be selected. If `weights` are not provided, all values have an equal likelihood of being selected.  
A selected item is not removed from the array. If this function is called multiple times on the same array, then it may select duplicate values.  
If the `values` array is emtpty, this function returns `NULL`.


## noisyData_test

This file contains a suite of tests for the `noisyData.py` file.


## textDatabaseHandler

The text database handler models a simplified database and table system, used to assist random question generation. Its functionality focuses on a group table as a set of columns and a set of rows as well as converting text file-stored values into memory. It is also responsible for calling methods to generate data to populate the various table's rows, ensuring the rows conform to foreign key constraints, providing dictionaries that allow easy parsing on the structure of the databse, and loading the database's tables' columns and rows into memory.


### Database class

This class is responsible for keeping track of all the tables as well as performing operations on all tables. It also keeps track whether they are RelaX or SQL tables.  
The connections between RelaX tables are structured as a tree with a depth of `depth`. SQL tables are a tree with a depth of one; in other words, the root table is the only table to contain references.


#### generateRows(self, qty)

This method determines whether the database contains RelaX or SQL tables and then call the appropirate method. After this method is called, the tables are all filled with rows of randomly generated data.


#### generateRowsSQL(self, qty)

This method first generates for the root table (a.k.a. the primary table) by calling the table's `generateRows()` method then it calls the same method on all the referenced tables. At this point, foreign key constraints are violated. The method then iterates over all rows in the primary table that are a foreign key and override the referenced column in the referenced table to match the column of the primary table, thereby enforcing foreign key constraints.


#### addRowsBackend(self, conditionalValues)

This method adds the values from `conditionalValues` into the backend rows of the tables. `conditionalValues` is a dictionary whose key is a column and whose value is some random data whose data-type matches the column's unit. For each value in `conditionalValues`, this method will create a row that includes the value and the other columns of the row contain random data; each row is added to the appropriate table's backend rows.


#### generateRowsBackend(self, qty=0)

This method generates a number of rows for each table's backend rows equal to `qty` minus that table's current count of backend rows such that each table will have `qty` number of rows regardless of how many starting rows the table had. For each table, this funciton calls the table's `generateRowsBackend()` method with a `qty` a previously determined. After all the backend rows are generated, it enforces foreign key constraints by overriding foreign columns.


#### loadColumns(self, data)

This method loads each table's CREATE statement into the data variable. The CREATE statements are placed in `data['params']['db_initialize_create']`.  
This method first loads the referenced tables and then the root (a.k.a primary) table. This order prevents foreign key constraint violations.


#### loadRows(self, data)

This method loads each table's INSERT statements for all its rows into the data variable. The INSERT statements are placed in `data['params']['db_initialize_insert_frontend']`. This method only loads the rows for the frontend database, the one the users will directly access.  
This method first loads the referenced tables and then the root (a.k.a primary) table. This order prevents foreign key constraint violations.


#### loadRowsBackend(self, data)

This method loads each table's INSERT statements for all its rows into the data variable. The INSERT statements are placed in `data['params']['db_initialize_insert_backend']`. This method only loads the rows for the backend database, the one the users will not directly access but their results will be graded against.  
This method first loads the referenced tables and then the root (a.k.a primary) table. This order prevents foreign key constraint violations.


#### loadDatabase(self, data)

This method calls all the necessary functions to load each table and all their rows, both rows for the frontend and the backend.


#### getTableMap(self)

The table map returned is a dictionary whose key is the name of the foreign key column and whose value is the referenced table. There is also a key that is the root (a.k.a primary) table's name and whose value is the root table.


#### getColumnMap(self, tableName=True)

The column map returned is a dictionary whose key is a column name and whose value is the table to which that column belongs.  
Is `tableNames` is set to true, then the dictionary's value is the string name of the table. If `tableNames` is false, then the value is the table object.


#### __str__(self)

The database's to-string method returns a string of each table's CREATE statement. This function should not be used to load the databases into the data variable since the order of the CREATE statements will cause a foreign key constraint error.


### Table class

The table object is responsible for tracking a table's columns, rows (for both the frontend and the backend), as well as methods to create and load the table.  
Frontend rows are loaded into the database the user will see on the question, thus the user can query and manipulate this database. The backend rows are loaded into a seperate database and are used to compare the user's answer to the solution. The data in these rows are different from one another and this is to prevent students from creating an answer that matches the expected output rather than creating an answer that matches the question.

#### load(self, file, columns, joins, clauses, constraints, random, columnNames)

The load method is called upon the initialisation of the table and it determines whether to call the method to create a random or a static table (as defined by the `random` parameter). It will either call `loadFromText()` or `loadRandom()`.


#### loadFromText(file)

If the table is a static table (that is to say that `random` is false), then this method will read the file provided to and use it to create the table. The file is open and each line is read. The lines are parsed through to determine and set the table's metadata.  
The layout of the file is of the form of a simple DDL file, so it contains the CREATE statement for a single table.


#### loadRandom(slef, name, columns, joins, clauses, constraints, columnNames)

If the table is a static table (that is to say that `random` is false), then this method will generate a table as specified by the parameters passed to the method. It first checks if the parameters are valid and if not, it exits and prints the issue.  
If the `name` parameter was not specified or is an empty string, then it the table will randomly choose a name from the array returned by the function `getRandomTableNames()`.  
`constraints` are used to ensure that specific columns appear in the table and are used to ensure that the primary table has at least one column with the integer unit (which helps create better queries) and to ensure that referenced tables contain specified columns. Each provided constraint is iterated over and an appropriate column is added to the table. Column created through these constraints are assumed to be primary keys.  
This method next adds columns until there is an amount equal to what was specified by `columns`. It first pops a column from the provided `columnNames` array; the pop ensures that column names are unique. There is a chance that due to contraints specifying a column, there exists a duplicate column so a sinlge check if performed to fix this issue. The data contained in `columnNames`–which is limited to a name, a data-type, and data-type infomration–is then used to create the column.  
The next step is to add joins until there are an amount of joins equal to the `joins` parameter. A random column from the table is selected without replacement (and this selection heavily prefers to avoid columns that contain 'Airport' or 'province' due to uniqueness issues during data generation). It them selects a random table name without replacement and specifies that this column is a foreign key to newly obtained table name. It them adjusts the two column names, both the foreign key column and the referenced column, to ensure that the names are unqiue.  
Finally the method iterates over `clauses`. The `clauses` specify how many primary keys, NOT NULL, UNIQUE, ON UPDATE CASCADE, and ON DELETE SET NULL clauses are in this table. For each clause in `clauses`, a valid column is selected and set to match the clause. On each check, there is a counter that ensures there is no timeout in the case there is not a valid column; if there would be a timeout, the clause is ignored.


#### getReferencedTables(self, unique=True, static=False, columnNames=[])

This method is called during the instantiation of a `Database` object after the primary (a.k.a root) table is created. It iterates over all the columns of the table and for each foreign key column it will create an appropriate table by specifying constraints. A dictionary is returned where the key is the name of the foreign key column and the value is the table object.  
If `unique` is false then, if the table has multiple foreign key columns that reference the same same table, that table may appear multiples times as values in the dictionary. Otherwise, if `unique` is true, a given table may only appear once.  
If `static` is false then the generated tables are random. Otherwise, if `static` is true, then the tables will not be random.


#### getKeyMap(self)

The key map is a dictionary whose keys are foreign key columns and whose values are another dictionary. This secon dictionary has keys `'references'` which is the name of the referenced table and `'foreignKey'` which is the column referenced.


#### getPrimaryKeys(self)

This method returns a dictionary whose keys are the names of all primary key columns and whose values are the columns.


#### generateRows(self, qty)

This method will generate rows and set its rows using `noisyData.generateColumns()`.


#### generateRowsBackend(self, qty)

This method will generate rows and set its backend rows using `noisyData.generateColumns()`.


#### addRows(self, row, index=0)

This method will add the `index`-th row from `row` to the table's rows.


#### addRows(self, row, index=0)

This method will add the `index`-th row from `row` to the table's backend rows.


#### getSQLSchema(self)

This method will return a string of the table's DDL CREATE statement.


#### getInserts(self)

This method will return a string of the table's DDL INSERT statements for all its rows.


#### getInsertsBackend(self)

This method will return a string of the table's DDL INSERT statements for all its backend rows.


#### __str__(self)

This to-string method will return the table's schema as a string.


### Helper functions for textDatabaseHandler

#### relativeTableFilePath(file)

This function returns the path the file called `file` in the `/randomTables` folder. To obtain the path, this function calls `absoluteDirectoryPath()`.
The `file` should not include an extension. The extension is assumed to be `.txt`.


#### relativeTableDataFilePath(file)

This function returns the path the file called `file` in the `/randomTableData` folder. To obtain the path, this function calls `absoluteDirectoryPath()`.
The `file` should not include an extension. The extension is assumed to be `.txt`.


#### absoluteDirecotryPath()

This function obtains the path to the current directory. If the `/RASQLib` is in this path, the path is returned. Otherwise the path is travelled up to the parent of the `/elements` directory then down into `/RASQLib`; this new path is returned.  
This function is necessary since PrairieLearn changes the directory layout at runtime. In order to run test on DroneCI, the filepath needs to be changed from what it would be on PrairieLearn.


#### getStaticSchema(file)

This function returns the DDL CREATE statement from the specified file in `/randomTables`.
The `file` should not include an extension. The extension is assumed to be `.txt`.


#### getAllTableFiles(path=f"{absoluteDirectoryPath()}/randomTables")

This function returns an array of all files in `/randomTables` without their extension.


#### getRandomTableNames(path=relativeTableDataFilePath('randomTableNames'))

This function returns an array of all random tables names as specified in the folder `randomTableNames`.


#### parseColumnsFromFile(file)

This function returns an array of column data of the form [name of the column, data-type of the column]. If the data-type metadata is specified, the form of the returned array's items are instead [name of the column, data-type of the column, data-type metadata of the column].  
The file is a text file that follows the form of a CSV file that matches the arrays previously described.


#### parseRange(string)

Given a string, returns the range the string describes. The string is deliminated by en-dashes ('-'). If the string contains no dashes, then it is returned unchanged. Otherwise if the form of the string follows `x-y` it returns `range(x, y + 1)`. If the string follows the form `x-y-z` it returns `range(x, y + 1, z)`.


## textDatabaseHandler_test

This file contains a suite of tests for the `textDatabaseHandler.py` file.
