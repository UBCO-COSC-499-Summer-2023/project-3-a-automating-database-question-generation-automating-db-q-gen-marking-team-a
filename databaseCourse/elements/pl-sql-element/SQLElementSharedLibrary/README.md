# SQLElementSharedLibrary

## __init__

Python libraries require an `__init__.py` file to be recognized as a library. The file is blank since it is only required to be present such that this folder is recognized as a library.


## Text Files

Text files include all the .txt files one directory level down, so all files in any of the following folders:
- lab2Databases
- lab3Databases
Such text files are used to hold DDL for static lab questions. These files are read during `pl-sql-element.py`'s `prepare()` function


## SQLAutogenerator

The autogenerator is responsible for creating random questions and initializing the front-end databases accordingly.


### autogenerate(data)

The autogenerate function calls the appropriate question generation function as specified by the passed HTML parameters, which were stored in the `data` variable. This function is called by `pl-sql-element.py` during its `prepare()` function.  
If a query-type question was generated and its expected output is empty, it re-generates the question until the expected output is not empty. This is done to prevent a question where the student see no expected output.


### generateCreate(data, difficulty)

This function creates a random question for the CREATE-style question. 
If a difficulty is used for this quesiton rather than HTML parameters, the question will load a static DDL file as appropriate for the difficulty. If HTML parameters are used for this question rather than a diffuclty, a random table is generated using the HTML parameters. Either way, the question text is generated by parsing the table.  
If the question's table references other tables, the referenced tables are loaded into the database. Of course, the table for the question itself is not loaded into the database.
The solution is set by calling the `createStatement()` function, which returns the formatted SQL CREATE statement for the table.


### createStatement(database)

The create statement function makes a CREATE statement for a given table. It does so by calling the table's `getSchema()` method.  
This function is called by `generateCreate()` to set the solution.


### generateInsert(data, difficulty)

This function creates a random question for the insert-style question. 
Based on the difficulty and specified parameters of the question, it will generate a table appropriately. It will then generate rows for each table.  
From the primary table, one row will be removed; this row of data is used to create the question string and will be the rows the user will insert into the table. By removing it from the primary table, it is guaranteed that inserting it will not violate and foreign key constraints.  
The question text is then generated.  
All tables are loaded into the database along with rows, excluding the row the user is to insert.  
The solution is set by calling the `insertStatement()` function, which returns the formatted SQL INSERT statement with the values of the row.


### insertStatement(database, row)

The insert statement function creates an INSERT statement for a given table and a given row of data. It returns a string of the statement.
This function is called by `generateInsert()` to set the solution and it is also called during `Database.loadDatabase()` to set the database initialisation string in `data`.


### generateUpdate(data, difficulty)

This function creates a random question for the UPDATE-style question. 
Based on the difficulty and specified parameters of the question, it will generate a table appropriately. It will then generate rows for each table.  
A random column from the primary table is chosen. This column cannot be a primary key, be a foreign key, or have the UNIQUE constraint since updating such a column would likely violate uniqueness. If it fails to find such a column, it will attempt to use a unique column. A random value appropriate for the selected column is generated using `noisyData.generateNoisyData()` which will be the value to which the table is updated.  
A series of conditional values are selected from the table using `getConditionalValues()` if necessary. These values are present on both the frontend and the backend databases.  
If the question uses a subquery, `generateSubquery()` is used to generate it.  
The question text is then generated.  
All tables are loaded into the database along with their rows.  
The solution is set by calling the `updateStatement()` function, which returns the formatted SQL UPDATE statement corresponding to the parameters.


### updateStatement(database, updateColumn, updateValue, conditionalValues=None, subquery='')

The update statement function creates an UPDATE statement for a given table.  
The updateColumn parameter determines which column will be updated and it will be updated to match updateValue. If there are conditionalValues, it will generate a statement where values from the conditionalColumn's column match conditionalValue's value. If there is a subquery, it is included.  
This function is called by `generateUpdate()` to set the solution.


### generateDelete(data, difficulty)

This function creates a random question for the DELETE-style question.  
Based on the difficulty and specified parameters of the question, it will generate a table appropriately. It will then generate rows for each table.  
A series of conditional values are selected from the table using `getConditionalValues()` if necessary. These values are present on both the frontend and the backend databases.  
If the question uses a subquery, `generateSubquery()` is used to generate it.  
All tables are loaded into the database along with their rows.  
The question text is then generated.  
The solution is set by calling the `deleteStatement()` function, which returns the formatted SQL DELETE statment corresponding to the parameters.


### deleteStatement(database, conditionalValues=None, subquery='')

The update statement function creates an DELETE statement for a given table.  
If there are conditionalValues, they are used to specify which values are to be deleted. If there is a subquery, it is included.  
This function is called by `generateDelete()` to set the solution.


### generateQuery(data, difficulty)

This function creates a random question for the query-style question.  
Based on the difficulty and specified parameters of the question, it will generate a table appropriately. It will then generate rows for each table.  
This function selects a number of columns from the database using `selectColumns()`.  
From these columns, if the question uses query functions, at least one will have a function applied to it; for every other column, there is a random chance it will be chosen to have a query applied to it.  
A series of conditional values are selected from the table using `getConditionalValues()` if necessary.  
Each table to which at least one selected columns belongs will be assigned a type of join. The different types of joins are randomly chosen with a weight to bias the query's output to be reasonable.  
If the `orderBy` parameter is non-zero, then random columns that are present in the joined tables are chosen to be included in the order by clause. When a column is chosen, it is randomly assigned either `'ASC'` or `'DESC'` will equal likelihood.  
If the `groupBy` parameter is non-zero, then random columns that are among the selected columns are chosen to be included in the group by clause.  
If the `having` parameter non-zero, then random columns are chosen from the columns that are part of the group by clause. These columns are giving an appropriate conditional value.  
If the question uses a subquery, `generateSubquery()` is used to generate it.  
The question text is then generated.  
All tables are loaded into the database along with rows, excluding the row the user is to insert.  
The solution is set by calling the `queryStatement()` function, which returns the formatted SQL SELECT statment corresponding to the parameters.  
If the question is set to display the expected output, the output is obtained through the `createPreview()` function.  
This function does not excplicitly support column aliasing. This is because the grading schema does not inspect column names; as such, column aliasing is useless from the student's perspective. A student may alias columns in their query as they wish and it will not affect the grading of their answer.  


### queryStatement(database, selectedColumns, joinTypes={}, conditionalValues={}, orderByColumns={}, groupByColumns={}, havingColumns={}, withColumns={}, limit=0, isDistinct=False, functionColumns={}, subquery='')

This function adds all the parameters from the function header into a string that is a SQL SELECT statement for the given table.  
If no columns are in the selectedColumns parameter, it instead selects all columns (as is done through '*').  
This function is called by `generateQuery()` to set the solution.


### generateSubquery(database)

This function returns both the SQL SELECT statement subquery as well as the appropriate question text.  
This function calls `subqueryStatement()` to obtain the SQL statement and `subqueryQuestionString()` to generate the question string. The function itself is responsible for choosing the table, the query functions, comparison operators, and the such.  
When selecting a column to appear in the SELECT subquery, different column data-types are assigned weights. These weights were chosen such that the expected output will return a reasonable number of rows. The main factor in what determined the weights were the number of query functions that data-type supports. Additionally, these columns must be from a table that is not in the primary table but there exists at least one column in the primary table that shares its data-type.  
If query functions cannot be used, which is the case when the primary table does not contain any columns whose data-type are INTEGER or DECIMAL, then the comparison operator is `'IN'` and the conditional column must be the same data-type as the selected column. Otherwise, if query functions can be used, then the conditional column must have a data-type of INTEGER or DECIMAL; these data-types can be compared to the results of query funcitons. The exception to this are columns with a data-type of either DATE or DATETIME which notably can be compared to other DATE and DATETIME columns on which a query function was performed.  
If query functions can be used, then an appropraite comparison operator is chosen for the data-type of the selected column; this is done through the `getQueryFunction()` function.  
There is a random chance that conditional values are included in the subquery. If they are included, it is weighted such that it is unlikely many conditional statements will be included. Generating these conditional values is done using `getConditionalValues()`.  
Based on the query function, an appropriate comparison operator is selected. It is heavily weighted to choose a comparison operator that is likely to return a reasonable output.  
Finaly, it obtains both the subquery statement and its corresponding question string and returns them.  
It is called by `generateUpdate()`, `generateDelete()`, and `generateQuery()` in the case that the useSubquery parameter in the respective function is true. 


### subqueryQuestionString(database, conditionalColumn, comparisonOperator, selectedColumnName, queryFunction='', conditionalValues={})

This function adds all the parameters from the function header into human-readable text that corresponds to an SQL SELECT statement subquery for the given subquery.  
This function is called by `generateSubquery()`.


### subqueryStatement(conditionalColumn, comparisonOperator, tableName, selectedColumnName, queryFunction='', conditionalValues={})

This function adds all the parameters from the function header into a string that is a SQL SELECT subquery statement for the given table.  
This function is called by `generateSubquery()`.


### getColumnList(tableMap, columnNames=True)

This function returns an array containing all columns from the supplied tableMap dictionary.  
If columnNames is true, then the array only contains the column's names (in other words, their key). If it is false, it instead returns an array of references to the columns themselves.


### selectColumns(columnsToSelect, database)

This function returns a dictionary whose keys are table names and whose values are an array of columns belonging to that table. The total count of columns equals ot the columnsToSelect parameter.


### getQueryFunction(database, key, conditionalValues={}, useIn=True)

This function returns a string that is an SQLite query function.  
The function will choose a query function based on the data-type of the key parameter. The query function is randomly chosen among applicable query functions but is weighted to be a query function that is likely to return a reasonable output.  
If conditionalValues is not empty, then the weights are altered such that it is likely to return a reasonable output given the subquery uses conditional values.  
If useIn is true, then a data-type of CHAR may use the `'IN'` comparison operator. If it is false, it cannot.  


### removeTrailingChars(string, qty=1, condition=True)

This function returns the supplied string after it has been altered. It will remove a number of characters at the end of the string equal to the qty parameter and it will only do so if the condition is true.  
This function is extensively used when generating question text for questions.  


### dictionaryQuestionString(dictionary, string='', iterations=None, index=0, tab='b')

This function returns the supplied string after appending a human-readable list of items as contained by the supplied dictionary.  
If no string is supplied, it will instead return the list of items rather than appending them to the string.  
The iterations and index parameters are used to keep the list grammatically correct in terms of commas and 'and's. They are used is multiple dictionaries need to be appended without unecessary commas or 'and's.  
The tag parameter is used to determine the HTML tag, if any, should be added around each item listed.  
This function is used to help create the question text of most question types.  


### conditionalStatement(column, condition)

This function is depracated. Instead, the `statementConditionals()` function should be used.  
This function returns a string that corresponds to a single conditional in an SQL statement. The comparison operator is always '='.  


### questionConditionals(conditionalValues, string='')

This function returns the supplied string after appending a human-readable set of conditions.  
The conditionalValues parameter is a dictionary whose key is the column in the condition. The value is another dictionary with a key for the comparison operator, for the boolean connector, and for the value that the column is compared to.  
If no conditional values are supplied, it returns the string.  
If no string is supplied, it will instead return the list of conditions rather than appending them to the string.  
This function is used to help create the question text of most question types in the case that question instance requires conditions.  


### statementConditionals(statement='', conditionalValues={}, clauseType=' WHERE')

This function returns the supplied string after appending the SQL set of conditions.  
The conditionalValues parameter is a dictionary whose key is the column in the condition. The value is another dictionary with a key for the comparison operator, for the boolean connector, and for the value that the column is compared to.  
If no conditional values are supplied, it returns the string.  
If no string is supplied, it will instead return the list of conditions rather than appending them to the string.  


### getConditionalValues(conditionals, database, columnList=[], restrictive=True)

This function returns a set of conditions and how they are connected.  
The conditionalValues, which are returned, is a dictionary whose key is the column in the condition. The value is another dictionary with a key for the comparison operator, for the boolean connector, and for the value that the column is compared to.  
This function will select a number of columns equal to the conditionals parameter from the columnList parameter. Each column is assigned a weight that will affect the chance of its selection depending on its data-type. The weighting decreases the likelihood VARCHAR and CHAR columns from being selected since they have less and worse (in terms of query results) compariosn operators. The same column cannot be chosen twice for two different conditions.  
This function may return less conditional values than called for by the conditionals parameter. This can occur when the supplied columnList parameter contains an insuffient amount of applicable columns.  
For each column selected, it will randomly assign it with a boolean connector: either 'and' or 'or'. This random assignment is weighted such that 'or' is more likely since the 'or' connector will produce a query with more rows than one with an 'and' connector.  
For each column selected, it will randomly assign it with an applicable comparison operator. These comparison operators are weight such that the operator used will likely produce a reasonable output.  
For each column selected, a random index is chosen from all rows in the table's rows. This index along with the selected column is used on the appropriate table's rows to get one of its values. The same index cannot be chosen twice for two different conditions.  
The column, obtained value, comparison operator, and logical connector is used to set a dictionary entry in the returned conditionalValues parameter.  
If the columnList parameter was not supplied, it is generated by the `getColumnList()` function called on all tables in the database.  
If restrictive is true, then any column that is a foreign key column but does not cascade when updated cannot be selected for a condition.  


### getQuestionParameters(data)

This function unpacks and returns parameters from the data variable.  
If keys in the data variable do not exist, which can only happen through the DroneCI testing pipeline, then it also creates those keys and sets default values.  
This function is called by all question types generation functions.  


### loadTrimmedDatabase(columnCount, joinCount=0)

This function is depracated. It has been replaced by `textDatabaseHandler`'s `Table` object.  
This function returns a table as defined in a static DDL file except with a number of columns trimmed off such that the resulting table has the columnCount parameter number of columns. It will not remove columns that are primary keys, and it will not remove columns that are foreign keys if it would result in a table will less than the joinCount parameter's number of foreign keys.  
If the function cannot trim off enough columns due to it violating the supplied parameters, then it returns the table with more columns than specified.  


### createPreview(data)

This function returns the HTML table corresponding to the expected output of the solution defined in the data variable.  
It obtains the SQL commands to create the table and to populate it with the appropriate data. It then establishes the connection to the database and runs the command. It then obtains the correct solution and runs that as a command on the database. The result are then stitched together with HTML tags to create the string of a table which is returned.  
The number of rows displayed is limited. If too many rows were to be displayed, then PrairieLearn's renderer will break and the unrendered HTML will spill onto the page.  
This function is called during `generateQuery()` to obtain the expected output.  

