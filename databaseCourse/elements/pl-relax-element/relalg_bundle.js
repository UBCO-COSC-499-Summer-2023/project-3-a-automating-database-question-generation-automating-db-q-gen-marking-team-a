// $(document).ready(function(){
(function(f){
  if(typeof exports==="object"&&typeof module!=="undefined"){
    module.exports=f()
  }else if(typeof define==="function"&&define.amd){
    define([],f)
  }else{
    var g;
    if(typeof window!=="undefined"){
      g=window
    }else if(typeof global!=="undefined"){
      g=global
    }else if(typeof self!=="undefined"){
      g=self
    }else{
      g=this
    }
    g.relalg_bundle = f()
  }
})

(function(){

  var define,module,exports;
  return (function(){
    function r(e,n,t){
      function o(i,f){
        if(!n[i]){
          if(!e[i]){
            var c="function"==typeof require&&require;
            if(!f&&c)
              return c(i,!0);
            if(u)
              return u(i,!0);
            var a=new Error("Cannot find module '"+i+"'");
            throw a.code="MODULE_NOT_FOUND",a
          }
          var p=n[i]={exports:{}};
          e[i][0].call(p.exports,function(r){
            var n=e[i][1][r];
            return o(n||r)
          }, p,p.exports,r,e,n,t)
        }
        return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],2:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],3:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],4:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],5:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],6:[function(require,module,exports){
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],7:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],8:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./setPrototypeOf.js":12}],9:[function(require,module,exports){
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],10:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],11:[function(require,module,exports){
var _typeof = require("./typeof.js")["default"];
var assertThisInitialized = require("./assertThisInitialized.js");
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./assertThisInitialized.js":3,"./typeof.js":14}],12:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],13:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles.js");
var iterableToArray = require("./iterableToArray.js");
var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");
var nonIterableRest = require("./nonIterableRest.js");
function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
}
module.exports = _toArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./arrayWithHoles.js":2,"./iterableToArray.js":9,"./nonIterableRest.js":10,"./unsupportedIterableToArray.js":15}],14:[function(require,module,exports){
function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],15:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray.js");
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./arrayLikeToArray.js":1}],16:[function(require,module,exports){
'use strict';

var _typeof = require('@babel/runtime/helpers/typeof');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');
var _inherits = require('@babel/runtime/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _toArray = require('@babel/runtime/helpers/toArray');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _toArray__default = /*#__PURE__*/_interopDefaultLegacy(_toArray);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var consoleLogger = {
  type: 'logger',
  log: function log(args) {
    this.output('log', args);
  },
  warn: function warn(args) {
    this.output('warn', args);
  },
  error: function error(args) {
    this.output('error', args);
  },
  output: function output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};

var Logger = function () {
  function Logger(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck__default['default'](this, Logger);

    this.init(concreteLogger, options);
  }

  _createClass__default['default'](Logger, [{
    key: "init",
    value: function init(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.prefix = options.prefix || 'i18next:';
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.forward(args, 'log', '', true);
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this.forward(args, 'warn', '', true);
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this.forward(args, 'error', '');
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug) return null;
      if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function clone(options) {
      options = options || this.options;
      options.prefix = options.prefix || this.prefix;
      return new Logger(this.logger, options);
    }
  }]);

  return Logger;
}();

var baseLogger = new Logger();

var EventEmitter = function () {
  function EventEmitter() {
    _classCallCheck__default['default'](this, EventEmitter);

    this.observers = {};
  }

  _createClass__default['default'](EventEmitter, [{
    key: "on",
    value: function on(events, listener) {
      var _this = this;

      events.split(' ').forEach(function (event) {
        _this.observers[event] = _this.observers[event] || [];

        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event]) return;

      if (!listener) {
        delete this.observers[event];
        return;
      }

      this.observers[event] = this.observers[event].filter(function (l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function (observer) {
          observer.apply(void 0, args);
        });
      }

      if (this.observers['*']) {
        var _cloned = [].concat(this.observers['*']);

        _cloned.forEach(function (observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);

  return EventEmitter;
}();

function defer() {
  var res;
  var rej;
  var promise = new Promise(function (resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null) return '';
  return '' + object;
}
function copy(a, s, t) {
  a.forEach(function (m) {
    if (s[m]) t[m] = s[m];
  });
}

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  function canNotTraverseDeeper() {
    return !object || typeof object === 'string';
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();

    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }

  if (canNotTraverseDeeper()) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}
function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);

  if (value !== undefined) {
    return value;
  }

  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== '__proto__' && prop !== 'constructor') {
      if (prop in target) {
        if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }

  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
var _entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;'
};
function escape(data) {
  if (typeof data === 'string') {
    return data.replace(/[&<>"'\/]/g, function (s) {
      return _entityMap[s];
    });
  }

  return data;
}
var isIE10 = typeof window !== 'undefined' && window.navigator && typeof window.navigator.userAgentData === 'undefined' && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;
var chars = [' ', ',', '?', '!', ';'];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || '';
  keySeparator = keySeparator || '';
  var possibleChars = chars.filter(function (c) {
    return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;
  });
  if (possibleChars.length === 0) return true;
  var r = new RegExp("(".concat(possibleChars.map(function (c) {
    return c === '?' ? '\\?' : c;
  }).join('|'), ")"));
  var matched = !r.test(key);

  if (!matched) {
    var ki = key.indexOf(keySeparator);

    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }

  return matched;
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
  if (!obj) return undefined;
  if (obj[path]) return obj[path];
  var paths = path.split(keySeparator);
  var current = obj;

  for (var i = 0; i < paths.length; ++i) {
    if (!current) return undefined;

    if (typeof current[paths[i]] === 'string' && i + 1 < paths.length) {
      return undefined;
    }

    if (current[paths[i]] === undefined) {
      var j = 2;
      var p = paths.slice(i, i + j).join(keySeparator);
      var mix = current[p];

      while (mix === undefined && paths.length > i + j) {
        j++;
        p = paths.slice(i, i + j).join(keySeparator);
        mix = current[p];
      }

      if (mix === undefined) return undefined;
      if (mix === null) return null;

      if (path.endsWith(p)) {
        if (typeof mix === 'string') return mix;
        if (p && typeof mix[p] === 'string') return mix[p];
      }

      var joinedPath = paths.slice(i + j).join(keySeparator);
      if (joinedPath) return deepFind(mix, joinedPath, keySeparator);
      return undefined;
    }

    current = current[paths[i]];
  }

  return current;
}

var ResourceStore = function (_EventEmitter) {
  _inherits__default['default'](ResourceStore, _EventEmitter);

  var _super = _createSuper(ResourceStore);

  function ResourceStore(data) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ns: ['translation'],
      defaultNS: 'translation'
    };

    _classCallCheck__default['default'](this, ResourceStore);

    _this = _super.call(this);

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized__default['default'](_this));
    }

    _this.data = data || {};
    _this.options = options;

    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = '.';
    }

    if (_this.options.ignoreJSONStructure === undefined) {
      _this.options.ignoreJSONStructure = true;
    }

    return _this;
  }

  _createClass__default['default'](ResourceStore, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);

      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path = [lng, ns];
      if (key && typeof key !== 'string') path = path.concat(key);
      if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
      }

      var result = getPath(this.data, path);
      if (result || !ignoreJSONStructure || typeof key !== 'string') return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === undefined) keySeparator = '.';
      var path = [lng, ns];
      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
        value = ns;
        ns = path[1];
      }

      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options.silent) this.emit('added', lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        silent: false
      };

      for (var m in resources) {
        if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
          silent: true
        });
      }

      if (!options.silent) this.emit('added', lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns];

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
        deep = resources;
        resources = ns;
        ns = path[1];
      }

      this.addNamespaces(ns);
      var pack = getPath(this.data, path) || {};

      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);
      }

      setPath(this.data, path, pack);
      if (!options.silent) this.emit('added', lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }

      this.removeNamespaces(ns);
      this.emit('removed', lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== undefined;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns) ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === 'v1') return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data = this.getDataByLanguage(lng);
      var n = data && Object.keys(data) || [];
      return !!n.find(function (v) {
        return data[v] && Object.keys(data[v]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);

  return ResourceStore;
}(EventEmitter);

var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;

    processors.forEach(function (processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var checkedLoadedFor = {};

var Translator = function (_EventEmitter) {
  _inherits__default['default'](Translator, _EventEmitter);

  var _super = _createSuper$1(Translator);

  function Translator(services) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck__default['default'](this, Translator);

    _this = _super.call(this);

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized__default['default'](_this));
    }

    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized__default['default'](_this));
    _this.options = options;

    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = '.';
    }

    _this.logger = baseLogger.create('translator');
    return _this;
  }

  _createClass__default['default'](Translator, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng) this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        interpolation: {}
      };

      if (key === undefined || key === null) {
        return false;
      }

      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== undefined;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === undefined) nsSeparator = ':';
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);

      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m = key.match(this.interpolator.nestingRegexp);

        if (m && m.length > 0) {
          return {
            key: key,
            namespaces: namespaces
          };
        }

        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
        key = parts.join(keySeparator);
      }

      if (typeof namespaces === 'string') namespaces = [namespaces];
      return {
        key: key,
        namespaces: namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options, lastKey) {
      var _this2 = this;

      if (_typeof__default['default'](options) !== 'object' && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }

      if (!options) options = {};
      if (keys === undefined || keys === null) return '';
      if (!Array.isArray(keys)) keys = [String(keys)];
      var returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;

      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
          key = _this$extractFromKey.key,
          namespaces = _this$extractFromKey.namespaces;

      var namespace = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;

      if (lng && lng.toLowerCase() === 'cimode') {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;

          if (returnDetails) {
            resolved.res = "".concat(namespace).concat(nsSeparator).concat(key);
            return resolved;
          }

          return "".concat(namespace).concat(nsSeparator).concat(key);
        }

        if (returnDetails) {
          resolved.res = key;
          return resolved;
        }

        return key;
      }

      var resolved = this.resolve(keys, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
      var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';

      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn('accessing an object - but returnObjects options is not enabled!');
          }

          var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");

          if (returnDetails) {
            resolved.res = r;
            return resolved;
          }

          return r;
        }

        if (keySeparator) {
          var resTypeIsArray = resType === '[object Array]';
          var copy = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;

          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy[m] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy[m] === deepKey) copy[m] = res[m];
            }
          }

          res = copy;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, keys, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
        var hasDefaultValue = Translator.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
        var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;

        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }

        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }

        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;

        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);

          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options), {}, {
              keySeparator: false
            }));
            if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
          }

          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);

          if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === 'all') {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }

          var send = function send(l, k, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;

            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
            }

            _this2.emit('missingKey', l, namespace, k, res);
          };

          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function (language) {
                _this2.pluralResolver.getSuffixes(language, options).forEach(function (suffix) {
                  send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }

        res = this.extendTranslation(res, keys, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);

        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== 'v1') {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : undefined);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }

      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }

      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;

      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved: resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation) this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options), {
          interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options.interpolation)
        }));
        var skipOnVariables = typeof res === 'string' && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;

        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }

        var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
        if (this.options.interpolation.defaultVariables) data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);

        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft) options.nest = false;
        }

        if (options.nest !== false) res = this.interpolator.nest(res, function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (lastKey && lastKey[0] === args[0] && !options.context) {
            _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));

            return null;
          }

          return _this3.translate.apply(_this3, args.concat([key]));
        }, options);
        if (options.interpolation) this.interpolator.reset();
      }

      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options) : options, this);
      }

      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === 'string') keys = [keys];
      keys.forEach(function (k) {
        if (_this4.isValidLookup(found)) return;

        var extracted = _this4.extractFromKey(k, options);

        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';

        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();

        var needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function (ns) {
          if (_this4.isValidLookup(found)) return;
          usedNS = ns;

          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;

            _this4.logger.warn("key \"".concat(usedKey, "\" for languages \"").concat(codes.join(', '), "\" won't get resolved as namespace \"").concat(usedNS, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
          }

          codes.forEach(function (code) {
            if (_this4.isValidLookup(found)) return;
            usedLng = code;
            var finalKeys = [key];

            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
              var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");

              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);

                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }

              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                finalKeys.push(contextKey);

                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);

                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }

            var possibleKey;

            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey: usedKey,
        exactUsedKey: exactUsedKey,
        usedLng: usedLng,
        usedNS: usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix = 'defaultValue';

      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
          return true;
        }
      }

      return false;
    }
  }]);

  return Translator;
}(EventEmitter);

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

var LanguageUtil = function () {
  function LanguageUtil(options) {
    _classCallCheck__default['default'](this, LanguageUtil);

    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create('languageUtils');
  }

  _createClass__default['default'](LanguageUtil, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf('-') < 0) return null;
      var p = code.split('-');
      if (p.length === 2) return null;
      p.pop();
      if (p[p.length - 1].toLowerCase() === 'x') return null;
      return this.formatLanguageCode(p.join('-'));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf('-') < 0) return code;
      var p = code.split('-');
      return this.formatLanguageCode(p[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === 'string' && code.indexOf('-') > -1) {
        var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
        var p = code.split('-');

        if (this.options.lowerCaseLng) {
          p = p.map(function (part) {
            return part.toLowerCase();
          });
        } else if (p.length === 2) {
          p[0] = p[0].toLowerCase();
          p[1] = p[1].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        } else if (p.length === 3) {
          p[0] = p[0].toLowerCase();
          if (p[1].length === 2) p[1] = p[1].toUpperCase();
          if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
        }

        return p.join('-');
      }

      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }

      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;

      if (!codes) return null;
      var found;
      codes.forEach(function (code) {
        if (found) return;

        var cleanedLng = _this.formatLanguageCode(code);

        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
      });

      if (!found && this.options.supportedLngs) {
        codes.forEach(function (code) {
          if (found) return;

          var lngOnly = _this.getLanguagePartFromCode(code);

          if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
          found = _this.options.supportedLngs.find(function (supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
          });
        });
      }

      if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks) return [];
      if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
      if (typeof fallbacks === 'string') fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
      if (!code) return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found) found = fallbacks[this.formatLanguageCode(code)];
      if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found) found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;

      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];

      var addCode = function addCode(c) {
        if (!c) return;

        if (_this2.isSupportedCode(c)) {
          codes.push(c);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
        }
      };

      if (typeof code === 'string' && code.indexOf('-') > -1) {
        if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
        if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === 'string') {
        addCode(this.formatLanguageCode(code));
      }

      fallbackCodes.forEach(function (fc) {
        if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);

  return LanguageUtil;
}();

var sets = [{
  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
  nr: [1],
  fc: 3
}, {
  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ['ar'],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ['cs', 'sk'],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ['csb', 'pl'],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ['cy'],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ['fr'],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ['ga'],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ['gd'],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ['is'],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ['jv'],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ['kw'],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ['lt'],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ['lv'],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ['mk'],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ['mnk'],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ['mt'],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ['or'],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ['ro'],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ['sl'],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ['he', 'iw'],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _(n) {
    return Number(n != 1);
  },
  3: function _(n) {
    return 0;
  },
  4: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _(n) {
    return Number(n >= 2);
  },
  10: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _(n) {
    return Number(n !== 0);
  },
  14: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _(n) {
    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
  },
  18: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ['v1', 'v2', 'v3'];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};

function createRules() {
  var rules = {};
  sets.forEach(function (set) {
    set.lngs.forEach(function (l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}

var PluralResolver = function () {
  function PluralResolver(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck__default['default'](this, PluralResolver);

    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create('pluralResolver');

    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === 'v4') && (typeof Intl === 'undefined' || !Intl.PluralRules)) {
      this.options.compatibilityJSON = 'v3';
      this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');
    }

    this.rules = createRules();
  }

  _createClass__default['default'](PluralResolver, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options.ordinal ? 'ordinal' : 'cardinal'
          });
        } catch (_unused) {
          return;
        }
      }

      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rule = this.getRule(code, options);

      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }

      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.getSuffixes(code, options).map(function (suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rule = this.getRule(code, options);

      if (!rule) {
        return [];
      }

      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function (pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function (pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }

      return rule.numbers.map(function (number) {
        return _this.getSuffix(code, number, options);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var rule = this.getRule(code, options);

      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }

        return this.getSuffixRetroCompatible(rule, count);
      }

      this.logger.warn("no plural rule found for: ".concat(code));
      return '';
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;

      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];

      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = 'plural';
        } else if (suffix === 1) {
          suffix = '';
        }
      }

      var returnSuffix = function returnSuffix() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };

      if (this.options.compatibilityJSON === 'v1') {
        if (suffix === 1) return '';
        if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === 'v2') {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }

      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);

  return PluralResolver;
}();

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var Interpolator = function () {
  function Interpolator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck__default['default'](this, Interpolator);

    this.logger = baseLogger.create('interpolator');
    this.options = options;

    this.format = options.interpolation && options.interpolation.format || function (value) {
      return value;
    };

    this.init(options);
  }

  _createClass__default['default'](Interpolator, [{
    key: "init",
    value: function init() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!options.interpolation) options.interpolation = {
        escapeValue: true
      };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
      this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options) this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, 'g');
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;

      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

      function regexSafe(val) {
        return val.replace(/\$/g, '$$$$');
      }

      var handleFormat = function handleFormat(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, undefined, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
            interpolationkey: key
          })) : path;
        }

        var p = key.split(_this.formatSeparator);
        var k = p.shift().trim();
        var f = p.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
          interpolationkey: k
        }));
      };

      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function (todo) {
        replaces = 0;

        while (match = todo.regex.exec(str)) {
          var matchedVar = match[1].trim();
          value = handleFormat(matchedVar);

          if (value === undefined) {
            if (typeof missingInterpolationHandler === 'function') {
              var temp = missingInterpolationHandler(str, match, options);
              value = typeof temp === 'string' ? temp : '';
            } else if (options && options.hasOwnProperty(matchedVar)) {
              value = '';
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));

              value = '';
            }
          } else if (typeof value !== 'string' && !_this.useRawValueToEscape) {
            value = makeString(value);
          }

          var safeValue = todo.safeValue(value);
          str = str.replace(match[0], safeValue);

          if (skipOnVariables) {
            todo.regex.lastIndex += value.length;
            todo.regex.lastIndex -= match[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }

          replaces++;

          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var match;
      var value;

      var clonedOptions = _objectSpread$3({}, options);

      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;

      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0) return key;
        var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c[1]);
        key = c[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        var matchedSingleQuotes = optionsString.match(/'/g);
        var matchedDoubleQuotes = optionsString.match(/"/g);

        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
          optionsString = optionsString.replace(/'/g, '"');
        }

        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions) clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
          return "".concat(key).concat(sep).concat(optionsString);
        }

        delete clonedOptions.defaultValue;
        return key;
      }

      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;

        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
          var r = match[1].split(this.formatSeparator).map(function (elem) {
            return elem.trim();
          });
          match[1] = r.shift();
          formatters = r;
          doReduce = true;
        }

        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== 'string') return value;
        if (typeof value !== 'string') value = makeString(value);

        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = '';
        }

        if (doReduce) {
          value = formatters.reduce(function (v, f) {
            return _this2.format(v, f, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
              interpolationkey: match[1].trim()
            }));
          }, value.trim());
        }

        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }

      return str;
    }
  }]);

  return Interpolator;
}();

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};

  if (formatStr.indexOf('(') > -1) {
    var p = formatStr.split('(');
    formatName = p[0].toLowerCase().trim();
    var optStr = p[1].substring(0, p[1].length - 1);

    if (formatName === 'currency' && optStr.indexOf(':') < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(';');
      opts.forEach(function (opt) {
        if (!opt) return;

        var _opt$split = opt.split(':'),
            _opt$split2 = _toArray__default['default'](_opt$split),
            key = _opt$split2[0],
            rest = _opt$split2.slice(1);

        var val = rest.join(':').trim().replace(/^'+|'+$/g, '');
        if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;
        if (val === 'false') formatOptions[key.trim()] = false;
        if (val === 'true') formatOptions[key.trim()] = true;
        if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }

  return {
    formatName: formatName,
    formatOptions: formatOptions
  };
}

function createCachedFormatter(fn) {
  var cache = {};
  return function invokeFormatter(val, lng, options) {
    var key = lng + JSON.stringify(options);
    var formatter = cache[key];

    if (!formatter) {
      formatter = fn(lng, options);
      cache[key] = formatter;
    }

    return formatter(val);
  };
}

var Formatter = function () {
  function Formatter() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck__default['default'](this, Formatter);

    this.logger = baseLogger.create('formatter');
    this.options = options;
    this.formats = {
      number: createCachedFormatter(function (lng, options) {
        var formatter = new Intl.NumberFormat(lng, options);
        return function (val) {
          return formatter.format(val);
        };
      }),
      currency: createCachedFormatter(function (lng, options) {
        var formatter = new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options), {}, {
          style: 'currency'
        }));
        return function (val) {
          return formatter.format(val);
        };
      }),
      datetime: createCachedFormatter(function (lng, options) {
        var formatter = new Intl.DateTimeFormat(lng, _objectSpread$4({}, options));
        return function (val) {
          return formatter.format(val);
        };
      }),
      relativetime: createCachedFormatter(function (lng, options) {
        var formatter = new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options));
        return function (val) {
          return formatter.format(val, options.range || 'day');
        };
      }),
      list: createCachedFormatter(function (lng, options) {
        var formatter = new Intl.ListFormat(lng, _objectSpread$4({}, options));
        return function (val) {
          return formatter.format(val);
        };
      })
    };
    this.init(options);
  }

  _createClass__default['default'](Formatter, [{
    key: "init",
    value: function init(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
    }
  }, {
    key: "add",
    value: function add(name, fc) {
      this.formats[name.toLowerCase().trim()] = fc;
    }
  }, {
    key: "addCached",
    value: function addCached(name, fc) {
      this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
    }
  }, {
    key: "format",
    value: function format(value, _format, lng, options) {
      var _this = this;

      var formats = _format.split(this.formatSeparator);

      var result = formats.reduce(function (mem, f) {
        var _parseFormatStr = parseFormatStr(f),
            formatName = _parseFormatStr.formatName,
            formatOptions = _parseFormatStr.formatOptions;

        if (_this.formats[formatName]) {
          var formatted = mem;

          try {
            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = _this.formats[formatName](mem, l, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options), valOptions));
          } catch (error) {
            _this.logger.warn(error);
          }

          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }

        return mem;
      }, value);
      return result;
    }
  }]);

  return Formatter;
}();

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function removePending(q, name) {
  if (q.pending[name] !== undefined) {
    delete q.pending[name];
    q.pendingCount--;
  }
}

var Connector = function (_EventEmitter) {
  _inherits__default['default'](Connector, _EventEmitter);

  var _super = _createSuper$2(Connector);

  function Connector(backend, store, services) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck__default['default'](this, Connector);

    _this = _super.call(this);

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized__default['default'](_this));
    }

    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create('backendConnector');
    _this.waitingReads = [];
    _this.maxParallelReads = options.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    _this.state = {};
    _this.queue = [];

    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }

    return _this;
  }

  _createClass__default['default'](Connector, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;

      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages.forEach(function (lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function (ns) {
          var name = "".concat(lng, "|").concat(ns);

          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0) ; else if (_this2.state[name] === 1) {
            if (pending[name] === undefined) pending[name] = true;
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === undefined) pending[name] = true;
            if (toLoad[name] === undefined) toLoad[name] = true;
            if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces) toLoadLanguages[lng] = true;
      });

      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending: pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback: callback
        });
      }

      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s = name.split('|');
      var lng = s[0];
      var ns = s[1];
      if (err) this.emit('failedLoading', lng, ns, err);

      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }

      this.state[name] = err ? -1 : 2;
      var loaded = {};
      this.queue.forEach(function (q) {
        pushPath(q.loaded, [lng], ns);
        removePending(q, name);
        if (err) q.errors.push(err);

        if (q.pendingCount === 0 && !q.done) {
          Object.keys(q.loaded).forEach(function (l) {
            if (!loaded[l]) loaded[l] = {};
            var loadedKeys = q.loaded[l];

            if (loadedKeys.length) {
              loadedKeys.forEach(function (ns) {
                if (loaded[l][ns] === undefined) loaded[l][ns] = true;
              });
            }
          });
          q.done = true;

          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      });
      this.emit('loaded', loaded);
      this.queue = this.queue.filter(function (q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns, fcName) {
      var _this3 = this;

      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;
      var callback = arguments.length > 5 ? arguments[5] : undefined;
      if (!lng.length) return callback(null, {});

      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: lng,
          ns: ns,
          fcName: fcName,
          tried: tried,
          wait: wait,
          callback: callback
        });
        return;
      }

      this.readingCalls++;
      return this.backend[fcName](lng, ns, function (err, data) {
        _this3.readingCalls--;

        if (_this3.waitingReads.length > 0) {
          var next = _this3.waitingReads.shift();

          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }

        if (err && data && tried < _this3.maxRetries) {
          setTimeout(function () {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }

        callback(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : undefined;

      if (!this.backend) {
        this.logger.warn('No backend was added via i18next.use. Will not load resources.');
        return callback && callback();
      }

      if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === 'string') namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);

      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length) callback();
        return null;
      }

      toLoad.toLoad.forEach(function (name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;

      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var s = name.split('|');
      var lng = s[0];
      var ns = s[1];
      this.read(lng, ns, 'read', undefined, undefined, function (err, data) {
        if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);

        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn("did not save key \"".concat(key, "\" as the namespace \"").concat(namespace, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
        return;
      }

      if (key === undefined || key === null || key === '') return;

      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options), {}, {
          isUpdate: isUpdate
        }));
      }

      if (!languages || !languages[0]) return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);

  return Connector;
}(EventEmitter);

function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ['translation'],
    defaultNS: ['translation'],
    fallbackLng: ['dev'],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: 'all',
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: '.',
    nsSeparator: ':',
    pluralSeparator: '_',
    contextSeparator: '_',
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: 'fallback',
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      var ret = {};
      if (_typeof__default['default'](args[1]) === 'object') ret = args[1];
      if (typeof args[1] === 'string') ret.defaultValue = args[1];
      if (typeof args[2] === 'string') ret.tDescription = args[2];

      if (_typeof__default['default'](args[2]) === 'object' || _typeof__default['default'](args[3]) === 'object') {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function (key) {
          ret[key] = options[key];
        });
      }

      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options) {
        return value;
      },
      prefix: '{{',
      suffix: '}}',
      formatSeparator: ',',
      unescapePrefix: '-',
      nestingPrefix: '$t(',
      nestingSuffix: ')',
      nestingOptionsSeparator: ',',
      maxReplaces: 1000,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === 'string') options.ns = [options.ns];
  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];

  if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {
    options.supportedLngs = options.supportedLngs.concat(['cimode']);
  }

  return options;
}

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function noop() {}

function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function (mem) {
    if (typeof inst[mem] === 'function') {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}

var I18n = function (_EventEmitter) {
  _inherits__default['default'](I18n, _EventEmitter);

  var _super = _createSuper$3(I18n);

  function I18n() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : undefined;

    _classCallCheck__default['default'](this, I18n);

    _this = _super.call(this);

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized__default['default'](_this));
    }

    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized__default['default'](_this));

    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);

        return _possibleConstructorReturn__default['default'](_this, _assertThisInitialized__default['default'](_this));
      }

      setTimeout(function () {
        _this.init(options, callback);
      }, 0);
    }

    return _this;
  }

  _createClass__default['default'](I18n, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      if (!options.defaultNS && options.defaultNS !== false && options.ns) {
        if (typeof options.ns === 'string') {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf('translation') < 0) {
          options.defaultNS = options.ns[0];
        }
      }

      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));

      if (this.options.compatibilityAPI !== 'v1') {
        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
      }

      if (options.keySeparator !== undefined) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }

      if (options.nsSeparator !== undefined) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }

      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject) return null;
        if (typeof ClassOrObject === 'function') return new ClassOrObject();
        return ClassOrObject;
      }

      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }

        var formatter;

        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== 'undefined') {
          formatter = Formatter;
        }

        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });

        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s.formatter = createClassOnDemand(formatter);
          s.formatter.init(s, this.options);
          this.options.interpolation.format = s.formatter.format.bind(s.formatter);
        }

        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on('*', function (event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          _this2.emit.apply(_this2, [event].concat(args));
        });

        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }

        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init) s.i18nFormat.init(this);
        }

        this.translator = new Translator(this.services, this.options);
        this.translator.on('*', function (event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function (m) {
          if (m.init) m.init(_this2);
        });
      }

      this.format = this.options.interpolation.format;
      if (!callback) callback = noop;

      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
      }

      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn('init: no languageDetector is used and no lng is defined');
      }

      var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
      storeApi.forEach(function (fcName) {
        _this2[fcName] = function () {
          var _this2$store;

          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];
      storeApiChained.forEach(function (fcName) {
        _this2[fcName] = function () {
          var _this2$store2;

          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);

          return _this2;
        };
      });
      var deferred = defer();

      var load = function load() {
        var finish = function finish(err, t) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce) _this2.logger.warn('init: i18next is already initialized. You should call init just once!');
          _this2.isInitialized = true;
          if (!_this2.options.isClone) _this2.logger.log('initialized', _this2.options);

          _this2.emit('initialized', _this2.options);

          deferred.resolve(t);
          callback(err, t);
        };

        if (_this2.languages && _this2.options.compatibilityAPI !== 'v1' && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));

        _this2.changeLanguage(_this2.options.lng, finish);
      };

      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }

      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      var usedCallback = callback;
      var usedLng = typeof language === 'string' ? language : this.language;
      if (typeof language === 'function') usedCallback = language;

      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();
        var toLoad = [];

        var append = function append(lng) {
          if (!lng) return;

          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);

          lngs.forEach(function (l) {
            if (toLoad.indexOf(l) < 0) toLoad.push(l);
          });
        };

        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function (l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }

        if (this.options.preload) {
          this.options.preload.forEach(function (l) {
            return append(l);
          });
        }

        this.services.backendConnector.load(toLoad, this.options.ns, function (e) {
          if (!e && !_this3.resolvedLanguage && _this3.language) _this3.setResolvedLanguage(_this3.language);
          usedCallback(e);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs) lngs = this.languages;
      if (!ns) ns = this.options.ns;
      if (!callback) callback = noop;
      this.services.backendConnector.reload(lngs, ns, function (err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
      if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');

      if (module.type === 'backend') {
        this.modules.backend = module;
      }

      if (module.type === 'logger' || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }

      if (module.type === 'languageDetector') {
        this.modules.languageDetector = module;
      }

      if (module.type === 'i18nFormat') {
        this.modules.i18nFormat = module;
      }

      if (module.type === 'postProcessor') {
        postProcessor.addPostProcessor(module);
      }

      if (module.type === 'formatter') {
        this.modules.formatter = module;
      }

      if (module.type === '3rdParty') {
        this.modules.external.push(module);
      }

      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l) {
      if (!l || !this.languages) return;
      if (['cimode', 'dev'].indexOf(l) > -1) return;

      for (var li = 0; li < this.languages.length; li++) {
        var lngInLngs = this.languages[li];
        if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;

        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;

      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit('languageChanging', lng);

      var setLngProps = function setLngProps(l) {
        _this4.language = l;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
        _this4.resolvedLanguage = undefined;

        _this4.setResolvedLanguage(l);
      };

      var done = function done(err, l) {
        if (l) {
          setLngProps(l);

          _this4.translator.changeLanguage(l);

          _this4.isLanguageChangingTo = undefined;

          _this4.emit('languageChanged', l);

          _this4.logger.log('languageChanged', l);
        } else {
          _this4.isLanguageChangingTo = undefined;
        }

        deferred.resolve(function () {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback) callback(err, function () {
          return _this4.t.apply(_this4, arguments);
        });
      };

      var setLng = function setLng(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector) lngs = [];
        var l = typeof lngs === 'string' ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);

        if (l) {
          if (!_this4.language) {
            setLngProps(l);
          }

          if (!_this4.translator.language) _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
        }

        _this4.loadResources(l, function (err) {
          done(err, l);
        });
      };

      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }

      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns, keyPrefix) {
      var _this5 = this;

      var fixedT = function fixedT(key, opts) {
        var options;

        if (_typeof__default['default'](opts) !== 'object') {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }

          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread$6({}, opts);
        }

        options.lng = options.lng || fixedT.lng;
        options.lngs = options.lngs || fixedT.lngs;
        options.ns = options.ns || fixedT.ns;
        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
        var keySeparator = _this5.options.keySeparator || '.';
        var resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options);
      };

      if (typeof lng === 'string') {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }

      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t() {
      var _this$translator;

      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;

      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace(ns) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.isInitialized) {
        this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
        return false;
      }

      if (!this.languages || !this.languages.length) {
        this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
        return false;
      }

      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === 'cimode') return true;

      var loadNotPending = function loadNotPending(l, n) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];

        return loadState === -1 || loadState === 2;
      };

      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== undefined) return preResult;
      }

      if (this.hasResourceBundle(lng, ns)) return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces(ns, callback) {
      var _this7 = this;

      var deferred = defer();

      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }

      if (typeof ns === 'string') ns = [ns];
      ns.forEach(function (n) {
        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);
      });
      this.loadResources(function (err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === 'string') lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function (lng) {
        return preloaded.indexOf(lng) < 0;
      });

      if (!newLngs.length) {
        if (callback) callback();
        return Promise.resolve();
      }

      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function (err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng) return 'rtl';
      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {
        isClone: true
      });

      var clone = new I18n(mergedOptions);

      if (options.debug !== undefined || options.prefix !== undefined) {
        clone.logger = clone.logger.clone(options);
      }

      var membersToCopy = ['store', 'services', 'language'];
      membersToCopy.forEach(function (m) {
        clone[m] = _this8[m];
      });
      clone.services = _objectSpread$6({}, this.services);
      clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      clone.translator = new Translator(clone.services, clone.options);
      clone.translator.on('*', function (event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        clone.emit.apply(clone, [event].concat(args));
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = clone.options;
      clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      return clone;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);

  return I18n;
}(EventEmitter);

_defineProperty__default['default'](I18n, "createInstance", function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var callback = arguments.length > 1 ? arguments[1] : undefined;
  return new I18n(options, callback);
});

var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;

module.exports = instance;

},{"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":4,"@babel/runtime/helpers/createClass":5,"@babel/runtime/helpers/defineProperty":6,"@babel/runtime/helpers/getPrototypeOf":7,"@babel/runtime/helpers/inherits":8,"@babel/runtime/helpers/possibleConstructorReturn":11,"@babel/runtime/helpers/toArray":13,"@babel/runtime/helpers/typeof":14}],17:[function(require,module,exports){
/**
 * MIT License
 * 
 * Copyright (c) 2014-present, Lee Byron and other contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Immutable = {}));
}(this, (function (exports) { 'use strict';

  var DELETE = 'delete';

  // Constants describing the size of trie nodes.
  var SHIFT = 5; // Resulted in best performance after ______?
  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1;

  // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.
  var NOT_SET = {};

  // Boolean references, Rough equivalent of `bool &`.
  function MakeRef() {
    return { value: false };
  }

  function SetRef(ref) {
    if (ref) {
      ref.value = true;
    }
  }

  // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.
  function OwnerID() {}

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^321.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }
      index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (
      ((begin === 0 && !isNeg(begin)) ||
        (size !== undefined && begin <= -size)) &&
      (end === undefined || (size !== undefined && end >= size))
    );
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    // Sanitize indices using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    return index === undefined
      ? defaultIndex
      : isNeg(index)
      ? size === Infinity
        ? size
        : Math.max(0, size + index) | 0
      : size === undefined || size === index
      ? index
      : Math.min(size, index) | 0;
  }

  function isNeg(value) {
    // Account for -0 which is negative, but not less than 0.
    return value < 0 || (value === 0 && 1 / value === -Infinity);
  }

  var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';

  function isCollection(maybeCollection) {
    return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
  }

  var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';

  function isKeyed(maybeKeyed) {
    return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
  }

  var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';

  function isIndexed(maybeIndexed) {
    return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  var Collection = function Collection(value) {
    return isCollection(value) ? value : Seq(value);
  };

  var KeyedCollection = /*@__PURE__*/(function (Collection) {
    function KeyedCollection(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }

    if ( Collection ) KeyedCollection.__proto__ = Collection;
    KeyedCollection.prototype = Object.create( Collection && Collection.prototype );
    KeyedCollection.prototype.constructor = KeyedCollection;

    return KeyedCollection;
  }(Collection));

  var IndexedCollection = /*@__PURE__*/(function (Collection) {
    function IndexedCollection(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }

    if ( Collection ) IndexedCollection.__proto__ = Collection;
    IndexedCollection.prototype = Object.create( Collection && Collection.prototype );
    IndexedCollection.prototype.constructor = IndexedCollection;

    return IndexedCollection;
  }(Collection));

  var SetCollection = /*@__PURE__*/(function (Collection) {
    function SetCollection(value) {
      return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
    }

    if ( Collection ) SetCollection.__proto__ = Collection;
    SetCollection.prototype = Object.create( Collection && Collection.prototype );
    SetCollection.prototype.constructor = SetCollection;

    return SetCollection;
  }(Collection));

  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;

  var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';

  function isSeq(maybeSeq) {
    return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
  }

  var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';

  function isRecord(maybeRecord) {
    return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
  }

  function isImmutable(maybeImmutable) {
    return isCollection(maybeImmutable) || isRecord(maybeImmutable);
  }

  var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';

  function isOrdered(maybeOrdered) {
    return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
  }

  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;

  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

  var Iterator = function Iterator(next) {
    this.next = next;
  };

  Iterator.prototype.toString = function toString () {
    return '[Iterator]';
  };

  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
    return this.toString();
  };
  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };

  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult
      ? (iteratorResult.value = value)
      : (iteratorResult = {
          value: value,
          done: false,
        });
    return iteratorResult;
  }

  function iteratorDone() {
    return { value: undefined, done: true };
  }

  function hasIterator(maybeIterable) {
    if (Array.isArray(maybeIterable)) {
      // IE11 trick as it does not support `Symbol.iterator`
      return true;
    }

    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn =
      iterable &&
      ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
        iterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isEntriesIterable(maybeIterable) {
    var iteratorFn = getIteratorFn(maybeIterable);
    return iteratorFn && iteratorFn === maybeIterable.entries;
  }

  function isKeysIterable(maybeIterable) {
    var iteratorFn = getIteratorFn(maybeIterable);
    return iteratorFn && iteratorFn === maybeIterable.keys;
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function isArrayLike(value) {
    if (Array.isArray(value) || typeof value === 'string') {
      return true;
    }

    return (
      value &&
      typeof value === 'object' &&
      Number.isInteger(value.length) &&
      value.length >= 0 &&
      (value.length === 0
        ? // Only {length: 0} is considered Array-like.
          Object.keys(value).length === 1
        : // An object is only Array-like if it has a property where the last value
          // in the array-like may be found (which could be undefined).
          value.hasOwnProperty(value.length - 1))
    );
  }

  var Seq = /*@__PURE__*/(function (Collection) {
    function Seq(value) {
      return value === undefined || value === null
        ? emptySequence()
        : isImmutable(value)
        ? value.toSeq()
        : seqFromValue(value);
    }

    if ( Collection ) Seq.__proto__ = Collection;
    Seq.prototype = Object.create( Collection && Collection.prototype );
    Seq.prototype.constructor = Seq;

    Seq.prototype.toSeq = function toSeq () {
      return this;
    };

    Seq.prototype.toString = function toString () {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function cacheResult () {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function __iterate (fn, reverse) {
      var cache = this._cache;
      if (cache) {
        var size = cache.length;
        var i = 0;
        while (i !== size) {
          var entry = cache[reverse ? size - ++i : i++];
          if (fn(entry[1], entry[0], this) === false) {
            break;
          }
        }
        return i;
      }
      return this.__iterateUncached(fn, reverse);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function __iterator (type, reverse) {
      var cache = this._cache;
      if (cache) {
        var size = cache.length;
        var i = 0;
        return new Iterator(function () {
          if (i === size) {
            return iteratorDone();
          }
          var entry = cache[reverse ? size - ++i : i++];
          return iteratorValue(type, entry[0], entry[1]);
        });
      }
      return this.__iteratorUncached(type, reverse);
    };

    return Seq;
  }(Collection));

  var KeyedSeq = /*@__PURE__*/(function (Seq) {
    function KeyedSeq(value) {
      return value === undefined || value === null
        ? emptySequence().toKeyedSeq()
        : isCollection(value)
        ? isKeyed(value)
          ? value.toSeq()
          : value.fromEntrySeq()
        : isRecord(value)
        ? value.toSeq()
        : keyedSeqFromValue(value);
    }

    if ( Seq ) KeyedSeq.__proto__ = Seq;
    KeyedSeq.prototype = Object.create( Seq && Seq.prototype );
    KeyedSeq.prototype.constructor = KeyedSeq;

    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {
      return this;
    };

    return KeyedSeq;
  }(Seq));

  var IndexedSeq = /*@__PURE__*/(function (Seq) {
    function IndexedSeq(value) {
      return value === undefined || value === null
        ? emptySequence()
        : isCollection(value)
        ? isKeyed(value)
          ? value.entrySeq()
          : value.toIndexedSeq()
        : isRecord(value)
        ? value.toSeq().entrySeq()
        : indexedSeqFromValue(value);
    }

    if ( Seq ) IndexedSeq.__proto__ = Seq;
    IndexedSeq.prototype = Object.create( Seq && Seq.prototype );
    IndexedSeq.prototype.constructor = IndexedSeq;

    IndexedSeq.of = function of (/*...values*/) {
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {
      return this;
    };

    IndexedSeq.prototype.toString = function toString () {
      return this.__toString('Seq [', ']');
    };

    return IndexedSeq;
  }(Seq));

  var SetSeq = /*@__PURE__*/(function (Seq) {
    function SetSeq(value) {
      return (
        isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)
      ).toSetSeq();
    }

    if ( Seq ) SetSeq.__proto__ = Seq;
    SetSeq.prototype = Object.create( Seq && Seq.prototype );
    SetSeq.prototype.constructor = SetSeq;

    SetSeq.of = function of (/*...values*/) {
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function toSetSeq () {
      return this;
    };

    return SetSeq;
  }(Seq));

  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;

  Seq.prototype[IS_SEQ_SYMBOL] = true;

  // #pragma Root Sequences

  var ArraySeq = /*@__PURE__*/(function (IndexedSeq) {
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;
    ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
    ArraySeq.prototype.constructor = ArraySeq;

    ArraySeq.prototype.get = function get (index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {
      var array = this._array;
      var size = array.length;
      var i = 0;
      while (i !== size) {
        var ii = reverse ? size - ++i : i++;
        if (fn(array[ii], ii, this) === false) {
          break;
        }
      }
      return i;
    };

    ArraySeq.prototype.__iterator = function __iterator (type, reverse) {
      var array = this._array;
      var size = array.length;
      var i = 0;
      return new Iterator(function () {
        if (i === size) {
          return iteratorDone();
        }
        var ii = reverse ? size - ++i : i++;
        return iteratorValue(type, ii, array[ii]);
      });
    };

    return ArraySeq;
  }(IndexedSeq));

  var ObjectSeq = /*@__PURE__*/(function (KeyedSeq) {
    function ObjectSeq(object) {
      var keys = Object.keys(object).concat(
        Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []
      );
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;
    ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );
    ObjectSeq.prototype.constructor = ObjectSeq;

    ObjectSeq.prototype.get = function get (key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function has (key) {
      return hasOwnProperty.call(this._object, key);
    };

    ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var size = keys.length;
      var i = 0;
      while (i !== size) {
        var key = keys[reverse ? size - ++i : i++];
        if (fn(object[key], key, this) === false) {
          break;
        }
      }
      return i;
    };

    ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var size = keys.length;
      var i = 0;
      return new Iterator(function () {
        if (i === size) {
          return iteratorDone();
        }
        var key = keys[reverse ? size - ++i : i++];
        return iteratorValue(type, key, object[key]);
      });
    };

    return ObjectSeq;
  }(KeyedSeq));
  ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;

  var CollectionSeq = /*@__PURE__*/(function (IndexedSeq) {
    function CollectionSeq(collection) {
      this._collection = collection;
      this.size = collection.length || collection.size;
    }

    if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;
    CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
    CollectionSeq.prototype.constructor = CollectionSeq;

    CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var collection = this._collection;
      var iterator = getIterator(collection);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var collection = this._collection;
      var iterator = getIterator(collection);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function () {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };

    return CollectionSeq;
  }(IndexedSeq));

  // # pragma Helper functions

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (seq) {
      return seq.fromEntrySeq();
    }
    if (typeof value === 'object') {
      return new ObjectSeq(value);
    }
    throw new TypeError(
      'Expected Array or collection object of [k, v] entries, or keyed object: ' +
        value
    );
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (seq) {
      return seq;
    }
    throw new TypeError(
      'Expected Array or collection object of values: ' + value
    );
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (seq) {
      return isEntriesIterable(value)
        ? seq.fromEntrySeq()
        : isKeysIterable(value)
        ? seq.toSetSeq()
        : seq;
    }
    if (typeof value === 'object') {
      return new ObjectSeq(value);
    }
    throw new TypeError(
      'Expected Array or collection object of values, or keyed object: ' + value
    );
  }

  function maybeIndexedSeqFromValue(value) {
    return isArrayLike(value)
      ? new ArraySeq(value)
      : hasIterator(value)
      ? new CollectionSeq(value)
      : undefined;
  }

  var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';

  function isMap(maybeMap) {
    return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
  }

  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  function isValueObject(maybeValue) {
    return Boolean(
      maybeValue &&
        typeof maybeValue.equals === 'function' &&
        typeof maybeValue.hashCode === 'function'
    );
  }

  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections are Value Objects: they implement `equals()`
   * and `hashCode()`.
   */
  function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
    if (
      typeof valueA.valueOf === 'function' &&
      typeof valueB.valueOf === 'function'
    ) {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
    }
    return !!(
      isValueObject(valueA) &&
      isValueObject(valueB) &&
      valueA.equals(valueB)
    );
  }

  var imul =
    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2
      ? Math.imul
      : function imul(a, b) {
          a |= 0; // int
          b |= 0; // int
          var c = a & 0xffff;
          var d = b & 0xffff;
          // Shift by 0 fixes the sign on the high part.
          return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int
        };

  // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.
  function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);
  }

  var defaultValueOf = Object.prototype.valueOf;

  function hash(o) {
    if (o == null) {
      return hashNullish(o);
    }

    if (typeof o.hashCode === 'function') {
      // Drop any high bits from accidentally long hash codes.
      return smi(o.hashCode(o));
    }

    var v = valueOf(o);

    if (v == null) {
      return hashNullish(v);
    }

    switch (typeof v) {
      case 'boolean':
        // The hash values for built-in constants are a 1 value for each 5-byte
        // shift region expect for the first, which encodes the value. This
        // reduces the odds of a hash collision for these common values.
        return v ? 0x42108421 : 0x42108420;
      case 'number':
        return hashNumber(v);
      case 'string':
        return v.length > STRING_HASH_CACHE_MIN_STRLEN
          ? cachedHashString(v)
          : hashString(v);
      case 'object':
      case 'function':
        return hashJSObj(v);
      case 'symbol':
        return hashSymbol(v);
      default:
        if (typeof v.toString === 'function') {
          return hashString(v.toString());
        }
        throw new Error('Value type ' + typeof v + ' cannot be hashed.');
    }
  }

  function hashNullish(nullish) {
    return nullish === null ? 0x42108422 : /* undefined */ 0x42108423;
  }

  // Compress arbitrarily large numbers into smi hashes.
  function hashNumber(n) {
    if (n !== n || n === Infinity) {
      return 0;
    }
    var hash = n | 0;
    if (hash !== n) {
      hash ^= n * 0xffffffff;
    }
    while (n > 0xffffffff) {
      n /= 0xffffffff;
      hash ^= n;
    }
    return smi(hash);
  }

  function cachedHashString(string) {
    var hashed = stringHashCache[string];
    if (hashed === undefined) {
      hashed = hashString(string);
      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }
      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hashed;
    }
    return hashed;
  }

  // http://jsperf.com/hashing-strings
  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hashed = 0;
    for (var ii = 0; ii < string.length; ii++) {
      hashed = (31 * hashed + string.charCodeAt(ii)) | 0;
    }
    return smi(hashed);
  }

  function hashSymbol(sym) {
    var hashed = symbolMap[sym];
    if (hashed !== undefined) {
      return hashed;
    }

    hashed = nextHash();

    symbolMap[sym] = hashed;

    return hashed;
  }

  function hashJSObj(obj) {
    var hashed;
    if (usingWeakMap) {
      hashed = weakMap.get(obj);
      if (hashed !== undefined) {
        return hashed;
      }
    }

    hashed = obj[UID_HASH_KEY];
    if (hashed !== undefined) {
      return hashed;
    }

    if (!canDefineProperty) {
      hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
      if (hashed !== undefined) {
        return hashed;
      }

      hashed = getIENodeHash(obj);
      if (hashed !== undefined) {
        return hashed;
      }
    }

    hashed = nextHash();

    if (usingWeakMap) {
      weakMap.set(obj, hashed);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: hashed,
      });
    } else if (
      obj.propertyIsEnumerable !== undefined &&
      obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable
    ) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function () {
        return this.constructor.prototype.propertyIsEnumerable.apply(
          this,
          arguments
        );
      };
      obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hashed;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hashed;
  }

  // Get references to ES5 object methods.
  var isExtensible = Object.isExtensible;

  // True if Object.defineProperty works as expected. IE8 fails this test.
  var canDefineProperty = (function () {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  })();

  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.
  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1: // Element
          return node.uniqueID;
        case 9: // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  }

  function valueOf(obj) {
    return obj.valueOf !== defaultValueOf && typeof obj.valueOf === 'function'
      ? obj.valueOf(obj)
      : obj;
  }

  function nextHash() {
    var nextHash = ++_objHashUID;
    if (_objHashUID & 0x40000000) {
      _objHashUID = 0;
    }
    return nextHash;
  }

  // If possible, use a WeakMap.
  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;
  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var symbolMap = Object.create(null);

  var _objHashUID = 0;

  var UID_HASH_KEY = '__immutablehash__';
  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  var ToKeyedSequence = /*@__PURE__*/(function (KeyedSeq) {
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    if ( KeyedSeq ) ToKeyedSequence.__proto__ = KeyedSeq;
    ToKeyedSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );
    ToKeyedSequence.prototype.constructor = ToKeyedSequence;

    ToKeyedSequence.prototype.get = function get (key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function has (key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function valueSeq () {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function reverse () {
      var this$1$1 = this;

      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function () { return this$1$1._iter.toSeq().reverse(); };
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function map (mapper, context) {
      var this$1$1 = this;

      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function () { return this$1$1._iter.toSeq().map(mapper, context); };
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1$1 = this;

      return this._iter.__iterate(function (v, k) { return fn(v, k, this$1$1); }, reverse);
    };

    ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {
      return this._iter.__iterator(type, reverse);
    };

    return ToKeyedSequence;
  }(KeyedSeq));
  ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;

  var ToIndexedSequence = /*@__PURE__*/(function (IndexedSeq) {
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    if ( IndexedSeq ) ToIndexedSequence.__proto__ = IndexedSeq;
    ToIndexedSequence.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
    ToIndexedSequence.prototype.constructor = ToIndexedSequence;

    ToIndexedSequence.prototype.includes = function includes (value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1$1 = this;

      var i = 0;
      reverse && ensureSize(this);
      return this._iter.__iterate(
        function (v) { return fn(v, reverse ? this$1$1.size - ++i : i++, this$1$1); },
        reverse
      );
    };

    ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {
      var this$1$1 = this;

      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var i = 0;
      reverse && ensureSize(this);
      return new Iterator(function () {
        var step = iterator.next();
        return step.done
          ? step
          : iteratorValue(
              type,
              reverse ? this$1$1.size - ++i : i++,
              step.value,
              step
            );
      });
    };

    return ToIndexedSequence;
  }(IndexedSeq));

  var ToSetSequence = /*@__PURE__*/(function (SetSeq) {
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    if ( SetSeq ) ToSetSequence.__proto__ = SetSeq;
    ToSetSequence.prototype = Object.create( SetSeq && SetSeq.prototype );
    ToSetSequence.prototype.constructor = ToSetSequence;

    ToSetSequence.prototype.has = function has (key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1$1 = this;

      return this._iter.__iterate(function (v) { return fn(v, v, this$1$1); }, reverse);
    };

    ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function () {
        var step = iterator.next();
        return step.done
          ? step
          : iteratorValue(type, step.value, step.value, step);
      });
    };

    return ToSetSequence;
  }(SetSeq));

  var FromEntriesSequence = /*@__PURE__*/(function (KeyedSeq) {
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    if ( KeyedSeq ) FromEntriesSequence.__proto__ = KeyedSeq;
    FromEntriesSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );
    FromEntriesSequence.prototype.constructor = FromEntriesSequence;

    FromEntriesSequence.prototype.entrySeq = function entrySeq () {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1$1 = this;

      return this._iter.__iterate(function (entry) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return fn(
            indexedCollection ? entry.get(1) : entry[1],
            indexedCollection ? entry.get(0) : entry[0],
            this$1$1
          );
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function () {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedCollection = isCollection(entry);
            return iteratorValue(
              type,
              indexedCollection ? entry.get(0) : entry[0],
              indexedCollection ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };

    return FromEntriesSequence;
  }(KeyedSeq));

  ToIndexedSequence.prototype.cacheResult =
    ToKeyedSequence.prototype.cacheResult =
    ToSetSequence.prototype.cacheResult =
    FromEntriesSequence.prototype.cacheResult =
      cacheResultThrough;

  function flipFactory(collection) {
    var flipSequence = makeSequence(collection);
    flipSequence._iter = collection;
    flipSequence.size = collection.size;
    flipSequence.flip = function () { return collection; };
    flipSequence.reverse = function () {
      var reversedSequence = collection.reverse.apply(this); // super.reverse()
      reversedSequence.flip = function () { return collection.reverse(); };
      return reversedSequence;
    };
    flipSequence.has = function (key) { return collection.includes(key); };
    flipSequence.includes = function (key) { return collection.has(key); };
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function (fn, reverse) {
      var this$1$1 = this;

      return collection.__iterate(function (v, k) { return fn(k, v, this$1$1) !== false; }, reverse);
    };
    flipSequence.__iteratorUncached = function (type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = collection.__iterator(type, reverse);
        return new Iterator(function () {
          var step = iterator.next();
          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }
          return step;
        });
      }
      return collection.__iterator(
        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
        reverse
      );
    };
    return flipSequence;
  }

  function mapFactory(collection, mapper, context) {
    var mappedSequence = makeSequence(collection);
    mappedSequence.size = collection.size;
    mappedSequence.has = function (key) { return collection.has(key); };
    mappedSequence.get = function (key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v === NOT_SET
        ? notSetValue
        : mapper.call(context, v, key, collection);
    };
    mappedSequence.__iterateUncached = function (fn, reverse) {
      var this$1$1 = this;

      return collection.__iterate(
        function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1$1) !== false; },
        reverse
      );
    };
    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
      return new Iterator(function () {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        return iteratorValue(
          type,
          key,
          mapper.call(context, entry[1], key, collection),
          step
        );
      });
    };
    return mappedSequence;
  }

  function reverseFactory(collection, useKeys) {
    var this$1$1 = this;

    var reversedSequence = makeSequence(collection);
    reversedSequence._iter = collection;
    reversedSequence.size = collection.size;
    reversedSequence.reverse = function () { return collection; };
    if (collection.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(collection);
        flipSequence.reverse = function () { return collection.flip(); };
        return flipSequence;
      };
    }
    reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };
    reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };
    reversedSequence.includes = function (value) { return collection.includes(value); };
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function (fn, reverse) {
      var this$1$1 = this;

      var i = 0;
      reverse && ensureSize(collection);
      return collection.__iterate(
        function (v, k) { return fn(v, useKeys ? k : reverse ? this$1$1.size - ++i : i++, this$1$1); },
        !reverse
      );
    };
    reversedSequence.__iterator = function (type, reverse) {
      var i = 0;
      reverse && ensureSize(collection);
      var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
      return new Iterator(function () {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        return iteratorValue(
          type,
          useKeys ? entry[0] : reverse ? this$1$1.size - ++i : i++,
          entry[1],
          step
        );
      });
    };
    return reversedSequence;
  }

  function filterFactory(collection, predicate, context, useKeys) {
    var filterSequence = makeSequence(collection);
    if (useKeys) {
      filterSequence.has = function (key) {
        var v = collection.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, collection);
      };
      filterSequence.get = function (key, notSetValue) {
        var v = collection.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, collection)
          ? v
          : notSetValue;
      };
    }
    filterSequence.__iterateUncached = function (fn, reverse) {
      var this$1$1 = this;

      var iterations = 0;
      collection.__iterate(function (v, k, c) {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$1$1);
        }
      }, reverse);
      return iterations;
    };
    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
      var iterations = 0;
      return new Iterator(function () {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          var value = entry[1];
          if (predicate.call(context, value, key, collection)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    };
    return filterSequence;
  }

  function countByFactory(collection, grouper, context) {
    var groups = Map().asMutable();
    collection.__iterate(function (v, k) {
      groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });
    });
    return groups.asImmutable();
  }

  function groupByFactory(collection, grouper, context) {
    var isKeyedIter = isKeyed(collection);
    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();
    collection.__iterate(function (v, k) {
      groups.update(
        grouper.call(context, v, k, collection),
        function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }
      );
    });
    var coerce = collectionClass(collection);
    return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();
  }

  function sliceFactory(collection, begin, end, useKeys) {
    var originalSize = collection.size;

    if (wholeSlice(begin, end, originalSize)) {
      return collection;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);

    // begin or end will be NaN if they were provided as negative numbers and
    // this collection's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
    }

    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(collection);

    // If collection.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size =
      sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;

    if (!useKeys && isSeq(collection) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize
          ? collection.get(index + resolvedBegin, notSetValue)
          : notSetValue;
      };
    }

    sliceSeq.__iterateUncached = function (fn, reverse) {
      var this$1$1 = this;

      if (sliceSize === 0) {
        return 0;
      }
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;
      collection.__iterate(function (v, k) {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return (
            fn(v, useKeys ? k : iterations - 1, this$1$1) !== false &&
            iterations !== sliceSize
          );
        }
      });
      return iterations;
    };

    sliceSeq.__iteratorUncached = function (type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      // Don't bother instantiating parent iterator if taking 0.
      if (sliceSize === 0) {
        return new Iterator(iteratorDone);
      }
      var iterator = collection.__iterator(type, reverse);
      var skipped = 0;
      var iterations = 0;
      return new Iterator(function () {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }
        if (++iterations > sliceSize) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (useKeys || type === ITERATE_VALUES || step.done) {
          return step;
        }
        if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        }
        return iteratorValue(type, iterations - 1, step.value[1], step);
      });
    };

    return sliceSeq;
  }

  function takeWhileFactory(collection, predicate, context) {
    var takeSequence = makeSequence(collection);
    takeSequence.__iterateUncached = function (fn, reverse) {
      var this$1$1 = this;

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      collection.__iterate(
        function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1); }
      );
      return iterations;
    };
    takeSequence.__iteratorUncached = function (type, reverse) {
      var this$1$1 = this;

      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
      var iterating = true;
      return new Iterator(function () {
        if (!iterating) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var k = entry[0];
        var v = entry[1];
        if (!predicate.call(context, v, k, this$1$1)) {
          iterating = false;
          return iteratorDone();
        }
        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
      });
    };
    return takeSequence;
  }

  function skipWhileFactory(collection, predicate, context, useKeys) {
    var skipSequence = makeSequence(collection);
    skipSequence.__iterateUncached = function (fn, reverse) {
      var this$1$1 = this;

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var isSkipping = true;
      var iterations = 0;
      collection.__iterate(function (v, k, c) {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$1$1);
        }
      });
      return iterations;
    };
    skipSequence.__iteratorUncached = function (type, reverse) {
      var this$1$1 = this;

      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
      var skipping = true;
      var iterations = 0;
      return new Iterator(function () {
        var step;
        var k;
        var v;
        do {
          step = iterator.next();
          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            }
            if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            }
            return iteratorValue(type, iterations++, step.value[1], step);
          }
          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$1$1));
        } while (skipping);
        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
      });
    };
    return skipSequence;
  }

  function concatFactory(collection, values) {
    var isKeyedCollection = isKeyed(collection);
    var iters = [collection]
      .concat(values)
      .map(function (v) {
        if (!isCollection(v)) {
          v = isKeyedCollection
            ? keyedSeqFromValue(v)
            : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
        } else if (isKeyedCollection) {
          v = KeyedCollection(v);
        }
        return v;
      })
      .filter(function (v) { return v.size !== 0; });

    if (iters.length === 0) {
      return collection;
    }

    if (iters.length === 1) {
      var singleton = iters[0];
      if (
        singleton === collection ||
        (isKeyedCollection && isKeyed(singleton)) ||
        (isIndexed(collection) && isIndexed(singleton))
      ) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);
    if (isKeyedCollection) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(collection)) {
      concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(function (sum, seq) {
      if (sum !== undefined) {
        var size = seq.size;
        if (size !== undefined) {
          return sum + size;
        }
      }
    }, 0);
    return concatSeq;
  }

  function flattenFactory(collection, depth, useKeys) {
    var flatSequence = makeSequence(collection);
    flatSequence.__iterateUncached = function (fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      var stopped = false;
      function flatDeep(iter, currentDepth) {
        iter.__iterate(function (v, k) {
          if ((!depth || currentDepth < depth) && isCollection(v)) {
            flatDeep(v, currentDepth + 1);
          } else {
            iterations++;
            if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
              stopped = true;
            }
          }
          return !stopped;
        }, reverse);
      }
      flatDeep(collection, 0);
      return iterations;
    };
    flatSequence.__iteratorUncached = function (type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = collection.__iterator(type, reverse);
      var stack = [];
      var iterations = 0;
      return new Iterator(function () {
        while (iterator) {
          var step = iterator.next();
          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }
          var v = step.value;
          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }
          if ((!depth || stack.length < depth) && isCollection(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }
        return iteratorDone();
      });
    };
    return flatSequence;
  }

  function flatMapFactory(collection, mapper, context) {
    var coerce = collectionClass(collection);
    return collection
      .toSeq()
      .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })
      .flatten(true);
  }

  function interposeFactory(collection, separator) {
    var interposedSequence = makeSequence(collection);
    interposedSequence.size = collection.size && collection.size * 2 - 1;
    interposedSequence.__iterateUncached = function (fn, reverse) {
      var this$1$1 = this;

      var iterations = 0;
      collection.__iterate(
        function (v) { return (!iterations || fn(separator, iterations++, this$1$1) !== false) &&
          fn(v, iterations++, this$1$1) !== false; },
        reverse
      );
      return iterations;
    };
    interposedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = collection.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      var step;
      return new Iterator(function () {
        if (!step || iterations % 2) {
          step = iterator.next();
          if (step.done) {
            return step;
          }
        }
        return iterations % 2
          ? iteratorValue(type, iterations++, separator)
          : iteratorValue(type, iterations++, step.value, step);
      });
    };
    return interposedSequence;
  }

  function sortFactory(collection, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    var isKeyedCollection = isKeyed(collection);
    var index = 0;
    var entries = collection
      .toSeq()
      .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })
      .valueSeq()
      .toArray();
    entries
      .sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; })
      .forEach(
        isKeyedCollection
          ? function (v, i) {
              entries[i].length = 2;
            }
          : function (v, i) {
              entries[i] = v[1];
            }
      );
    return isKeyedCollection
      ? KeyedSeq(entries)
      : isIndexed(collection)
      ? IndexedSeq(entries)
      : SetSeq(entries);
  }

  function maxFactory(collection, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    if (mapper) {
      var entry = collection
        .toSeq()
        .map(function (v, k) { return [v, mapper(v, k, collection)]; })
        .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });
      return entry && entry[0];
    }
    return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return (
      (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||
      comp > 0
    );
  }

  function zipWithFactory(keyIter, zipper, iters, zipAll) {
    var zipSequence = makeSequence(keyIter);
    var sizes = new ArraySeq(iters).map(function (i) { return i.size; });
    zipSequence.size = zipAll ? sizes.max() : sizes.min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function (fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    zipSequence.__iteratorUncached = function (type, reverse) {
      var iterators = iters.map(
        function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }
      );
      var iterations = 0;
      var isDone = false;
      return new Iterator(function () {
        var steps;
        if (!isDone) {
          steps = iterators.map(function (i) { return i.next(); });
          isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });
        }
        if (isDone) {
          return iteratorDone();
        }
        return iteratorValue(
          type,
          iterations++,
          zipper.apply(
            null,
            steps.map(function (s) { return s.value; })
          )
        );
      });
    };
    return zipSequence;
  }

  // #pragma Helper Functions

  function reify(iter, seq) {
    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function collectionClass(collection) {
    return isKeyed(collection)
      ? KeyedCollection
      : isIndexed(collection)
      ? IndexedCollection
      : SetCollection;
  }

  function makeSequence(collection) {
    return Object.create(
      (isKeyed(collection)
        ? KeyedSeq
        : isIndexed(collection)
        ? IndexedSeq
        : SetSeq
      ).prototype
    );
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    }
    return Seq.prototype.cacheResult.call(this);
  }

  function defaultComparator(a, b) {
    if (a === undefined && b === undefined) {
      return 0;
    }

    if (a === undefined) {
      return 1;
    }

    if (b === undefined) {
      return -1;
    }

    return a > b ? 1 : a < b ? -1 : 0;
  }

  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }
    return newArr;
  }

  function invariant(condition, error) {
    if (!condition) { throw new Error(error); }
  }

  function assertNotInfinite(size) {
    invariant(
      size !== Infinity,
      'Cannot perform this action with an infinite size.'
    );
  }

  function coerceKeyPath(keyPath) {
    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {
      return keyPath;
    }
    if (isOrdered(keyPath)) {
      return keyPath.toArray();
    }
    throw new TypeError(
      'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath
    );
  }

  var toString = Object.prototype.toString;

  function isPlainObject(value) {
    // The base prototype's toString deals with Argument objects and native namespaces like Math
    if (
      !value ||
      typeof value !== 'object' ||
      toString.call(value) !== '[object Object]'
    ) {
      return false;
    }

    var proto = Object.getPrototypeOf(value);
    if (proto === null) {
      return true;
    }

    // Iteratively going up the prototype chain is needed for cross-realm environments (differing contexts, iframes, etc)
    var parentProto = proto;
    var nextProto = Object.getPrototypeOf(proto);
    while (nextProto !== null) {
      parentProto = nextProto;
      nextProto = Object.getPrototypeOf(parentProto);
    }
    return parentProto === proto;
  }

  /**
   * Returns true if the value is a potentially-persistent data structure, either
   * provided by Immutable.js or a plain Array or Object.
   */
  function isDataStructure(value) {
    return (
      typeof value === 'object' &&
      (isImmutable(value) || Array.isArray(value) || isPlainObject(value))
    );
  }

  function quoteString(value) {
    try {
      return typeof value === 'string' ? JSON.stringify(value) : String(value);
    } catch (_ignoreError) {
      return JSON.stringify(value);
    }
  }

  function has(collection, key) {
    return isImmutable(collection)
      ? collection.has(key)
      : isDataStructure(collection) && hasOwnProperty.call(collection, key);
  }

  function get(collection, key, notSetValue) {
    return isImmutable(collection)
      ? collection.get(key, notSetValue)
      : !has(collection, key)
      ? notSetValue
      : typeof collection.get === 'function'
      ? collection.get(key)
      : collection[key];
  }

  function shallowCopy(from) {
    if (Array.isArray(from)) {
      return arrCopy(from);
    }
    var to = {};
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    return to;
  }

  function remove(collection, key) {
    if (!isDataStructure(collection)) {
      throw new TypeError(
        'Cannot update non-data-structure value: ' + collection
      );
    }
    if (isImmutable(collection)) {
      if (!collection.remove) {
        throw new TypeError(
          'Cannot update immutable value without .remove() method: ' + collection
        );
      }
      return collection.remove(key);
    }
    if (!hasOwnProperty.call(collection, key)) {
      return collection;
    }
    var collectionCopy = shallowCopy(collection);
    if (Array.isArray(collectionCopy)) {
      collectionCopy.splice(key, 1);
    } else {
      delete collectionCopy[key];
    }
    return collectionCopy;
  }

  function set(collection, key, value) {
    if (!isDataStructure(collection)) {
      throw new TypeError(
        'Cannot update non-data-structure value: ' + collection
      );
    }
    if (isImmutable(collection)) {
      if (!collection.set) {
        throw new TypeError(
          'Cannot update immutable value without .set() method: ' + collection
        );
      }
      return collection.set(key, value);
    }
    if (hasOwnProperty.call(collection, key) && value === collection[key]) {
      return collection;
    }
    var collectionCopy = shallowCopy(collection);
    collectionCopy[key] = value;
    return collectionCopy;
  }

  function updateIn$1(collection, keyPath, notSetValue, updater) {
    if (!updater) {
      updater = notSetValue;
      notSetValue = undefined;
    }
    var updatedValue = updateInDeeply(
      isImmutable(collection),
      collection,
      coerceKeyPath(keyPath),
      0,
      notSetValue,
      updater
    );
    return updatedValue === NOT_SET ? notSetValue : updatedValue;
  }

  function updateInDeeply(
    inImmutable,
    existing,
    keyPath,
    i,
    notSetValue,
    updater
  ) {
    var wasNotSet = existing === NOT_SET;
    if (i === keyPath.length) {
      var existingValue = wasNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }
    if (!wasNotSet && !isDataStructure(existing)) {
      throw new TypeError(
        'Cannot update within non-data-structure value in path [' +
          keyPath.slice(0, i).map(quoteString) +
          ']: ' +
          existing
      );
    }
    var key = keyPath[i];
    var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
    var nextUpdated = updateInDeeply(
      nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
      nextExisting,
      keyPath,
      i + 1,
      notSetValue,
      updater
    );
    return nextUpdated === nextExisting
      ? existing
      : nextUpdated === NOT_SET
      ? remove(existing, key)
      : set(
          wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,
          key,
          nextUpdated
        );
  }

  function setIn$1(collection, keyPath, value) {
    return updateIn$1(collection, keyPath, NOT_SET, function () { return value; });
  }

  function setIn(keyPath, v) {
    return setIn$1(this, keyPath, v);
  }

  function removeIn(collection, keyPath) {
    return updateIn$1(collection, keyPath, function () { return NOT_SET; });
  }

  function deleteIn(keyPath) {
    return removeIn(this, keyPath);
  }

  function update$1(collection, key, notSetValue, updater) {
    return updateIn$1(collection, [key], notSetValue, updater);
  }

  function update(key, notSetValue, updater) {
    return arguments.length === 1
      ? key(this)
      : update$1(this, key, notSetValue, updater);
  }

  function updateIn(keyPath, notSetValue, updater) {
    return updateIn$1(this, keyPath, notSetValue, updater);
  }

  function merge$1() {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    return mergeIntoKeyedWith(this, iters);
  }

  function mergeWith$1(merger) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    if (typeof merger !== 'function') {
      throw new TypeError('Invalid merger function: ' + merger);
    }
    return mergeIntoKeyedWith(this, iters, merger);
  }

  function mergeIntoKeyedWith(collection, collections, merger) {
    var iters = [];
    for (var ii = 0; ii < collections.length; ii++) {
      var collection$1 = KeyedCollection(collections[ii]);
      if (collection$1.size !== 0) {
        iters.push(collection$1);
      }
    }
    if (iters.length === 0) {
      return collection;
    }
    if (
      collection.toSeq().size === 0 &&
      !collection.__ownerID &&
      iters.length === 1
    ) {
      return collection.constructor(iters[0]);
    }
    return collection.withMutations(function (collection) {
      var mergeIntoCollection = merger
        ? function (value, key) {
            update$1(collection, key, NOT_SET, function (oldVal) { return oldVal === NOT_SET ? value : merger(oldVal, value, key); }
            );
          }
        : function (value, key) {
            collection.set(key, value);
          };
      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoCollection);
      }
    });
  }

  function merge(collection) {
    var sources = [], len = arguments.length - 1;
    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

    return mergeWithSources(collection, sources);
  }

  function mergeWith(merger, collection) {
    var sources = [], len = arguments.length - 2;
    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];

    return mergeWithSources(collection, sources, merger);
  }

  function mergeDeep$1(collection) {
    var sources = [], len = arguments.length - 1;
    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

    return mergeDeepWithSources(collection, sources);
  }

  function mergeDeepWith$1(merger, collection) {
    var sources = [], len = arguments.length - 2;
    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];

    return mergeDeepWithSources(collection, sources, merger);
  }

  function mergeDeepWithSources(collection, sources, merger) {
    return mergeWithSources(collection, sources, deepMergerWith(merger));
  }

  function mergeWithSources(collection, sources, merger) {
    if (!isDataStructure(collection)) {
      throw new TypeError(
        'Cannot merge into non-data-structure value: ' + collection
      );
    }
    if (isImmutable(collection)) {
      return typeof merger === 'function' && collection.mergeWith
        ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))
        : collection.merge
        ? collection.merge.apply(collection, sources)
        : collection.concat.apply(collection, sources);
    }
    var isArray = Array.isArray(collection);
    var merged = collection;
    var Collection = isArray ? IndexedCollection : KeyedCollection;
    var mergeItem = isArray
      ? function (value) {
          // Copy on write
          if (merged === collection) {
            merged = shallowCopy(merged);
          }
          merged.push(value);
        }
      : function (value, key) {
          var hasVal = hasOwnProperty.call(merged, key);
          var nextVal =
            hasVal && merger ? merger(merged[key], value, key) : value;
          if (!hasVal || nextVal !== merged[key]) {
            // Copy on write
            if (merged === collection) {
              merged = shallowCopy(merged);
            }
            merged[key] = nextVal;
          }
        };
    for (var i = 0; i < sources.length; i++) {
      Collection(sources[i]).forEach(mergeItem);
    }
    return merged;
  }

  function deepMergerWith(merger) {
    function deepMerger(oldValue, newValue, key) {
      return isDataStructure(oldValue) &&
        isDataStructure(newValue) &&
        areMergeable(oldValue, newValue)
        ? mergeWithSources(oldValue, [newValue], deepMerger)
        : merger
        ? merger(oldValue, newValue, key)
        : newValue;
    }
    return deepMerger;
  }

  /**
   * It's unclear what the desired behavior is for merging two collections that
   * fall into separate categories between keyed, indexed, or set-like, so we only
   * consider them mergeable if they fall into the same category.
   */
  function areMergeable(oldDataStructure, newDataStructure) {
    var oldSeq = Seq(oldDataStructure);
    var newSeq = Seq(newDataStructure);
    // This logic assumes that a sequence can only fall into one of the three
    // categories mentioned above (since there's no `isSetLike()` method).
    return (
      isIndexed(oldSeq) === isIndexed(newSeq) &&
      isKeyed(oldSeq) === isKeyed(newSeq)
    );
  }

  function mergeDeep() {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    return mergeDeepWithSources(this, iters);
  }

  function mergeDeepWith(merger) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return mergeDeepWithSources(this, iters, merger);
  }

  function mergeIn(keyPath) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return updateIn$1(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });
  }

  function mergeDeepIn(keyPath) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return updateIn$1(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }
    );
  }

  function withMutations(fn) {
    var mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  }

  function asMutable() {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  }

  function asImmutable() {
    return this.__ensureOwner();
  }

  function wasAltered() {
    return this.__altered;
  }

  var Map = /*@__PURE__*/(function (KeyedCollection) {
    function Map(value) {
      return value === undefined || value === null
        ? emptyMap()
        : isMap(value) && !isOrdered(value)
        ? value
        : emptyMap().withMutations(function (map) {
            var iter = KeyedCollection(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v, k) { return map.set(k, v); });
          });
    }

    if ( KeyedCollection ) Map.__proto__ = KeyedCollection;
    Map.prototype = Object.create( KeyedCollection && KeyedCollection.prototype );
    Map.prototype.constructor = Map;

    Map.of = function of () {
      var keyValues = [], len = arguments.length;
      while ( len-- ) keyValues[ len ] = arguments[ len ];

      return emptyMap().withMutations(function (map) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };

    Map.prototype.toString = function toString () {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function get (k, notSetValue) {
      return this._root
        ? this._root.get(0, undefined, k, notSetValue)
        : notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function set (k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.remove = function remove (k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteAll = function deleteAll (keys) {
      var collection = Collection(keys);

      if (collection.size === 0) {
        return this;
      }

      return this.withMutations(function (map) {
        collection.forEach(function (key) { return map.remove(key); });
      });
    };

    Map.prototype.clear = function clear () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.sort = function sort (comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function sortBy (mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    Map.prototype.map = function map (mapper, context) {
      var this$1$1 = this;

      return this.withMutations(function (map) {
        map.forEach(function (value, key) {
          map.set(key, mapper.call(context, value, key, this$1$1));
        });
      });
    };

    // @pragma Mutability

    Map.prototype.__iterator = function __iterator (type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1$1 = this;

      var iterations = 0;
      this._root &&
        this._root.iterate(function (entry) {
          iterations++;
          return fn(entry[1], entry[0], this$1$1);
        }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        if (this.size === 0) {
          return emptyMap();
        }
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };

    return Map;
  }(KeyedCollection));

  Map.isMap = isMap;

  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SYMBOL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeAll = MapPrototype.deleteAll;
  MapPrototype.setIn = setIn;
  MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
  MapPrototype.update = update;
  MapPrototype.updateIn = updateIn;
  MapPrototype.merge = MapPrototype.concat = merge$1;
  MapPrototype.mergeWith = mergeWith$1;
  MapPrototype.mergeDeep = mergeDeep;
  MapPrototype.mergeDeepWith = mergeDeepWith;
  MapPrototype.mergeIn = mergeIn;
  MapPrototype.mergeDeepIn = mergeDeepIn;
  MapPrototype.withMutations = withMutations;
  MapPrototype.wasAltered = wasAltered;
  MapPrototype.asImmutable = asImmutable;
  MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;
  MapPrototype['@@transducer/step'] = function (result, arr) {
    return result.set(arr[0], arr[1]);
  };
  MapPrototype['@@transducer/result'] = function (obj) {
    return obj.asImmutable();
  };

  // #pragma Trie Nodes

  var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
    this.ownerID = ownerID;
    this.entries = entries;
  };

  ArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
    var entries = this.entries;
    for (var ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  };

  ArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    var removed = value === NOT_SET;

    var entries = this.entries;
    var idx = 0;
    var len = entries.length;
    for (; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    var exists = idx < len;

    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }

    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);

    if (removed && entries.length === 1) {
      return; // undefined
    }

    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
      return createNodes(ownerID, entries, key, value);
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);

    if (exists) {
      if (removed) {
        idx === len - 1
          ? newEntries.pop()
          : (newEntries[idx] = newEntries.pop());
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }

    if (isEditable) {
      this.entries = newEntries;
      return this;
    }

    return new ArrayMapNode(ownerID, newEntries);
  };

  var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
    this.ownerID = ownerID;
    this.bitmap = bitmap;
    this.nodes = nodes;
  };

  BitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }
    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
    var bitmap = this.bitmap;
    return (bitmap & bit) === 0
      ? notSetValue
      : this.nodes[popCount(bitmap & (bit - 1))].get(
          shift + SHIFT,
          keyHash,
          key,
          notSetValue
        );
  };

  BitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }
    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var bit = 1 << keyHashFrag;
    var bitmap = this.bitmap;
    var exists = (bitmap & bit) !== 0;

    if (!exists && value === NOT_SET) {
      return this;
    }

    var idx = popCount(bitmap & (bit - 1));
    var nodes = this.nodes;
    var node = exists ? nodes[idx] : undefined;
    var newNode = updateNode(
      node,
      ownerID,
      shift + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );

    if (newNode === node) {
      return this;
    }

    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
    }

    if (
      exists &&
      !newNode &&
      nodes.length === 2 &&
      isLeafNode(nodes[idx ^ 1])
    ) {
      return nodes[idx ^ 1];
    }

    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
      return newNode;
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;
    var newNodes = exists
      ? newNode
        ? setAt(nodes, idx, newNode, isEditable)
        : spliceOut(nodes, idx, isEditable)
      : spliceIn(nodes, idx, newNode, isEditable);

    if (isEditable) {
      this.bitmap = newBitmap;
      this.nodes = newNodes;
      return this;
    }

    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
  };

  var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
    this.ownerID = ownerID;
    this.count = count;
    this.nodes = nodes;
  };

  HashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }
    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var node = this.nodes[idx];
    return node
      ? node.get(shift + SHIFT, keyHash, key, notSetValue)
      : notSetValue;
  };

  HashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }
    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var removed = value === NOT_SET;
    var nodes = this.nodes;
    var node = nodes[idx];

    if (removed && !node) {
      return this;
    }

    var newNode = updateNode(
      node,
      ownerID,
      shift + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
    if (newNode === node) {
      return this;
    }

    var newCount = this.count;
    if (!node) {
      newCount++;
    } else if (!newNode) {
      newCount--;
      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
        return packNodes(ownerID, nodes, newCount, idx);
      }
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newNodes = setAt(nodes, idx, newNode, isEditable);

    if (isEditable) {
      this.count = newCount;
      this.nodes = newNodes;
      return this;
    }

    return new HashArrayMapNode(ownerID, newCount, newNodes);
  };

  var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entries = entries;
  };

  HashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
    var entries = this.entries;
    for (var ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  };

  HashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var removed = value === NOT_SET;

    if (keyHash !== this.keyHash) {
      if (removed) {
        return this;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
    }

    var entries = this.entries;
    var idx = 0;
    var len = entries.length;
    for (; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    var exists = idx < len;

    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }

    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);

    if (removed && len === 2) {
      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);

    if (exists) {
      if (removed) {
        idx === len - 1
          ? newEntries.pop()
          : (newEntries[idx] = newEntries.pop());
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }

    if (isEditable) {
      this.entries = newEntries;
      return this;
    }

    return new HashCollisionNode(ownerID, this.keyHash, newEntries);
  };

  var ValueNode = function ValueNode(ownerID, keyHash, entry) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entry = entry;
  };

  ValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  };

  ValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    var removed = value === NOT_SET;
    var keyMatch = is(key, this.entry[0]);
    if (keyMatch ? value === this.entry[1] : removed) {
      return this;
    }

    SetRef(didAlter);

    if (removed) {
      SetRef(didChangeSize);
      return; // undefined
    }

    if (keyMatch) {
      if (ownerID && ownerID === this.ownerID) {
        this.entry[1] = value;
        return this;
      }
      return new ValueNode(ownerID, this.keyHash, [key, value]);
    }

    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
  };

  // #pragma Iterators

  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate =
    function (fn, reverse) {
      var entries = this.entries;
      for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };

  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate =
    function (fn, reverse) {
      var nodes = this.nodes;
      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse) === false) {
          return false;
        }
      }
    };

  // eslint-disable-next-line no-unused-vars
  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  };

  var MapIterator = /*@__PURE__*/(function (Iterator) {
    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    if ( Iterator ) MapIterator.__proto__ = Iterator;
    MapIterator.prototype = Object.create( Iterator && Iterator.prototype );
    MapIterator.prototype.constructor = MapIterator;

    MapIterator.prototype.next = function next () {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex = (void 0);
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(
              type,
              node.entries[this._reverse ? maxIndex - index : index]
            );
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };

    return MapIterator;
  }(Iterator));

  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev,
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;
  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }
      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef();
      var didAlter = MakeRef();
      newRoot = updateNode(
        map._root,
        map.__ownerID,
        0,
        undefined,
        k,
        v,
        didChangeSize,
        didAlter
      );
      if (!didAlter.value) {
        return map;
      }
      newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);
    }
    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(
    node,
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  ) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(
      ownerID,
      shift,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
  }

  function isLeafNode(node) {
    return (
      node.constructor === ValueNode || node.constructor === HashCollisionNode
    );
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

    var newNode;
    var nodes =
      idx1 === idx2
        ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]
        : ((newNode = new ValueNode(ownerID, keyHash, entry)),
          idx1 < idx2 ? [node, newNode] : [newNode, node]);

    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];
      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function popCount(x) {
    x -= (x >> 1) & 0x55555555;
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x += x >> 8;
    x += x >> 16;
    return x & 0x7f;
  }

  function setAt(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }
    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }
      newArray[ii] = array[ii + after];
    }
    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';

  function isList(maybeList) {
    return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
  }

  var List = /*@__PURE__*/(function (IndexedCollection) {
    function List(value) {
      var empty = emptyList();
      if (value === undefined || value === null) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedCollection(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function (list) {
        list.setSize(size);
        iter.forEach(function (v, i) { return list.set(i, v); });
      });
    }

    if ( IndexedCollection ) List.__proto__ = IndexedCollection;
    List.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );
    List.prototype.constructor = List;

    List.of = function of (/*...values*/) {
      return this(arguments);
    };

    List.prototype.toString = function toString () {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function get (index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function set (index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function remove (index) {
      return !this.has(index)
        ? this
        : index === 0
        ? this.shift()
        : index === this.size - 1
        ? this.pop()
        : this.splice(index, 1);
    };

    List.prototype.insert = function insert (index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function clear () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function push (/*...values*/) {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function (list) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function pop () {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function unshift (/*...values*/) {
      var values = arguments;
      return this.withMutations(function (list) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function shift () {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.concat = function concat (/*...collections*/) {
      var arguments$1 = arguments;

      var seqs = [];
      for (var i = 0; i < arguments.length; i++) {
        var argument = arguments$1[i];
        var seq = IndexedCollection(
          typeof argument !== 'string' && hasIterator(argument)
            ? argument
            : [argument]
        );
        if (seq.size !== 0) {
          seqs.push(seq);
        }
      }
      if (seqs.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
        return this.constructor(seqs[0]);
      }
      return this.withMutations(function (list) {
        seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });
      });
    };

    List.prototype.setSize = function setSize (size) {
      return setListBounds(this, 0, size);
    };

    List.prototype.map = function map (mapper, context) {
      var this$1$1 = this;

      return this.withMutations(function (list) {
        for (var i = 0; i < this$1$1.size; i++) {
          list.set(i, mapper.call(context, list.get(i), i, this$1$1));
        }
      });
    };

    // @pragma Iteration

    List.prototype.slice = function slice (begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };

    List.prototype.__iterator = function __iterator (type, reverse) {
      var index = reverse ? this.size : 0;
      var values = iterateList(this, reverse);
      return new Iterator(function () {
        var value = values();
        return value === DONE
          ? iteratorDone()
          : iteratorValue(type, reverse ? --index : index++, value);
      });
    };

    List.prototype.__iterate = function __iterate (fn, reverse) {
      var index = reverse ? this.size : 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, reverse ? --index : index++, this) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function __ensureOwner (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        if (this.size === 0) {
          return emptyList();
        }
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeList(
        this._origin,
        this._capacity,
        this._level,
        this._root,
        this._tail,
        ownerID,
        this.__hash
      );
    };

    return List;
  }(IndexedCollection));

  List.isList = isList;

  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SYMBOL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.merge = ListPrototype.concat;
  ListPrototype.setIn = setIn;
  ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
  ListPrototype.update = update;
  ListPrototype.updateIn = updateIn;
  ListPrototype.mergeIn = mergeIn;
  ListPrototype.mergeDeepIn = mergeDeepIn;
  ListPrototype.withMutations = withMutations;
  ListPrototype.wasAltered = wasAltered;
  ListPrototype.asImmutable = asImmutable;
  ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;
  ListPrototype['@@transducer/step'] = function (result, arr) {
    return result.push(arr);
  };
  ListPrototype['@@transducer/result'] = function (obj) {
    return obj.asImmutable();
  };

  var VNode = function VNode(array, ownerID) {
    this.array = array;
    this.ownerID = ownerID;
  };

  // TODO: seems like these methods are very similar

  VNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {
    if (index === level ? 1 << level : this.array.length === 0) {
      return this;
    }
    var originIndex = (index >>> level) & MASK;
    if (originIndex >= this.array.length) {
      return new VNode([], ownerID);
    }
    var removingFirst = originIndex === 0;
    var newChild;
    if (level > 0) {
      var oldChild = this.array[originIndex];
      newChild =
        oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
      if (newChild === oldChild && removingFirst) {
        return this;
      }
    }
    if (removingFirst && !newChild) {
      return this;
    }
    var editable = editableVNode(this, ownerID);
    if (!removingFirst) {
      for (var ii = 0; ii < originIndex; ii++) {
        editable.array[ii] = undefined;
      }
    }
    if (newChild) {
      editable.array[originIndex] = newChild;
    }
    return editable;
  };

  VNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {
    if (index === (level ? 1 << level : 0) || this.array.length === 0) {
      return this;
    }
    var sizeIndex = ((index - 1) >>> level) & MASK;
    if (sizeIndex >= this.array.length) {
      return this;
    }

    var newChild;
    if (level > 0) {
      var oldChild = this.array[sizeIndex];
      newChild =
        oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
      if (newChild === oldChild && sizeIndex === this.array.length - 1) {
        return this;
      }
    }

    var editable = editableVNode(this, ownerID);
    editable.array.splice(sizeIndex + 1);
    if (newChild) {
      editable.array[sizeIndex] = newChild;
    }
    return editable;
  };

  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;

    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0
        ? iterateLeaf(node, offset)
        : iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;
      if (to > SIZE) {
        to = SIZE;
      }
      return function () {
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : (left - offset) >> level;
      var to = ((right - offset) >> level) + 1;
      if (to > SIZE) {
        to = SIZE;
      }
      return function () {
        while (true) {
          if (values) {
            var value = values();
            if (value !== DONE) {
              return value;
            }
            values = null;
          }
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(
            array && array[idx],
            level - SHIFT,
            offset + (idx << level)
          );
        }
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;
  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function (list) {
        index < 0
          ? setListBounds(list, index).set(0, value)
          : setListBounds(list, 0, index + 1).set(index, value);
      });
    }

    index += list._origin;

    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef();
    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(
        newRoot,
        list.__ownerID,
        list._level,
        index,
        value,
        didAlter
      );
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(
        lowerNode,
        ownerID,
        level - SHIFT,
        index,
        value,
        didAlter
      );
      if (newLowerNode === lowerNode) {
        return node;
      }
      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    if (didAlter) {
      SetRef(didAlter);
    }

    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }
    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
      var node = list._root;
      var level = list._level;
      while (node && level > 0) {
        node = node.array[(rawIndex >>> level) & MASK];
        level -= SHIFT;
      }
      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin |= 0;
    }
    if (end !== undefined) {
      end |= 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity =
      end === undefined
        ? oldCapacity
        : end < 0
        ? oldCapacity + end
        : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    }

    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root;

    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(
        newRoot && newRoot.array.length ? [undefined, newRoot] : [],
        owner
      );
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);

    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
      newRoot = new VNode(
        newRoot && newRoot.array.length ? [newRoot] : [],
        owner
      );
      newLevel += SHIFT;
    }

    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail =
      newTailOffset < oldTailOffset
        ? listNodeFor(list, newCapacity - 1)
        : newTailOffset > oldTailOffset
        ? new VNode([], owner)
        : oldTail;

    // Merge Tail into tree.
    if (
      oldTail &&
      newTailOffset > oldTailOffset &&
      newOrigin < oldCapacity &&
      oldTail.array.length
    ) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;
      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = (oldTailOffset >>> level) & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }
      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }

    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }

    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

      // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0;

      // Identify the new top root node of the subtree of the old root.
      while (newRoot) {
        var beginIndex = (newOrigin >>> newLevel) & MASK;
        if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {
          break;
        }
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      }

      // Trim the new sides of the new root.
      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }
      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(
          owner,
          newLevel,
          newTailOffset - offsetShift
        );
      }
      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;
  }

  var OrderedMap = /*@__PURE__*/(function (Map) {
    function OrderedMap(value) {
      return value === undefined || value === null
        ? emptyOrderedMap()
        : isOrderedMap(value)
        ? value
        : emptyOrderedMap().withMutations(function (map) {
            var iter = KeyedCollection(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v, k) { return map.set(k, v); });
          });
    }

    if ( Map ) OrderedMap.__proto__ = Map;
    OrderedMap.prototype = Object.create( Map && Map.prototype );
    OrderedMap.prototype.constructor = OrderedMap;

    OrderedMap.of = function of (/*...values*/) {
      return this(arguments);
    };

    OrderedMap.prototype.toString = function toString () {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function get (k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function clear () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        this.__altered = true;
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function set (k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function remove (k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1$1 = this;

      return this._list.__iterate(
        function (entry) { return entry && fn(entry[1], entry[0], this$1$1); },
        reverse
      );
    };

    OrderedMap.prototype.__iterator = function __iterator (type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        if (this.size === 0) {
          return emptyOrderedMap();
        }
        this.__ownerID = ownerID;
        this.__altered = false;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };

    return OrderedMap;
  }(Map));

  OrderedMap.isOrderedMap = isOrderedMap;

  OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    omap.__altered = false;
    return omap;
  }

  var EMPTY_ORDERED_MAP;
  function emptyOrderedMap() {
    return (
      EMPTY_ORDERED_MAP ||
      (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))
    );
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) {
      // removed
      if (!has) {
        return omap;
      }
      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });
        newMap = newList
          .toKeyedSeq()
          .map(function (entry) { return entry[0]; })
          .flip()
          .toMap();
        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else if (has) {
      if (v === list.get(i)[1]) {
        return omap;
      }
      newMap = map;
      newList = list.set(i, [k, v]);
    } else {
      newMap = map.set(k, list.size);
      newList = list.set(list.size, [k, v]);
    }
    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      omap.__altered = true;
      return omap;
    }
    return makeOrderedMap(newMap, newList);
  }

  var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';

  function isStack(maybeStack) {
    return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
  }

  var Stack = /*@__PURE__*/(function (IndexedCollection) {
    function Stack(value) {
      return value === undefined || value === null
        ? emptyStack()
        : isStack(value)
        ? value
        : emptyStack().pushAll(value);
    }

    if ( IndexedCollection ) Stack.__proto__ = IndexedCollection;
    Stack.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );
    Stack.prototype.constructor = Stack;

    Stack.of = function of (/*...values*/) {
      return this(arguments);
    };

    Stack.prototype.toString = function toString () {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function get (index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function peek () {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function push (/*...values*/) {
      var arguments$1 = arguments;

      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments$1[ii],
          next: head,
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function pushAll (iter) {
      iter = IndexedCollection(iter);
      if (iter.size === 0) {
        return this;
      }
      if (this.size === 0 && isStack(iter)) {
        return iter;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.__iterate(function (value) {
        newSize++;
        head = {
          value: value,
          next: head,
        };
      }, /* reverse */ true);
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function pop () {
      return this.slice(1);
    };

    Stack.prototype.clear = function clear () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function slice (begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        if (this.size === 0) {
          return emptyStack();
        }
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1$1 = this;

      if (reverse) {
        return new ArraySeq(this.toArray()).__iterate(
          function (v, k) { return fn(v, k, this$1$1); },
          reverse
        );
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function __iterator (type, reverse) {
      if (reverse) {
        return new ArraySeq(this.toArray()).__iterator(type, reverse);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function () {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };

    return Stack;
  }(IndexedCollection));

  Stack.isStack = isStack;

  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SYMBOL] = true;
  StackPrototype.shift = StackPrototype.pop;
  StackPrototype.unshift = StackPrototype.push;
  StackPrototype.unshiftAll = StackPrototype.pushAll;
  StackPrototype.withMutations = withMutations;
  StackPrototype.wasAltered = wasAltered;
  StackPrototype.asImmutable = asImmutable;
  StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;
  StackPrototype['@@transducer/step'] = function (result, arr) {
    return result.unshift(arr);
  };
  StackPrototype['@@transducer/result'] = function (obj) {
    return obj.asImmutable();
  };

  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;
  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }

  var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';

  function isSet(maybeSet) {
    return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
  }

  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (
      !isCollection(b) ||
      (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||
      (a.__hash !== undefined &&
        b.__hash !== undefined &&
        a.__hash !== b.__hash) ||
      isKeyed(a) !== isKeyed(b) ||
      isIndexed(a) !== isIndexed(b) ||
      isOrdered(a) !== isOrdered(b)
    ) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return (
        b.every(function (v, k) {
          var entry = entries.next().value;
          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
        }) && entries.next().done
      );
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;
    var bSize = b.__iterate(function (v, k) {
      if (
        notAssociative
          ? !a.has(v)
          : flipped
          ? !is(v, a.get(k, NOT_SET))
          : !is(a.get(k, NOT_SET), v)
      ) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  function mixin(ctor, methods) {
    var keyCopier = function (key) {
      ctor.prototype[key] = methods[key];
    };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  function toJS(value) {
    if (!value || typeof value !== 'object') {
      return value;
    }
    if (!isCollection(value)) {
      if (!isDataStructure(value)) {
        return value;
      }
      value = Seq(value);
    }
    if (isKeyed(value)) {
      var result$1 = {};
      value.__iterate(function (v, k) {
        result$1[k] = toJS(v);
      });
      return result$1;
    }
    var result = [];
    value.__iterate(function (v) {
      result.push(toJS(v));
    });
    return result;
  }

  var Set = /*@__PURE__*/(function (SetCollection) {
    function Set(value) {
      return value === undefined || value === null
        ? emptySet()
        : isSet(value) && !isOrdered(value)
        ? value
        : emptySet().withMutations(function (set) {
            var iter = SetCollection(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v) { return set.add(v); });
          });
    }

    if ( SetCollection ) Set.__proto__ = SetCollection;
    Set.prototype = Object.create( SetCollection && SetCollection.prototype );
    Set.prototype.constructor = Set;

    Set.of = function of (/*...values*/) {
      return this(arguments);
    };

    Set.fromKeys = function fromKeys (value) {
      return this(KeyedCollection(value).keySeq());
    };

    Set.intersect = function intersect (sets) {
      sets = Collection(sets).toArray();
      return sets.length
        ? SetPrototype.intersect.apply(Set(sets.pop()), sets)
        : emptySet();
    };

    Set.union = function union (sets) {
      sets = Collection(sets).toArray();
      return sets.length
        ? SetPrototype.union.apply(Set(sets.pop()), sets)
        : emptySet();
    };

    Set.prototype.toString = function toString () {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function has (value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function add (value) {
      return updateSet(this, this._map.set(value, value));
    };

    Set.prototype.remove = function remove (value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function clear () {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.map = function map (mapper, context) {
      var this$1$1 = this;

      // keep track if the set is altered by the map function
      var didChanges = false;

      var newMap = updateSet(
        this,
        this._map.mapEntries(function (ref) {
          var v = ref[1];

          var mapped = mapper.call(context, v, v, this$1$1);

          if (mapped !== v) {
            didChanges = true;
          }

          return [mapped, mapped];
        }, context)
      );

      return didChanges ? newMap : this;
    };

    Set.prototype.union = function union () {
      var iters = [], len = arguments.length;
      while ( len-- ) iters[ len ] = arguments[ len ];

      iters = iters.filter(function (x) { return x.size !== 0; });
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function (set) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetCollection(iters[ii]).forEach(function (value) { return set.add(value); });
        }
      });
    };

    Set.prototype.intersect = function intersect () {
      var iters = [], len = arguments.length;
      while ( len-- ) iters[ len ] = arguments[ len ];

      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function (iter) { return SetCollection(iter); });
      var toRemove = [];
      this.forEach(function (value) {
        if (!iters.every(function (iter) { return iter.includes(value); })) {
          toRemove.push(value);
        }
      });
      return this.withMutations(function (set) {
        toRemove.forEach(function (value) {
          set.remove(value);
        });
      });
    };

    Set.prototype.subtract = function subtract () {
      var iters = [], len = arguments.length;
      while ( len-- ) iters[ len ] = arguments[ len ];

      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function (iter) { return SetCollection(iter); });
      var toRemove = [];
      this.forEach(function (value) {
        if (iters.some(function (iter) { return iter.includes(value); })) {
          toRemove.push(value);
        }
      });
      return this.withMutations(function (set) {
        toRemove.forEach(function (value) {
          set.remove(value);
        });
      });
    };

    Set.prototype.sort = function sort (comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function sortBy (mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function wasAltered () {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1$1 = this;

      return this._map.__iterate(function (k) { return fn(k, k, this$1$1); }, reverse);
    };

    Set.prototype.__iterator = function __iterator (type, reverse) {
      return this._map.__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        if (this.size === 0) {
          return this.__empty();
        }
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };

    return Set;
  }(SetCollection));

  Set.isSet = isSet;

  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SYMBOL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
  SetPrototype.withMutations = withMutations;
  SetPrototype.asImmutable = asImmutable;
  SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;
  SetPrototype['@@transducer/step'] = function (result, arr) {
    return result.add(arr);
  };
  SetPrototype['@@transducer/result'] = function (obj) {
    return obj.asImmutable();
  };

  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }
    return newMap === set._map
      ? set
      : newMap.size === 0
      ? set.__empty()
      : set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;
  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  /**
   * Returns a lazy seq of nums from start (inclusive) to end
   * (exclusive), by step, where start defaults to 0, step to 1, and end to
   * infinity. When start is equal to end, returns empty list.
   */
  var Range = /*@__PURE__*/(function (IndexedSeq) {
    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    if ( IndexedSeq ) Range.__proto__ = IndexedSeq;
    Range.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
    Range.prototype.constructor = Range;

    Range.prototype.toString = function toString () {
      if (this.size === 0) {
        return 'Range []';
      }
      return (
        'Range [ ' +
        this._start +
        '...' +
        this._end +
        (this._step !== 1 ? ' by ' + this._step : '') +
        ' ]'
      );
    };

    Range.prototype.get = function get (index, notSetValue) {
      return this.has(index)
        ? this._start + wrapIndex(this, index) * this._step
        : notSetValue;
    };

    Range.prototype.includes = function includes (searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return (
        possibleIndex >= 0 &&
        possibleIndex < this.size &&
        possibleIndex === Math.floor(possibleIndex)
      );
    };

    Range.prototype.slice = function slice (begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(
        this.get(begin, this._end),
        this.get(end, this._end),
        this._step
      );
    };

    Range.prototype.indexOf = function indexOf (searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index;
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function __iterate (fn, reverse) {
      var size = this.size;
      var step = this._step;
      var value = reverse ? this._start + (size - 1) * step : this._start;
      var i = 0;
      while (i !== size) {
        if (fn(value, reverse ? size - ++i : i++, this) === false) {
          break;
        }
        value += reverse ? -step : step;
      }
      return i;
    };

    Range.prototype.__iterator = function __iterator (type, reverse) {
      var size = this.size;
      var step = this._step;
      var value = reverse ? this._start + (size - 1) * step : this._start;
      var i = 0;
      return new Iterator(function () {
        if (i === size) {
          return iteratorDone();
        }
        var v = value;
        value += reverse ? -step : step;
        return iteratorValue(type, reverse ? size - ++i : i++, v);
      });
    };

    Range.prototype.equals = function equals (other) {
      return other instanceof Range
        ? this._start === other._start &&
            this._end === other._end &&
            this._step === other._step
        : deepEqual(this, other);
    };

    return Range;
  }(IndexedSeq));

  var EMPTY_RANGE;

  function getIn$1(collection, searchKeyPath, notSetValue) {
    var keyPath = coerceKeyPath(searchKeyPath);
    var i = 0;
    while (i !== keyPath.length) {
      collection = get(collection, keyPath[i++], NOT_SET);
      if (collection === NOT_SET) {
        return notSetValue;
      }
    }
    return collection;
  }

  function getIn(searchKeyPath, notSetValue) {
    return getIn$1(this, searchKeyPath, notSetValue);
  }

  function hasIn$1(collection, keyPath) {
    return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
  }

  function hasIn(searchKeyPath) {
    return hasIn$1(this, searchKeyPath);
  }

  function toObject() {
    assertNotInfinite(this.size);
    var object = {};
    this.__iterate(function (v, k) {
      object[k] = v;
    });
    return object;
  }

  // Note: all of these methods are deprecated.
  Collection.isIterable = isCollection;
  Collection.isKeyed = isKeyed;
  Collection.isIndexed = isIndexed;
  Collection.isAssociative = isAssociative;
  Collection.isOrdered = isOrdered;

  Collection.Iterator = Iterator;

  mixin(Collection, {
    // ### Conversion to other types

    toArray: function toArray() {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);
      var useTuples = isKeyed(this);
      var i = 0;
      this.__iterate(function (v, k) {
        // Keyed collections produce an array of tuples.
        array[i++] = useTuples ? [k, v] : v;
      });
      return array;
    },

    toIndexedSeq: function toIndexedSeq() {
      return new ToIndexedSequence(this);
    },

    toJS: function toJS$1() {
      return toJS(this);
    },

    toKeyedSeq: function toKeyedSeq() {
      return new ToKeyedSequence(this, true);
    },

    toMap: function toMap() {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },

    toObject: toObject,

    toOrderedMap: function toOrderedMap() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },

    toOrderedSet: function toOrderedSet() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },

    toSet: function toSet() {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },

    toSetSeq: function toSetSeq() {
      return new ToSetSequence(this);
    },

    toSeq: function toSeq() {
      return isIndexed(this)
        ? this.toIndexedSeq()
        : isKeyed(this)
        ? this.toKeyedSeq()
        : this.toSetSeq();
    },

    toStack: function toStack() {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },

    toList: function toList() {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },

    // ### Common JavaScript methods and properties

    toString: function toString() {
      return '[Collection]';
    },

    __toString: function __toString(head, tail) {
      if (this.size === 0) {
        return head + tail;
      }
      return (
        head +
        ' ' +
        this.toSeq().map(this.__toStringMapper).join(', ') +
        ' ' +
        tail
      );
    },

    // ### ES6 Collection methods (ES6 Array and Map)

    concat: function concat() {
      var values = [], len = arguments.length;
      while ( len-- ) values[ len ] = arguments[ len ];

      return reify(this, concatFactory(this, values));
    },

    includes: function includes(searchValue) {
      return this.some(function (value) { return is(value, searchValue); });
    },

    entries: function entries() {
      return this.__iterator(ITERATE_ENTRIES);
    },

    every: function every(predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;
      this.__iterate(function (v, k, c) {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });
      return returnValue;
    },

    filter: function filter(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },

    find: function find(predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },

    forEach: function forEach(sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },

    join: function join(separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;
      this.__iterate(function (v) {
        isFirst ? (isFirst = false) : (joined += separator);
        joined += v !== null && v !== undefined ? v.toString() : '';
      });
      return joined;
    },

    keys: function keys() {
      return this.__iterator(ITERATE_KEYS);
    },

    map: function map(mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },

    reduce: function reduce$1(reducer, initialReduction, context) {
      return reduce(
        this,
        reducer,
        initialReduction,
        context,
        arguments.length < 2,
        false
      );
    },

    reduceRight: function reduceRight(reducer, initialReduction, context) {
      return reduce(
        this,
        reducer,
        initialReduction,
        context,
        arguments.length < 2,
        true
      );
    },

    reverse: function reverse() {
      return reify(this, reverseFactory(this, true));
    },

    slice: function slice(begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },

    some: function some(predicate, context) {
      return !this.every(not(predicate), context);
    },

    sort: function sort(comparator) {
      return reify(this, sortFactory(this, comparator));
    },

    values: function values() {
      return this.__iterator(ITERATE_VALUES);
    },

    // ### More sequential methods

    butLast: function butLast() {
      return this.slice(0, -1);
    },

    isEmpty: function isEmpty() {
      return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });
    },

    count: function count(predicate, context) {
      return ensureSize(
        predicate ? this.toSeq().filter(predicate, context) : this
      );
    },

    countBy: function countBy(grouper, context) {
      return countByFactory(this, grouper, context);
    },

    equals: function equals(other) {
      return deepEqual(this, other);
    },

    entrySeq: function entrySeq() {
      var collection = this;
      if (collection._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(collection._cache);
      }
      var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
      entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };
      return entriesSequence;
    },

    filterNot: function filterNot(predicate, context) {
      return this.filter(not(predicate), context);
    },

    findEntry: function findEntry(predicate, context, notSetValue) {
      var found = notSetValue;
      this.__iterate(function (v, k, c) {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });
      return found;
    },

    findKey: function findKey(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },

    findLast: function findLast(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },

    findLastEntry: function findLastEntry(predicate, context, notSetValue) {
      return this.toKeyedSeq()
        .reverse()
        .findEntry(predicate, context, notSetValue);
    },

    findLastKey: function findLastKey(predicate, context) {
      return this.toKeyedSeq().reverse().findKey(predicate, context);
    },

    first: function first(notSetValue) {
      return this.find(returnTrue, null, notSetValue);
    },

    flatMap: function flatMap(mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },

    flatten: function flatten(depth) {
      return reify(this, flattenFactory(this, depth, true));
    },

    fromEntrySeq: function fromEntrySeq() {
      return new FromEntriesSequence(this);
    },

    get: function get(searchKey, notSetValue) {
      return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);
    },

    getIn: getIn,

    groupBy: function groupBy(grouper, context) {
      return groupByFactory(this, grouper, context);
    },

    has: function has(searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },

    hasIn: hasIn,

    isSubset: function isSubset(iter) {
      iter = typeof iter.includes === 'function' ? iter : Collection(iter);
      return this.every(function (value) { return iter.includes(value); });
    },

    isSuperset: function isSuperset(iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
      return iter.isSubset(this);
    },

    keyOf: function keyOf(searchValue) {
      return this.findKey(function (value) { return is(value, searchValue); });
    },

    keySeq: function keySeq() {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },

    last: function last(notSetValue) {
      return this.toSeq().reverse().first(notSetValue);
    },

    lastKeyOf: function lastKeyOf(searchValue) {
      return this.toKeyedSeq().reverse().keyOf(searchValue);
    },

    max: function max(comparator) {
      return maxFactory(this, comparator);
    },

    maxBy: function maxBy(mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },

    min: function min(comparator) {
      return maxFactory(
        this,
        comparator ? neg(comparator) : defaultNegComparator
      );
    },

    minBy: function minBy(mapper, comparator) {
      return maxFactory(
        this,
        comparator ? neg(comparator) : defaultNegComparator,
        mapper
      );
    },

    rest: function rest() {
      return this.slice(1);
    },

    skip: function skip(amount) {
      return amount === 0 ? this : this.slice(Math.max(0, amount));
    },

    skipLast: function skipLast(amount) {
      return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
    },

    skipWhile: function skipWhile(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },

    skipUntil: function skipUntil(predicate, context) {
      return this.skipWhile(not(predicate), context);
    },

    sortBy: function sortBy(mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },

    take: function take(amount) {
      return this.slice(0, Math.max(0, amount));
    },

    takeLast: function takeLast(amount) {
      return this.slice(-Math.max(0, amount));
    },

    takeWhile: function takeWhile(predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },

    takeUntil: function takeUntil(predicate, context) {
      return this.takeWhile(not(predicate), context);
    },

    update: function update(fn) {
      return fn(this);
    },

    valueSeq: function valueSeq() {
      return this.toIndexedSeq();
    },

    // ### Hashable Object

    hashCode: function hashCode() {
      return this.__hash || (this.__hash = hashCollection(this));
    },

    // ### Internal

    // abstract __iterate(fn, reverse)

    // abstract __iterator(type, reverse)
  });

  var CollectionPrototype = Collection.prototype;
  CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
  CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
  CollectionPrototype.toJSON = CollectionPrototype.toArray;
  CollectionPrototype.__toStringMapper = quoteString;
  CollectionPrototype.inspect = CollectionPrototype.toSource = function () {
    return this.toString();
  };
  CollectionPrototype.chain = CollectionPrototype.flatMap;
  CollectionPrototype.contains = CollectionPrototype.includes;

  mixin(KeyedCollection, {
    // ### More sequential methods

    flip: function flip() {
      return reify(this, flipFactory(this));
    },

    mapEntries: function mapEntries(mapper, context) {
      var this$1$1 = this;

      var iterations = 0;
      return reify(
        this,
        this.toSeq()
          .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1$1); })
          .fromEntrySeq()
      );
    },

    mapKeys: function mapKeys(mapper, context) {
      var this$1$1 = this;

      return reify(
        this,
        this.toSeq()
          .flip()
          .map(function (k, v) { return mapper.call(context, k, v, this$1$1); })
          .flip()
      );
    },
  });

  var KeyedCollectionPrototype = KeyedCollection.prototype;
  KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
  KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
  KeyedCollectionPrototype.toJSON = toObject;
  KeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };

  mixin(IndexedCollection, {
    // ### Conversion to other types

    toKeyedSeq: function toKeyedSeq() {
      return new ToKeyedSequence(this, false);
    },

    // ### ES6 Collection methods (ES6 Array and Map)

    filter: function filter(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },

    findIndex: function findIndex(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    indexOf: function indexOf(searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    lastIndexOf: function lastIndexOf(searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    reverse: function reverse() {
      return reify(this, reverseFactory(this, false));
    },

    slice: function slice(begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },

    splice: function splice(index, removeNum /*, ...values*/) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum || 0, 0);
      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
        return this;
      }
      // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.
      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(
        this,
        numArgs === 1
          ? spliced
          : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
      );
    },

    // ### More collection methods

    findLastIndex: function findLastIndex(predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    first: function first(notSetValue) {
      return this.get(0, notSetValue);
    },

    flatten: function flatten(depth) {
      return reify(this, flattenFactory(this, depth, false));
    },

    get: function get(index, notSetValue) {
      index = wrapIndex(this, index);
      return index < 0 ||
        this.size === Infinity ||
        (this.size !== undefined && index > this.size)
        ? notSetValue
        : this.find(function (_, key) { return key === index; }, undefined, notSetValue);
    },

    has: function has(index) {
      index = wrapIndex(this, index);
      return (
        index >= 0 &&
        (this.size !== undefined
          ? this.size === Infinity || index < this.size
          : this.indexOf(index) !== -1)
      );
    },

    interpose: function interpose(separator) {
      return reify(this, interposeFactory(this, separator));
    },

    interleave: function interleave(/*...collections*/) {
      var collections = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
      var interleaved = zipped.flatten(true);
      if (zipped.size) {
        interleaved.size = zipped.size * collections.length;
      }
      return reify(this, interleaved);
    },

    keySeq: function keySeq() {
      return Range(0, this.size);
    },

    last: function last(notSetValue) {
      return this.get(-1, notSetValue);
    },

    skipWhile: function skipWhile(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },

    zip: function zip(/*, ...collections */) {
      var collections = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, collections));
    },

    zipAll: function zipAll(/*, ...collections */) {
      var collections = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, collections, true));
    },

    zipWith: function zipWith(zipper /*, ...collections */) {
      var collections = arrCopy(arguments);
      collections[0] = this;
      return reify(this, zipWithFactory(this, zipper, collections));
    },
  });

  var IndexedCollectionPrototype = IndexedCollection.prototype;
  IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
  IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;

  mixin(SetCollection, {
    // ### ES6 Collection methods (ES6 Array and Map)

    get: function get(value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },

    includes: function includes(value) {
      return this.has(value);
    },

    // ### More sequential methods

    keySeq: function keySeq() {
      return this.valueSeq();
    },
  });

  var SetCollectionPrototype = SetCollection.prototype;
  SetCollectionPrototype.has = CollectionPrototype.includes;
  SetCollectionPrototype.contains = SetCollectionPrototype.includes;
  SetCollectionPrototype.keys = SetCollectionPrototype.values;

  // Mixin subclasses

  mixin(KeyedSeq, KeyedCollectionPrototype);
  mixin(IndexedSeq, IndexedCollectionPrototype);
  mixin(SetSeq, SetCollectionPrototype);

  // #pragma Helper functions

  function reduce(collection, reducer, reduction, context, useFirst, reverse) {
    assertNotInfinite(collection.size);
    collection.__iterate(function (v, k, c) {
      if (useFirst) {
        useFirst = false;
        reduction = v;
      } else {
        reduction = reducer.call(context, reduction, v, k, c);
      }
    }, reverse);
    return reduction;
  }

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function () {
      return !predicate.apply(this, arguments);
    };
  }

  function neg(predicate) {
    return function () {
      return -predicate.apply(this, arguments);
    };
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashCollection(collection) {
    if (collection.size === Infinity) {
      return 0;
    }
    var ordered = isOrdered(collection);
    var keyed = isKeyed(collection);
    var h = ordered ? 1 : 0;
    var size = collection.__iterate(
      keyed
        ? ordered
          ? function (v, k) {
              h = (31 * h + hashMerge(hash(v), hash(k))) | 0;
            }
          : function (v, k) {
              h = (h + hashMerge(hash(v), hash(k))) | 0;
            }
        : ordered
        ? function (v) {
            h = (31 * h + hash(v)) | 0;
          }
        : function (v) {
            h = (h + hash(v)) | 0;
          }
    );
    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xcc9e2d51);
    h = imul((h << 15) | (h >>> -15), 0x1b873593);
    h = imul((h << 13) | (h >>> -13), 5);
    h = ((h + 0xe6546b64) | 0) ^ size;
    h = imul(h ^ (h >>> 16), 0x85ebca6b);
    h = imul(h ^ (h >>> 13), 0xc2b2ae35);
    h = smi(h ^ (h >>> 16));
    return h;
  }

  function hashMerge(a, b) {
    return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int
  }

  var OrderedSet = /*@__PURE__*/(function (Set) {
    function OrderedSet(value) {
      return value === undefined || value === null
        ? emptyOrderedSet()
        : isOrderedSet(value)
        ? value
        : emptyOrderedSet().withMutations(function (set) {
            var iter = SetCollection(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v) { return set.add(v); });
          });
    }

    if ( Set ) OrderedSet.__proto__ = Set;
    OrderedSet.prototype = Object.create( Set && Set.prototype );
    OrderedSet.prototype.constructor = OrderedSet;

    OrderedSet.of = function of (/*...values*/) {
      return this(arguments);
    };

    OrderedSet.fromKeys = function fromKeys (value) {
      return this(KeyedCollection(value).keySeq());
    };

    OrderedSet.prototype.toString = function toString () {
      return this.__toString('OrderedSet {', '}');
    };

    return OrderedSet;
  }(Set));

  OrderedSet.isOrderedSet = isOrderedSet;

  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
  OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
  OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
  OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;

  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;
  function emptyOrderedSet() {
    return (
      EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))
    );
  }

  function throwOnInvalidDefaultValues(defaultValues) {
    if (isRecord(defaultValues)) {
      throw new Error(
        'Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead.'
      );
    }

    if (isImmutable(defaultValues)) {
      throw new Error(
        'Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead.'
      );
    }

    if (defaultValues === null || typeof defaultValues !== 'object') {
      throw new Error(
        'Can not call `Record` with a non-object as default values. Use a plain javascript object instead.'
      );
    }
  }

  var Record = function Record(defaultValues, name) {
    var hasInitialized;

    throwOnInvalidDefaultValues(defaultValues);

    var RecordType = function Record(values) {
      var this$1$1 = this;

      if (values instanceof RecordType) {
        return values;
      }
      if (!(this instanceof RecordType)) {
        return new RecordType(values);
      }
      if (!hasInitialized) {
        hasInitialized = true;
        var keys = Object.keys(defaultValues);
        var indices = (RecordTypePrototype._indices = {});
        // Deprecated: left to attempt not to break any external code which
        // relies on a ._name property existing on record instances.
        // Use Record.getDescriptiveName() instead
        RecordTypePrototype._name = name;
        RecordTypePrototype._keys = keys;
        RecordTypePrototype._defaultValues = defaultValues;
        for (var i = 0; i < keys.length; i++) {
          var propName = keys[i];
          indices[propName] = i;
          if (RecordTypePrototype[propName]) {
            /* eslint-disable no-console */
            typeof console === 'object' &&
              console.warn &&
              console.warn(
                'Cannot define ' +
                  recordName(this) +
                  ' with property "' +
                  propName +
                  '" since that property name is part of the Record API.'
              );
            /* eslint-enable no-console */
          } else {
            setProp(RecordTypePrototype, propName);
          }
        }
      }
      this.__ownerID = undefined;
      this._values = List().withMutations(function (l) {
        l.setSize(this$1$1._keys.length);
        KeyedCollection(values).forEach(function (v, k) {
          l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? undefined : v);
        });
      });
      return this;
    };

    var RecordTypePrototype = (RecordType.prototype =
      Object.create(RecordPrototype));
    RecordTypePrototype.constructor = RecordType;

    if (name) {
      RecordType.displayName = name;
    }

    return RecordType;
  };

  Record.prototype.toString = function toString () {
    var str = recordName(this) + ' { ';
    var keys = this._keys;
    var k;
    for (var i = 0, l = keys.length; i !== l; i++) {
      k = keys[i];
      str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));
    }
    return str + ' }';
  };

  Record.prototype.equals = function equals (other) {
    return (
      this === other ||
      (isRecord(other) && recordSeq(this).equals(recordSeq(other)))
    );
  };

  Record.prototype.hashCode = function hashCode () {
    return recordSeq(this).hashCode();
  };

  // @pragma Access

  Record.prototype.has = function has (k) {
    return this._indices.hasOwnProperty(k);
  };

  Record.prototype.get = function get (k, notSetValue) {
    if (!this.has(k)) {
      return notSetValue;
    }
    var index = this._indices[k];
    var value = this._values.get(index);
    return value === undefined ? this._defaultValues[k] : value;
  };

  // @pragma Modification

  Record.prototype.set = function set (k, v) {
    if (this.has(k)) {
      var newValues = this._values.set(
        this._indices[k],
        v === this._defaultValues[k] ? undefined : v
      );
      if (newValues !== this._values && !this.__ownerID) {
        return makeRecord(this, newValues);
      }
    }
    return this;
  };

  Record.prototype.remove = function remove (k) {
    return this.set(k);
  };

  Record.prototype.clear = function clear () {
    var newValues = this._values.clear().setSize(this._keys.length);

    return this.__ownerID ? this : makeRecord(this, newValues);
  };

  Record.prototype.wasAltered = function wasAltered () {
    return this._values.wasAltered();
  };

  Record.prototype.toSeq = function toSeq () {
    return recordSeq(this);
  };

  Record.prototype.toJS = function toJS$1 () {
    return toJS(this);
  };

  Record.prototype.entries = function entries () {
    return this.__iterator(ITERATE_ENTRIES);
  };

  Record.prototype.__iterator = function __iterator (type, reverse) {
    return recordSeq(this).__iterator(type, reverse);
  };

  Record.prototype.__iterate = function __iterate (fn, reverse) {
    return recordSeq(this).__iterate(fn, reverse);
  };

  Record.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newValues = this._values.__ensureOwner(ownerID);
    if (!ownerID) {
      this.__ownerID = ownerID;
      this._values = newValues;
      return this;
    }
    return makeRecord(this, newValues, ownerID);
  };

  Record.isRecord = isRecord;
  Record.getDescriptiveName = recordName;
  var RecordPrototype = Record.prototype;
  RecordPrototype[IS_RECORD_SYMBOL] = true;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
  RecordPrototype.getIn = getIn;
  RecordPrototype.hasIn = CollectionPrototype.hasIn;
  RecordPrototype.merge = merge$1;
  RecordPrototype.mergeWith = mergeWith$1;
  RecordPrototype.mergeIn = mergeIn;
  RecordPrototype.mergeDeep = mergeDeep;
  RecordPrototype.mergeDeepWith = mergeDeepWith;
  RecordPrototype.mergeDeepIn = mergeDeepIn;
  RecordPrototype.setIn = setIn;
  RecordPrototype.update = update;
  RecordPrototype.updateIn = updateIn;
  RecordPrototype.withMutations = withMutations;
  RecordPrototype.asMutable = asMutable;
  RecordPrototype.asImmutable = asImmutable;
  RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
  RecordPrototype.toJSON = RecordPrototype.toObject =
    CollectionPrototype.toObject;
  RecordPrototype.inspect = RecordPrototype.toSource = function () {
    return this.toString();
  };

  function makeRecord(likeRecord, values, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._values = values;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record.constructor.displayName || record.constructor.name || 'Record';
  }

  function recordSeq(record) {
    return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));
  }

  function setProp(prototype, name) {
    try {
      Object.defineProperty(prototype, name, {
        get: function () {
          return this.get(name);
        },
        set: function (value) {
          invariant(this.__ownerID, 'Cannot set on an immutable record.');
          this.set(name, value);
        },
      });
    } catch (error) {
      // Object.defineProperty failed. Probably IE8.
    }
  }

  /**
   * Returns a lazy Seq of `value` repeated `times` times. When `times` is
   * undefined, returns an infinite sequence of `value`.
   */
  var Repeat = /*@__PURE__*/(function (IndexedSeq) {
    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    if ( IndexedSeq ) Repeat.__proto__ = IndexedSeq;
    Repeat.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
    Repeat.prototype.constructor = Repeat;

    Repeat.prototype.toString = function toString () {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function get (index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function includes (searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function slice (begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size)
        ? this
        : new Repeat(
            this._value,
            resolveEnd(end, size) - resolveBegin(begin, size)
          );
    };

    Repeat.prototype.reverse = function reverse () {
      return this;
    };

    Repeat.prototype.indexOf = function indexOf (searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function __iterate (fn, reverse) {
      var size = this.size;
      var i = 0;
      while (i !== size) {
        if (fn(this._value, reverse ? size - ++i : i++, this) === false) {
          break;
        }
      }
      return i;
    };

    Repeat.prototype.__iterator = function __iterator (type, reverse) {
      var this$1$1 = this;

      var size = this.size;
      var i = 0;
      return new Iterator(function () { return i === size
          ? iteratorDone()
          : iteratorValue(type, reverse ? size - ++i : i++, this$1$1._value); }
      );
    };

    Repeat.prototype.equals = function equals (other) {
      return other instanceof Repeat
        ? is(this._value, other._value)
        : deepEqual(other);
    };

    return Repeat;
  }(IndexedSeq));

  var EMPTY_REPEAT;

  function fromJS(value, converter) {
    return fromJSWith(
      [],
      converter || defaultConverter,
      value,
      '',
      converter && converter.length > 2 ? [] : undefined,
      { '': value }
    );
  }

  function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
    if (
      typeof value !== 'string' &&
      !isImmutable(value) &&
      (isArrayLike(value) || hasIterator(value) || isPlainObject(value))
    ) {
      if (~stack.indexOf(value)) {
        throw new TypeError('Cannot convert circular structure to Immutable');
      }
      stack.push(value);
      keyPath && key !== '' && keyPath.push(key);
      var converted = converter.call(
        parentValue,
        key,
        Seq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }
        ),
        keyPath && keyPath.slice()
      );
      stack.pop();
      keyPath && keyPath.pop();
      return converted;
    }
    return value;
  }

  function defaultConverter(k, v) {
    // Effectively the opposite of "Collection.toSeq()"
    return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();
  }

  var version = "4.1.0";

  var Immutable = {
    version: version,

    Collection: Collection,
    // Note: Iterable is deprecated
    Iterable: Collection,

    Seq: Seq,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,

    Record: Record,
    Range: Range,
    Repeat: Repeat,

    is: is,
    fromJS: fromJS,
    hash: hash,

    isImmutable: isImmutable,
    isCollection: isCollection,
    isKeyed: isKeyed,
    isIndexed: isIndexed,
    isAssociative: isAssociative,
    isOrdered: isOrdered,
    isValueObject: isValueObject,
    isPlainObject: isPlainObject,
    isSeq: isSeq,
    isList: isList,
    isMap: isMap,
    isOrderedMap: isOrderedMap,
    isStack: isStack,
    isSet: isSet,
    isOrderedSet: isOrderedSet,
    isRecord: isRecord,

    get: get,
    getIn: getIn$1,
    has: has,
    hasIn: hasIn$1,
    merge: merge,
    mergeDeep: mergeDeep$1,
    mergeWith: mergeWith,
    mergeDeepWith: mergeDeepWith$1,
    remove: remove,
    removeIn: removeIn,
    set: set,
    setIn: setIn$1,
    update: update$1,
    updateIn: updateIn$1,
  };

  // Note: Iterable is deprecated
  var Iterable = Collection;

  exports.Collection = Collection;
  exports.Iterable = Iterable;
  exports.List = List;
  exports.Map = Map;
  exports.OrderedMap = OrderedMap;
  exports.OrderedSet = OrderedSet;
  exports.Range = Range;
  exports.Record = Record;
  exports.Repeat = Repeat;
  exports.Seq = Seq;
  exports.Set = Set;
  exports.Stack = Stack;
  exports.default = Immutable;
  exports.fromJS = fromJS;
  exports.get = get;
  exports.getIn = getIn$1;
  exports.has = has;
  exports.hasIn = hasIn$1;
  exports.hash = hash;
  exports.is = is;
  exports.isAssociative = isAssociative;
  exports.isCollection = isCollection;
  exports.isImmutable = isImmutable;
  exports.isIndexed = isIndexed;
  exports.isKeyed = isKeyed;
  exports.isList = isList;
  exports.isMap = isMap;
  exports.isOrdered = isOrdered;
  exports.isOrderedMap = isOrderedMap;
  exports.isOrderedSet = isOrderedSet;
  exports.isPlainObject = isPlainObject;
  exports.isRecord = isRecord;
  exports.isSeq = isSeq;
  exports.isSet = isSet;
  exports.isStack = isStack;
  exports.isValueObject = isValueObject;
  exports.merge = merge;
  exports.mergeDeep = mergeDeep$1;
  exports.mergeDeepWith = mergeDeepWith$1;
  exports.mergeWith = mergeWith;
  exports.remove = remove;
  exports.removeIn = removeIn;
  exports.set = set;
  exports.setIn = setIn$1;
  exports.update = update$1;
  exports.updateIn = updateIn$1;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],18:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Column = void 0;
class Column {
    constructor(
    /** the name of the column */
    name, 
    /** the relation alias of the name (or null) */
    relAlias, 
    /** optional type of the column */
    optionalType = 'null') {
        this._type = 'null';
        this._name = name;
        this._relAlias = relAlias;
        this._type = optionalType;
    }
    getName() {
        return this._name;
    }
    getRelAlias() {
        return this._relAlias;
    }
    getType() {
        return this._type;
    }
    setRelAlias(relAlias) {
        this._relAlias = relAlias;
    }
    toString() {
        return Column.printColumn(this._name, this._relAlias);
    }
    equals(columnB) {
        return this._name === columnB._name && this._relAlias === columnB._relAlias;
    }
    static printColumn(name, relAlias) {
        let pName;
        if (typeof (name) === 'number') {
            pName = `[${name}]`;
        }
        else {
            pName = name;
        }
        if (relAlias === null) {
            return pName;
        }
        return `${relAlias}.${pName}`;
    }
}
exports.Column = Column;

},{}],19:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Difference = void 0;
const i18n = require("i18next");
const RANode_1 = require("./RANode");
const Table_1 = require("./Table");
/**
 * relational algebra difference operator
 */
class Difference extends RANode_1.RANodeBinary {
    constructor(
    /** the left child expression */
    child, 
    /** the right child expression */
    child2) {
        super('-', child, child2);
        this._schema = null;
    }
    getSchema() {
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        return this._schema;
    }
    getResult(session) {
        session = this._returnOrCreateSession(session);
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        const res = new Table_1.Table();
        const orgA = this.getChild().getResult(session);
        const orgB = this.getChild2().getResult(session);
        res.setSchema(this._schema);
        // copy
        for (let i = 0; i < orgA.getNumRows(); i++) {
            const rowA = orgA.getRow(i);
            let notFound = true;
            for (let j = 0; j < orgB.getNumRows(); j++) {
                if (Table_1.Table.rowEqualsRow(rowA, orgB.getRow(j))) {
                    notFound = false;
                    break;
                }
            }
            if (notFound) {
                res.addRow(rowA);
            }
        }
        this.setResultNumRows(res.getNumRows());
        return res;
    }
    check() {
        this._child.check();
        this._child2.check();
        if (this._child.getSchema().equalsTypeOnly(this._child2.getSchema()) === false) {
            this.throwExecutionError(i18n.t('db.messages.exec.error-schemas-not-unifiable', {
                schemaA: this._child.getSchema(),
                schemaB: this._child2.getSchema(),
            }));
        }
        // schema of diff is the left schema
        this._schema = this._child.getSchema().copy();
    }
}
exports.Difference = Difference;

},{"./RANode":26,"./Table":32,"i18next":16}],20:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Division = void 0;
const Difference_1 = require("./Difference");
const CrossJoin_1 = require("./joins/CrossJoin");
const Projection_1 = require("./Projection");
const RANode_1 = require("./RANode");
/**
 * relational algebra division operator
 */
class Division extends RANode_1.RANodeBinary {
    constructor(child, child2) {
        super('', child, child2);
        // is set by check
        this._delegate = null;
    }
    getSchema() {
        if (this._delegate === null) {
            throw new Error(`check not called`);
        }
        return this._delegate.getSchema();
    }
    getResult(session) {
        session = this._returnOrCreateSession(session);
        if (this._delegate === null) {
            throw new Error(`check not called`);
        }
        const res = this._delegate.getResult(session);
        res.eliminateDuplicateRows();
        this.setResultNumRows(res.getNumRows());
        return res;
    }
    check() {
        this._child.check();
        this._child2.check();
        // schema r' is (sch(left) \ sch(right))
        const schemaA = this._child.getSchema();
        const schemaB = this._child2.getSchema();
        const numColsA = schemaA.getSize();
        const numColsB = schemaB.getSize();
        const schema = schemaA.copy();
        for (let i = 0; i < numColsB; i++) {
            const index = schema.getColumnIndex(schemaB.getColumn(i).getName(), null, false);
            if (index > -1) {
                schema.removeColumn(index);
            }
        }
        if (schema.getSize() === numColsA) { // size has not changed => schemaB not part of schemaA
            this.throwExecutionError(i18n.t('db.messages.exec.error-schema-a-not-part-of-schema-b', {
                schemaA: schemaB,
                schemaB: schemaA,
            }));
        }
        // (R % S) := (pi r'(R)) -  pi r'( ( (pi r'(R)) x (S) ) - (R) )
        this._delegate = new Difference_1.Difference(new Projection_1.Projection(this._child, schema.getColumns()).setCodeInfoObject(this._codeInfo), new Projection_1.Projection(new Difference_1.Difference(new CrossJoin_1.CrossJoin(new Projection_1.Projection(this._child, schema.getColumns()).setCodeInfoObject(this._codeInfo), this._child2).setCodeInfoObject(this._codeInfo), this._child).setCodeInfoObject(this._codeInfo), schema.getColumns()).setCodeInfoObject(this._codeInfo));
        this._delegate.check();
    }
}
exports.Division = Division;

},{"./Difference":19,"./Projection":25,"./RANode":26,"./joins/CrossJoin":36}],21:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionError = void 0;
class ExecutionError extends Error {
    constructor(message, codeInfo) {
        super(message);
        this.codeInfo = codeInfo || undefined;
    }
}
exports.ExecutionError = ExecutionError;

},{}],22:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupBy = void 0;
const i18n = require("i18next");
const Column_1 = require("./Column");
const RANode_1 = require("./RANode");
const Schema_1 = require("./Schema");
const Table_1 = require("./Table");
/**
 * relational algebra group-by operator
 *
 * @extends RANode
 * @constructor
 * @param   {RANode}  child              the child expression
 * @param   {Array}   groupByCols        Array of {name, relAlias} objects
 * @param   {Array}   aggregateFunctions Array of {aggFunction, col{name, relAlias}} objects
 * @returns {GroupBy}
 */
class GroupBy extends RANode_1.RANodeUnary {
    constructor(child, groupByCols, aggregateFunctions) {
        super('&gamma;', child);
        this.checked = null;
        this.groupByCols = groupByCols;
        this.aggregateFunctions = aggregateFunctions;
    }
    getSchema() {
        if (this.checked === null) {
            throw new Error(`check not called`);
        }
        return this.checked.schema;
    }
    check() {
        this._child.check();
        const childSchema = this._child.getSchema();
        const groupByColumnIndices = new Array(this.groupByCols.length);
        const aggregateFunctionsColIndex = Array(this.aggregateFunctions.length);
        for (let i = 0; i < this.groupByCols.length; i++) {
            groupByColumnIndices[i] = childSchema.getColumnIndex(this.groupByCols[i].name, this.groupByCols[i].relAlias);
        }
        for (let i = 0; i < this.aggregateFunctions.length; i++) {
            const f = this.aggregateFunctions[i];
            switch (f.aggFunction) {
                case 'COUNT_ALL':
                case 'COUNT':
                case 'SUM':
                case 'AVG':
                case 'MIN':
                case 'MAX':
                    break;
                default:
                    throw new Error('should not happen; unknown aggregate function');
            }
            if (f.aggFunction !== 'COUNT_ALL') {
                aggregateFunctionsColIndex[i] = childSchema.getColumnIndex(f.col.name, f.col.relAlias);
            }
        }
        // create new Schema
        const schema = new Schema_1.Schema();
        for (let i = 0; i < groupByColumnIndices.length; i++) {
            schema.addColumn2(childSchema.getColumn(groupByColumnIndices[i]));
        }
        for (let i = 0; i < this.aggregateFunctions.length; i++) {
            const func = this.aggregateFunctions[i];
            const colType = childSchema.getType(aggregateFunctionsColIndex[i]);
            let type;
            switch (func.aggFunction) {
                case 'MIN':
                case 'MAX':
                    type = colType;
                    break;
                case 'SUM':
                case 'AVG':
                    if (colType !== 'number') {
                        this.throwExecutionError(i18n.t('db.messages.exec.error-func-not-defined-for-column-type', {
                            func: func.aggFunction,
                            colType: colType,
                        }));
                    }
                    type = colType;
                    break;
                case 'COUNT_ALL':
                case 'COUNT':
                    type = 'number';
                    break;
                default:
                    throw new Error('unknown aggregate function ' + func.aggFunction);
            }
            schema.addColumn(func.name, null, type);
        }
        this.checked = {
            aggregateFunctionsColIndex,
            schema,
            groupByColumnIndices,
        };
    }
    getArgumentHtml() {
        const group = this.groupByCols.map(col => {
            return Column_1.Column.printColumn(col.name, col.relAlias);
        });
        const agg = this.aggregateFunctions.map(func => {
            const s = (func.aggFunction === 'COUNT_ALL'
                ? 'COUNT(*)'
                : `${func.aggFunction}(${Column_1.Column.printColumn(func.col.name, func.col.relAlias)})`);
            return `${s}${func.name}`;
        });
        return `${group.join(', ')}; ${agg.join(', ')}`;
    }
    getResult(session) {
        session = this._returnOrCreateSession(session);
        if (this.checked === null) {
            throw new Error(`check not called`);
        }
        const org = this.getChild().getResult(session);
        const res = new Table_1.Table();
        res.setSchema(this.checked.schema);
        const hasGroupCols = this.groupByCols.length > 0;
        let groupsOfRows; // might be sparsely filled
        let numberOfGroups = 0; // === number of rows in result table
        if (hasGroupCols) {
            const hashTable = {};
            for (let i = 0; i < org.getNumRows(); i++) {
                const row = org.getRow(i);
                const keyTuple = new Array(this.checked.groupByColumnIndices.length);
                for (let j = 0; j < this.checked.groupByColumnIndices.length; j++) {
                    keyTuple[j] = row[this.checked.groupByColumnIndices[j]];
                }
                const key = JSON.stringify(keyTuple);
                if (typeof (hashTable[key]) !== 'undefined') {
                    hashTable[key].rows.push(row);
                }
                else {
                    hashTable[key] = {
                        rows: [row],
                        resultTuple: keyTuple,
                        rownumber: i,
                    };
                    numberOfGroups++;
                }
            }
            groupsOfRows = new Array(org.getNumRows()); // sparsely filled
            // write hashtable into sparsely filled array to preserve ordering
            let entry;
            for (const key in hashTable) {
                if (!hashTable.hasOwnProperty(key)) {
                    continue;
                }
                entry = hashTable[key];
                groupsOfRows[entry.rownumber] = entry;
            }
        }
        else { // no grouping attributes => entire relation is one group
            numberOfGroups = 1;
            groupsOfRows = new Array(numberOfGroups);
            groupsOfRows[0] = {
                rows: org.getRows(),
                resultTuple: [],
            };
        }
        // min and max for strings, numbers and dates
        const genericMin = function (a, b) {
            if (a < b) {
                return a;
            }
            return b;
        };
        const genericMax = function (a, b) {
            if (a > b) {
                return a;
            }
            return b;
        };
        // execute aggregate functions
        let aggValue, group, value;
        let entry;
        for (let h = 0; h < groupsOfRows.length; h++) {
            if (!groupsOfRows[h]) {
                continue;
            } // skip unfilled rows
            entry = groupsOfRows[h];
            group = entry.rows;
            for (let i = 0; i < this.aggregateFunctions.length; i++) {
                const func = this.aggregateFunctions[i];
                const funcColIndex = this.checked.aggregateFunctionsColIndex[i];
                if (func.aggFunction === 'COUNT_ALL') {
                    aggValue = group.length;
                }
                else {
                    // var colType = this._child.getSchema().getType(func.colIndex);
                    switch (func.aggFunction) {
                        case 'COUNT':
                            aggValue = 0;
                            for (let j = 0; j < group.length; j++) {
                                value = group[j][funcColIndex];
                                if (value !== null) {
                                    aggValue++;
                                }
                            }
                            break;
                        case 'MIN':
                        case 'MAX':
                            aggValue = null;
                            const c = func.aggFunction === 'MIN' ? genericMin : genericMax;
                            for (let j = 0; j < group.length; j++) {
                                value = group[j][funcColIndex];
                                if (aggValue === null) {
                                    aggValue = value;
                                }
                                else {
                                    aggValue = c(aggValue, value);
                                }
                            }
                            break;
                        case 'AVG':
                        case 'SUM':
                            let sum = 0;
                            let counter = 0;
                            for (let j = 0; j < group.length; j++) {
                                value = group[j][funcColIndex];
                                if (value !== null) {
                                    sum += value;
                                    counter++;
                                }
                            }
                            if (counter === 0) {
                                aggValue = null;
                            }
                            else if (func.aggFunction === 'SUM') {
                                aggValue = sum;
                            }
                            else { // AVG
                                aggValue = sum / counter;
                            }
                            break;
                        default:
                            throw new Error('this should not happen');
                    }
                }
                entry.resultTuple.push(aggValue);
            }
        }
        // write into result-table
        for (let i = 0; i < groupsOfRows.length; i++) {
            if (!groupsOfRows[i]) {
                continue;
            }
            res.addRow(groupsOfRows[i].resultTuple);
        }
        res.eliminateDuplicateRows();
        this.setResultNumRows(res.getNumRows());
        return res;
    }
}
exports.GroupBy = GroupBy;

},{"./Column":18,"./RANode":26,"./Schema":30,"./Table":32,"i18next":16}],23:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Intersect = void 0;
const i18n = require("i18next");
const RANode_1 = require("./RANode");
const Table_1 = require("./Table");
/**
 * Calculates the intersection of two relations
 * The order of the rows is kept.
 * The output schema will be the schema of the left child
 */
class Intersect extends RANode_1.RANodeBinary {
    constructor(child, child2) {
        super('', child, child2);
        this._schema = null; // is set by check
    }
    getSchema() {
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        return this._schema;
    }
    getResult(session) {
        session = this._returnOrCreateSession(session);
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        const res = new Table_1.Table();
        const orgA = this.getChild().getResult(session);
        const orgB = this.getChild2().getResult(session);
        res.setSchema(this._schema);
        // copy
        const numRowsA = orgA.getNumRows();
        const numRowsB = orgB.getNumRows();
        const numCols = orgA.getNumCols();
        for (let i = 0; i < numRowsA; i++) {
            const rowA = orgA.getRow(i);
            for (let j = 0; j < numRowsB; j++) {
                const rowB = orgB.getRow(j);
                let equals = true;
                for (let k = 0; k < numCols; k++) {
                    if (rowA[k] !== rowB[k]) {
                        equals = false;
                        break;
                    }
                }
                if (equals) {
                    res.addRow(rowA);
                    break;
                }
            }
        }
        this.setResultNumRows(res.getNumRows());
        return res;
    }
    check() {
        this._child.check();
        this._child2.check();
        if (this._child.getSchema().equalsTypeOnly(this._child2.getSchema()) === false) {
            this.throwExecutionError(i18n.t('db.messages.exec.error-schemas-not-unifiable', {
                schemaA: this._child.getSchema(),
                schemaB: this._child2.getSchema(),
            }));
        }
        // schema is the left schema
        this._schema = this._child.getSchema().copy();
    }
}
exports.Intersect = Intersect;

},{"./RANode":26,"./Table":32,"i18next":16}],24:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderBy = void 0;
const RANode_1 = require("./RANode");
/**
 * relational algebra order-by operator
 *
 * @constructor
 * @extends RANode
 * @param   {RANode}  child     child expression
 * @param   {Array}   orderCols Array of Column
 * @param   {Array}   orderAsc  Array of Boolean indicating the sort direction (true == asc)
 * @returns {OrderBy}
 */
class OrderBy extends RANode_1.RANodeUnary {
    constructor(child, orderCols, orderAsc) {
        super('&tau;', child);
        this._orderCols = orderCols;
        this._orderAsc = orderAsc;
        if (this._orderAsc.length !== this._orderCols.length) {
            throw new Error('order cols not correct');
        }
        this._orderIndices = null; // set by check
    }
    getSchema() {
        return this._child.getSchema();
    }
    getResult(session) {
        session = this._returnOrCreateSession(session);
        if (this._orderIndices === null) {
            throw new Error(`check not called`);
        }
        const res = this.getChild().getResult(session).copy();
        res.eliminateDuplicateRows();
        this.setResultNumRows(res.getNumRows());
        res.sort(this._orderIndices, this._orderAsc);
        return res;
    }
    check() {
        this._child.check();
        const schema = this._child.getSchema();
        this._orderIndices = [];
        for (let i = 0; i < this._orderCols.length; i++) {
            const col = this._orderCols[i];
            const index = schema.getColumnIndex(col.getName(), col.getRelAlias());
            this._orderIndices.push(index);
        }
    }
    getArgumentHtml() {
        const list = [];
        for (let i = 0; i < this._orderCols.length; i++) {
            const s = `${this._orderCols[i].toString()} ${this._orderAsc[i] ? 'asc' : 'desc'}`;
            list.push(s);
        }
        return list.join(', ');
    }
}
exports.OrderBy = OrderBy;

},{"./RANode":26}],25:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Projection = void 0;
const i18n = require("i18next");
const Column_1 = require("./Column");
const ExecutionError_1 = require("./ExecutionError");
const RANode_1 = require("./RANode");
const Schema_1 = require("./Schema");
const Table_1 = require("./Table");
/**
 * relational algebra projection operator
 */
class Projection extends RANode_1.RANodeUnary {
    constructor(child, proj) {
        super('&pi;', child);
        this._checked = null;
        this._columns = proj;
    }
    getSchema() {
        if (this._columns === null) {
            // inherit schema on `select *`
            return this._child.getSchema();
        }
        if (this._checked === null) {
            throw new Error(`check has not been called`);
        }
        return this._checked._projectedSchema;
    }
    getResult(session) {
        session = this._returnOrCreateSession(session);
        if (this._checked === null) {
            throw new Error(`check has not been called`);
        }
        const { _indices } = this._checked;
        if (this._columns === null) {
            return this._child.getResult(session);
        }
        const org = this._child.getResult(session);
        const res = new Table_1.Table();
        res.setSchema(this.getSchema());
        const numCols = res.getNumCols();
        const numRows = org.getNumRows();
        let i, j, orgRow, resRow;
        for (i = 0; i < numRows; i++) {
            orgRow = org.getRow(i);
            resRow = new Array(numCols);
            for (j = 0; j < numCols; j++) {
                if (_indices[j] === -1) {
                    resRow[j] = this._columns[j].child.evaluate(orgRow, [], i, session);
                }
                else {
                    resRow[j] = orgRow[_indices[j]];
                }
            }
            res.addRow(resRow);
        }
        res.eliminateDuplicateRows();
        this.setResultNumRows(res.getNumRows());
        return res;
    }
    check() {
        this._child.check();
        // check if all parts are part of the schema
        const unProjectedSchema = this._child.getSchema();
        const childSchema = this._child.getSchema();
        const _indices = [];
        try {
            // handle if column name == X.* => replace entry in proj with real names
            for (let i = 0; i < this._columns.length; i++) {
                if (this._columns[i] instanceof Column_1.Column === false) {
                    continue;
                }
                const element = this._columns[i];
                const name = element.getName();
                const relAlias = element.getRelAlias();
                if (name !== '*') {
                    continue;
                }
                this._columns.splice(i, 1);
                let found = 0;
                for (let j = 0; j < childSchema.getSize(); j++) {
                    const col = childSchema.getColumn(j);
                    if (relAlias !== null && col.getRelAlias() !== relAlias) {
                        continue;
                    }
                    this._columns.splice(i + found, 0, col); // TODO: add {name, child, relalias}
                    found++;
                }
                if (found === 0) {
                    this.throwExecutionError(i18n.t('db.messages.exec.error-no-columns-match-alias-star'));
                }
            }
            // call check for all expressions
            for (let i = 0; i < this._columns.length; i++) {
                const element = this._columns[i];
                if (element instanceof Column_1.Column) {
                    continue;
                }
                element.child.check(unProjectedSchema);
                if (element.child.getDataType() === 'null') {
                    this.throwExecutionError(i18n.t('db.messages.exec.error-datatype-not-specified-for-col', {
                        index: (i + 1),
                        column: (element.child._codeInfo
                            ? element.child._codeInfo.text
                            : ''),
                    }));
                }
            }
            // search for indices with the names
            for (let i = 0; i < this._columns.length; i++) {
                let index;
                if (this._columns[i] instanceof Column_1.Column === false) {
                    index = -1;
                }
                else {
                    const element = this._columns[i];
                    const name = element.getName();
                    const relAlias = element.getRelAlias();
                    index = childSchema.getColumnIndex(name, relAlias);
                }
                _indices[i] = index;
            }
        }
        catch (e) {
            if (e instanceof ExecutionError_1.ExecutionError) {
                throw e;
            }
            else {
                this.throwExecutionError(i18n.t('db.messages.exec.error-invalid-projection-error', {
                    argument: this.getArgumentHtml(),
                    error: e.message,
                }));
            }
        }
        // create projected schema
        const projectedSchema = new Schema_1.Schema();
        for (let i = 0; i < _indices.length; i++) {
            const index = _indices[i];
            if (index === -1) {
                const col = this._columns[i];
                // dataType 'null' (unknown) has been checked before
                const dataType = col.child.getDataType();
                projectedSchema.addColumn(col.name, col.relAlias, dataType);
            }
            else {
                const col = unProjectedSchema.getColumn(index);
                const type = unProjectedSchema.getType(index);
                projectedSchema.addColumn(col.getName(), col.getRelAlias(), type);
            }
        }
        this._checked = {
            _indices,
            _projectedSchema: projectedSchema,
        };
    }
    getArgumentHtml() {
        const args = [];
        for (let i = 0; i < this._columns.length; i++) {
            const p = this._columns[i];
            if (p instanceof Column_1.Column) {
                args.push(p.toString());
            }
            else {
                let tmp = p.child.getFormulaHtml();
                tmp += '';
                tmp += p.relAlias === null ? '' : p.relAlias + '.';
                tmp += p.name;
                args.push(tmp);
            }
        }
        return args.join(', ');
    }
}
exports.Projection = Projection;

},{"./Column":18,"./ExecutionError":21,"./RANode":26,"./Schema":30,"./Table":32,"i18next":16}],26:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RANodeBinary = exports.RANodeUnary = exports.RANodeNullary = exports.RANode = void 0;
const ExecutionError_1 = require("./ExecutionError");
/**
 * the base class for all relational algebra operations
 *
 * the calculation of an expression must follow the following 3 steps:
 * - the instances of the operators get plugged together building a operator tree
 *   at this stage no checking is done
 * - the `check()` function  is called recursively to check the correct nesting
 *   of the expressions like schema compability or existence of columns
 *   used in an projection
 *   The `check()` function also calculates the output schema for the specific
 *   operator.
 * - after check has been called the actual result is calculated when `getResult()` is called
 *   the results are not cached and return a new of Table that is independant of the results
 *   of their operands
 *   the session object is created automatically at the root of the tree
 * @constructor
 * @abstract
 * @returns {RANode} this is an abstract class
 */
class RANode {
    constructor(functionName = '') {
        this._codeInfo = null;
        this._metaData = {};
        this._resultNumRows = -1;
        this._wrappedInParentheses = false;
        this._warnings = [];
        this._functionName = functionName;
    }
    setCodeInfoObject(codeInfo) {
        this._codeInfo = codeInfo;
        return this;
    }
    addWarning(msg, codeInfo) {
        const w = {
            message: msg,
            codeInfo: undefined,
        };
        if (codeInfo) {
            w.codeInfo = codeInfo;
        }
        if (!this._warnings) {
            this._warnings = [];
        }
        this._warnings.push(w);
    }
    setWrappedInParentheses(wrappedInBrackets = true) {
        this._wrappedInParentheses = wrappedInBrackets;
    }
    throwExecutionError(message) {
        throw new ExecutionError_1.ExecutionError(message, this._codeInfo);
    }
    setMetaData(key, value) {
        this._metaData[key] = value;
    }
    hasMetaData(key) {
        return typeof this._metaData[key] !== 'undefined';
    }
    getMetaData(key) {
        return this._metaData[key];
    }
    getResultNumRows() {
        if (typeof (this._resultNumRows) === 'undefined' || this._resultNumRows === -1) {
            throw new Error('result num rows not set! call only after getResult');
        }
        return this._resultNumRows;
    }
    setResultNumRows(num) {
        this._resultNumRows = num;
    }
    /**
     * this method is called in every getResult() method
     *
     * this is actually a hack due to the lack of a statement object
     * there is no place to store data that can be used
     * by all operators
     *
     * the method will create a new session when called with undefined
     * or just returns the argument
     *
     * @param   {Object} session the already initialized session object or undefined
     * @returns {Object} [[Description]]
     */
    _returnOrCreateSession(session) {
        if (session === undefined) {
            // create a new session
            return {
                statement_timestamp: new Date(),
            };
        }
        else {
            return session;
        }
    }
    getArgumentHtml() {
        return '';
    }
    static foreachRecursive(node, func) {
        func(node);
        if (node instanceof RANodeUnary) {
            func(node.getChild());
        }
        else if (node instanceof RANodeBinary) {
            func(node.getChild());
            func(node.getChild2());
        }
    }
}
exports.RANode = RANode;
class RANodeNullary extends RANode {
    getWarnings(recursive) {
        return this._warnings;
    }
    getFormulaHtml(printChildren = true, isChildElement = true) {
        const wrap = this._wrappedInParentheses === true && isChildElement === true;
        return (`${wrap ? '(' : ''}
				<span>
					<span class="math">${this._functionName}</span>
				</span>
			${wrap ? ')' : ''}`);
    }
}
exports.RANodeNullary = RANodeNullary;
class RANodeUnary extends RANode {
    constructor(functionName, child) {
        super(functionName);
        this._child = child;
    }
    getChild() {
        return this._child;
    }
    getWarnings(recursive) {
        if (recursive === true) {
            return [...this._warnings, ...this.getChild().getWarnings(true)];
        }
        else {
            return [...this._warnings];
        }
    }
    getFormulaHtml(printChildren = true, isChildElement = true) {
        const wrap = this._wrappedInParentheses === true && isChildElement === true;
        return (`${wrap ? '(' : ''}

				<span>
					<span class="math">${this._functionName}</span>
					<sub>${this.getArgumentHtml()}</sub>
					${printChildren === true ? this.getChild().getFormulaHtml(printChildren, true) : ''}
				</span>
			${wrap ? ')' : ''}`);
    }
}
exports.RANodeUnary = RANodeUnary;
class RANodeBinary extends RANode {
    constructor(functionName, child, child2) {
        super(functionName);
        this._child = child;
        this._child2 = child2;
    }
    getChild() {
        return this._child;
    }
    getChild2() {
        return this._child2;
    }
    getWarnings(recursive) {
        if (recursive === true) {
            return [
                ...this._warnings,
                ...this.getChild().getWarnings(true),
                ...this.getChild2().getWarnings(true),
            ];
        }
        else {
            return [...this._warnings];
        }
    }
    getFormulaHtml(printChildren = true, isChildElement = true) {
        const wrap = this._wrappedInParentheses === true || isChildElement === true;
        return (`${wrap ? '(' : ''}

				<span>
					${printChildren === true ? this.getChild().getFormulaHtml(printChildren, true) : ''}
					<span class="math">${this._functionName}</span>
					<sub>${this.getArgumentHtml()}</sub>
					${printChildren === true ? this.getChild2().getFormulaHtml(printChildren, true) : ''}
				</span>
			${wrap ? ')' : ''}`);
    }
}
exports.RANodeBinary = RANodeBinary;

},{"./ExecutionError":21}],27:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Relation = void 0;
const RANode_1 = require("./RANode");
const Table_1 = require("./Table");
/**
 * the base of all relational algebra statements
 */
class Relation extends RANode_1.RANodeNullary {
    constructor(
    /** the name of the relation */
    functionName, 
    /** relation is filled by evaluating the node */
    content) {
        super(functionName);
        this._schema = null;
        if (content === undefined) {
            this._table = new Table_1.Table();
        }
        else {
            content.check();
            this._schema = content.getSchema();
            this._table = content.getResult();
        }
    }
    setSchema(schema, doNotSetRelAlias = false) {
        this._schema = schema.copy();
        if (doNotSetRelAlias !== true) {
            this._schema.setRelAlias(this._functionName);
        }
        this._table.setSchema(this._schema);
        return this;
    }
    addRow(arr) {
        this._table.addRow(arr);
    }
    addRows(arr) {
        this._table.addRows(arr);
    }
    getResultNumRows() {
        return this._resultNumRows;
    }
    getResult(session) {
        this._returnOrCreateSession(session);
        const res = this._table.copy();
        res.eliminateDuplicateRows();
        this.setResultNumRows(res.getNumRows());
        return res;
    }
    getSchema() {
        return this._table.getSchema();
    }
    getName() {
        return this._functionName;
    }
    check() {
        // noop
    }
    hasChild() {
        return false;
    }
    copy() {
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        const c = new Relation(this._functionName);
        c.setSchema(this._schema);
        c._table = this._table.copy();
        return c;
    }
}
exports.Relation = Relation;

},{"./RANode":26,"./Table":32}],28:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenameColumns = void 0;
const i18n = require("i18next");
const Column_1 = require("./Column");
const RANode_1 = require("./RANode");
const Schema_1 = require("./Schema");
/**
 * relational algebra anti-join operator
 *
 * the columns that should be renamed are added via `addRenaming()`
 */
class RenameColumns extends RANode_1.RANodeUnary {
    constructor(child) {
        super('&rho;', child);
        this._renameList = [];
        this._schema = null;
    }
    getSchema() {
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        return this._schema;
    }
    addRenaming(newName, oldName, oldRelAlias) {
        this._renameList.push({
            newName: newName,
            oldName: oldName,
            oldRelAlias: oldRelAlias,
        });
    }
    check() {
        this._child.check();
        const schemaA = this._child.getSchema().copy();
        const schema = new Schema_1.Schema();
        const list = this._renameList;
        // check the rename list
        for (let i = 0; i < list.length; i++) {
            if (schemaA.getColumnIndex(list[i].oldName, list[i].oldRelAlias, false) === -1) {
                this.throwExecutionError(i18n.t('db.messages.exec.error-column-not-found-name', {
                    column: Column_1.Column.printColumn(list[i].oldName, list[i].oldRelAlias),
                    schema: schemaA.toString(),
                }));
            }
        }
        // create the new schema
        for (let i = 0; i < schemaA.getSize(); i++) {
            const oldColumn = schemaA.getColumn(i);
            let columnRenamed = false;
            for (let j = 0; j < list.length; j++) {
                const e = list[j];
                if (e.oldName === oldColumn.getName() && (e.oldRelAlias === null || e.oldRelAlias === oldColumn.getRelAlias())) {
                    // add column with new name
                    schema.addColumn(e.newName, oldColumn.getRelAlias(), oldColumn.getType());
                    columnRenamed = true;
                    break;
                }
            }
            if (columnRenamed) {
                continue;
            }
            // add the not renamed column with its original
            schema.addColumn2(schemaA.getColumn(i));
        }
        this._schema = schema;
    }
    getResult(session) {
        session = this._returnOrCreateSession(session);
        const res = this._child.getResult(session).copy();
        res.setSchema(this.getSchema());
        this.setResultNumRows(res.getNumRows());
        return res;
    }
    getArgumentHtml() {
        const out = [];
        const list = this._renameList;
        for (let i = 0; i < list.length; i++) {
            const e = list[i];
            out.push(`${e.newName}${Column_1.Column.printColumn(e.oldName, e.oldRelAlias)}`);
        }
        return out.join(', ');
    }
}
exports.RenameColumns = RenameColumns;

},{"./Column":18,"./RANode":26,"./Schema":30,"i18next":16}],29:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenameRelation = void 0;
const RANode_1 = require("./RANode");
/**
 * relational algebra anti-join operator
 *
 * @extends RANode
 * @constructor
 * @param   {RANode}         child           the left child expression
 * @param {String} new alias for the relation as String
 * @returns {RenameRelation}
 */
class RenameRelation extends RANode_1.RANodeUnary {
    constructor(child, newRelAlias) {
        super('&rho;', child);
        this._schema = null;
        this._newRelAlias = newRelAlias;
    }
    getSchema() {
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        return this._schema;
    }
    check() {
        this._child.check();
        try {
            this._schema = this._child.getSchema().copy();
            this._schema.setRelAlias(this._newRelAlias);
        }
        catch (e) {
            this.throwExecutionError(e.message);
        }
    }
    getResult(session) {
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        const res = this._child.getResult(session).copy();
        res.setSchema(this.getSchema());
        this.setResultNumRows(res.getNumRows());
        return res;
    }
    getArgumentHtml() {
        return this._newRelAlias;
    }
}
exports.RenameRelation = RenameRelation;

},{"./RANode":26}],30:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schema = void 0;
const i18n = require("i18next");
const Column_1 = require("./Column");
/**
 * the schema of a relation
 */
class Schema {
    constructor() {
        this._names = [];
        this._relAliases = [];
        this._types = [];
        this._size = 0;
        /** key: name, value: [] of columns */
        this._colIndexPerName = {};
    }
    getSize() {
        return this._size;
    }
    addColumn(name, relAlias, type) {
        if (!(type === 'string' || type === 'date' || type === 'number' || type === 'boolean')) {
            throw new Error('unknown type! ' + type);
        }
        this._names.push(name);
        this._relAliases.push(relAlias);
        this._types.push(type);
        const index = this._size;
        if (this.isUnique(index) === false) {
            throw new Error(i18n.t('db.messages.exec.error-column-not-unique', { column: relAlias + '.' + name }));
        }
        // names
        this._addColToIndex(name, index);
        this._size++;
        return this;
    }
    addColumn2(column) {
        return this.addColumn(column.getName(), column.getRelAlias(), column.getType());
    }
    _addColToIndex(name, index) {
        if (typeof (this._colIndexPerName[name]) === 'undefined') {
            this._colIndexPerName[name] = [index];
        }
        else {
            this._colIndexPerName[name].push(index);
        }
    }
    _removeColFromIndex(index) {
        const name = this._names[index];
        const indices = this._colIndexPerName[name];
        indices.splice(indices.indexOf(index, 0), 1);
        if (indices.length === 0) {
            delete this._colIndexPerName[name];
        }
    }
    removeColumn(index) {
        this._names.splice(index, 1);
        this._relAliases.splice(index, 1);
        this._types.splice(index, 1);
        this._size--;
        // update names because index is 1 lower at all following columns
        for (let i = index; i < this._size; i++) {
            const name = this._names[i];
            const indices = this._colIndexPerName[name];
            for (let j = 0; j < indices.length; j++) {
                indices[j] -= 1;
            }
        }
    }
    copy() {
        const res = new Schema();
        for (let i = 0; i < this._size; i++) {
            res.addColumn(this._names[i], this._relAliases[i], this._types[i]);
        }
        return res;
    }
    isUnique(index) {
        for (let j = 0; j < this._size; j++) {
            if (index === j) {
                continue;
            }
            if (this._names[index] === this._names[j] && this._relAliases[index] === this._relAliases[j]) {
                return false;
            }
        }
        return true;
    }
    getColumn(index) {
        return new Column_1.Column(this._names[index], this._relAliases[index], this._types[index]);
    }
    getColumns() {
        const a = [];
        for (let i = 0; i < this._size; i++) {
            a.push(this.getColumn(i));
        }
        return a;
    }
    getColumnIndex(name, relAlias, throwsExceptions = true) {
        const indices = this.getColumnIndexArray(name, relAlias);
        if (indices.length === 0) {
            if (throwsExceptions) {
                const error = 'db.messages.exec.error-column-not-found-' + (typeof (name) === 'string' ? 'name' : 'index');
                throw new Error(i18n.t(error, { column: Column_1.Column.printColumn(name, relAlias), schema: this.toString() }));
            }
            else {
                return -1;
            }
        }
        else if (indices.length === 1) {
            return indices[0];
        }
        else {
            throw new Error(i18n.t('db.messages.exec.error-column-ambiguous', {
                column: Column_1.Column.printColumn(name, relAlias),
                schema: this.toString(),
            }));
        }
    }
    /**
     * returns an array of Columns that appear in both
     * schemas (fully qualified)
     * @param {Schema} schemaB the other schema
     * @returns {Column[]} array of Column objects
     */
    getConflictingColumnsArray(schemaB) {
        const conflicts = [];
        for (let i = 0; i < this._size; i++) {
            const index = schemaB.getColumnIndex(this._names[i], this._relAliases[i], false);
            if (index !== -1) {
                conflicts.push(this.getColumn(i));
            }
        }
        return conflicts;
    }
    getColumnIndexArray(name, relAlias) {
        let index;
        if (typeof (name) === 'string') {
            const indices = this._colIndexPerName[name];
            if (typeof (indices) === 'undefined' || indices === null) {
                return [];
            }
            if (relAlias === null) {
                return indices; // contains all indices of columns with the given name
            }
            // check relAlias for all columns with the same name
            for (let i = 0; i < indices.length; i++) {
                index = indices[i];
                if (this._relAliases[index] === relAlias) {
                    return [index]; // found full qualified name; must be unique => only hit
                }
            }
        }
        else { // name is the column index (starting at 1)!!
            index = name - 1;
            if (name < 1 || name > this._size) {
                throw new Error(i18n.t('db.messages.exec.error-column-index-out-of-range', {
                    column: Column_1.Column.printColumn(name, relAlias),
                    schema: this.toString(),
                }));
            }
            if (relAlias === null) {
                return [index];
            }
            // check if column has the given relAlias
            if (this._relAliases[index] === relAlias) {
                return [index];
            }
        }
        return [];
    }
    getType(index) {
        return this._types[index];
    }
    equals(schemaB) {
        if (this.equalsTypeOnly(schemaB) === false) {
            return false;
        }
        for (let i = 0; i < this._size; i++) {
            if (this._names[i] !== schemaB._names[i] || this._relAliases[i] !== schemaB._relAliases[i]) {
                return false;
            }
        }
        return true;
    }
    equalsTypeOnly(schemaB) {
        if (this._size !== schemaB._size) {
            return false;
        }
        for (let i = 0; i < this._size; i++) {
            if (this._types[i] !== schemaB._types[i]) {
                return false;
            }
        }
        return true;
    }
    // no index => all
    setRelAlias(relAlias, index) {
        const setRelAliasAtIndex = function (schema, relAlias, index) {
            schema._relAliases[index] = relAlias;
            if (schema.isUnique(index) === false) {
                throw new Error(i18n.t('db.messages.exec.error-could-not-change-rel-alias-ambiguity', { alias: relAlias }));
            }
        };
        if (typeof index === 'undefined') {
            // set all relAliases
            for (let i = 0; i < this._size; i++) {
                setRelAliasAtIndex(this, relAlias, i);
            }
        }
        else {
            setRelAliasAtIndex(this, relAlias, index);
        }
    }
    setName(newName, index) {
        const oldName = this._names[index];
        // update index
        this._removeColFromIndex(index);
        this._addColToIndex(newName, index);
        this._names[index] = newName;
        if (this.isUnique(index) === false) {
            throw new Error(i18n.t('db.messages.exec.error-could-not-change-rel-alias-ambiguity', {
                newName: newName,
                oldName: oldName,
                schema: this.toString(),
            }));
        }
    }
    needsFullName(index) {
        return this._colIndexPerName[this._names[index]].length > 1;
    }
    getName(index) {
        return this._names[index];
    }
    getFullName(index) {
        return (this._relAliases[index] ? this._relAliases[index] + '.' : '') + this._names[index];
    }
    toString() {
        const list = [];
        for (let i = 0; i < this._size; i++) {
            const c = this.getColumn(i);
            const type = this.getType(i);
            const name = c.toString();
            list.push(`${name} : ${type}`);
        }
        return `[${list.join(', ')}]`;
    }
    /**
     * concatenates the two given schemas
     * @param   {Schema} schemaA a Schema
     * @param   {Schema} schemaB a Schema
     * @returns {Schema} concatenated schema
     */
    static concat(schemaA, schemaB) {
        const schema = schemaA.copy();
        const numColsB = schemaB.getSize();
        for (let i = 0; i < numColsB; i++) {
            const col = schemaB.getColumn(i);
            const type = schemaB.getType(i);
            schema.addColumn(col.getName(), col.getRelAlias(), type);
        }
        return schema;
    }
    /**
     * concatenates the two given schemas like required by a natural join
     */
    static concatNatural(
    /** the first Schema */
    schemaA, 
    /** the second Schema */
    schemaB, 
    /** wether the columns of the left (true)
     * or the right (false) schema should be kept if they have the same name
     */
    keepColsFromSchemaA = true, 
    /**
     * optional argument to indicate that only the columns
     * with names listed in the Array of Strings should
     * be considered for the equality search.
     * This is used for the USING() clause in SQL that is
     * actually a restricted version of a natural join
     */
    restrictToColumns = null) {
        const sizeA = schemaA.getSize();
        const sizeB = schemaB.getSize();
        const work = {
            keepA: new Array(sizeA),
            keepB: new Array(sizeB),
            size: -1,
            keepIndicesA: [],
            keepIndicesB: [],
        };
        let i, j;
        // init
        for (i = 0; i < sizeA; i++) {
            work.keepA[i] = true;
        }
        for (i = 0; i < sizeB; i++) {
            work.keepB[i] = true;
        }
        // find columns with the same name in schemaA and schemaB
        for (i = 0; i < sizeA; i++) {
            const candidate = schemaA.getColumn(i);
            if (restrictToColumns !== null && restrictToColumns.indexOf(candidate.getName() + '') === -1) {
                // skip column if it is not in the restriction set
                continue;
            }
            const colIndicesInA = schemaA.getColumnIndexArray(candidate.getName(), null);
            const colIndicesInB = schemaB.getColumnIndexArray(candidate.getName(), null);
            if (colIndicesInA.length === 0 || colIndicesInB.length === 0) {
                continue;
            }
            if (keepColsFromSchemaA) {
                // keep the all columns (with this name) in A and none (with this name) in B
                for (j = 0; j < colIndicesInB.length; j++) {
                    work.keepB[colIndicesInB[j]] = false;
                }
            }
            else {
                // keep the all columns (with this name) in B and none (with this name) in A
                for (j = 0; j < colIndicesInA.length; j++) {
                    work.keepA[colIndicesInA[j]] = false;
                }
            }
        }
        // generate concatenated schema from work-information
        const schema = new Schema();
        let col;
        for (i = 0; i < sizeA; i++) {
            if (work.keepA[i] === false) {
                continue;
            }
            col = schemaA.getColumn(i);
            schema.addColumn(col.getName(), col.getRelAlias(), schemaA.getType(i));
        }
        for (i = 0; i < sizeB; i++) {
            if (work.keepB[i] === false) {
                continue;
            }
            col = schemaB.getColumn(i);
            schema.addColumn(col.getName(), col.getRelAlias(), schemaB.getType(i));
        }
        work.size = schema.getSize();
        // create arrays with the indices we want to keep
        for (i = 0; i < sizeA; i++) {
            if (work.keepA[i] === false) {
                continue;
            }
            work.keepIndicesA.push(i);
        }
        for (i = 0; i < sizeB; i++) {
            if (work.keepB[i] === false) {
                continue;
            }
            work.keepIndicesB.push(i);
        }
        return {
            keep: work,
            schema: schema,
        };
    }
}
exports.Schema = Schema;

},{"./Column":18,"i18next":16}],31:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Selection = void 0;
const i18n = require("i18next");
const RANode_1 = require("./RANode");
const Table_1 = require("./Table");
const ValueExpr = require("./ValueExpr");
class Selection extends RANode_1.RANodeUnary {
    constructor(child, condition) {
        super('&sigma;', child);
        this._schema = null;
        this._condition = condition;
        if (condition instanceof ValueExpr.ValueExpr === false) {
            throw new Error('no condition given');
        }
    }
    getSchema() {
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        return this._schema;
    }
    getResult(session) {
        session = this._returnOrCreateSession(session);
        const res = new Table_1.Table();
        const org = this.getChild().getResult(session);
        res.setSchema(org.getSchema());
        // copy
        const condition = this._condition;
        const numRows = org.getNumRows();
        for (let i = 0; i < numRows; i++) {
            const row = org.getRow(i);
            if (condition.evaluate(row, [], i, session) === true) {
                res.addRow(row);
            }
        }
        this.setResultNumRows(res.getNumRows());
        return res;
    }
    check() {
        this._child.check();
        // schema of union is the left schema
        this._schema = this._child.getSchema();
        this._condition.check(this._schema);
        if (this._condition.getDataType() !== 'boolean') {
            this.throwExecutionError(i18n.t('db.messages.exec.error-condition-must-be-boolean'));
        }
    }
    getArgumentHtml() {
        return this._condition.getFormulaHtml();
    }
}
exports.Selection = Selection;

},{"./RANode":26,"./Table":32,"./ValueExpr":34,"i18next":16}],32:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Table = void 0;
const ValueExpr_1 = require("./ValueExpr");
const Relation_1 = require("./Relation");
const Schema_1 = require("./Schema");
class Table {
    constructor() {
        this._rows = [];
        this._schema = new Schema_1.Schema();
    }
    static rowEqualsRow(rowA, rowB) {
        if (rowA.length !== rowB.length) {
            return false;
        }
        for (let i = 0; i < rowA.length; i++) {
            if (rowA[i] !== rowB[i]) {
                return false;
            }
        }
        return true;
    }
    addRow(dataArray) {
        this._rows.push(dataArray);
    }
    addRows(rows) {
        for (let i = 0; i < rows.length; i++) {
            this.addRow(rows[i]);
        }
    }
    setSchema(schema) {
        if (schema instanceof Schema_1.Schema === false) {
            throw new Error('illegal argument: no schema');
        }
        this._schema = schema;
        return this;
    }
    getSchema() {
        return this._schema;
    }
    getRow(i) {
        return this._rows[i];
    }
    getNumRows() {
        return this._rows.length;
    }
    getNumCols() {
        return this._schema.getSize();
    }
    getValueHtmlAt(row, col) {
        const value = this._rows[row][col];
        const type = this._schema.getType(col);
        const text = (0, ValueExpr_1.printValue)(value, type);
        return '<span class="' + (value === null ? 'null ' + type : type) + '">' + text + '</span>';
    }
    getRows(offset = 0, maxRows) {
        if (offset === 0 && maxRows === undefined) {
            return this._rows;
        }
        else {
            const numRows = this._rows.length;
            let end = numRows;
            if (maxRows && maxRows > 0) {
                end = Math.min(numRows, offset + maxRows);
            }
            this._rows.slice(offset, end);
            const rows = [];
            for (let i = offset; i < end; i++) {
                rows.push(this._rows[i]);
            }
            return rows;
        }
    }
    getHtml(unqualifiedColumnNames = false, maxRows = -1, offset = 0) {
        const numCols = this.getNumCols();
        let thead = '<thead><tr>';
        for (let i = 0; i < numCols; i++) {
            const c = this._schema.getColumn(i);
            if (unqualifiedColumnNames) {
                thead += '<th>' + c.getName() + '</th>';
            }
            else {
                thead += '<th>' + c.toString() + '</th>';
            }
        }
        thead += '</tr></thead>';
        let tbody = '<tbody>';
        const numRows = this.getNumRows();
        let end = numRows;
        if (maxRows && maxRows > 0) {
            end = Math.min(numRows, offset + maxRows);
        }
        for (let i = offset; i < end; i++) {
            let tr = '<tr>';
            for (let j = 0; j < numCols; j++) {
                tr += '<td>' + this.getValueHtmlAt(i, j) + '</td>';
            }
            tbody += tr + '</tr>';
        }
        return '<table>' + thead + tbody + '</table>';
    }
    equals(table) {
        if (table instanceof Table === false) {
            throw new Error('can not compare');
        }
        // compare schema
        if (this._schema.equals(table._schema) === false) {
            return false;
        }
        // compare rows
        if (this._rows.length !== table._rows.length) {
            return false;
        }
        for (let i = 0; i < this._rows.length; i++) {
            if (Table.rowEqualsRow(this._rows[i], table._rows[i]) === false) {
                return false;
            }
        }
        return true;
    }
    eliminateDuplicateRows() {
        const uniqueRows = new Map();
        for (let i = 0; i < this._rows.length; i++) {
            const key = JSON.stringify(this._rows[i]);
            if (uniqueRows.has(key) === false) {
                uniqueRows.set(key, this._rows[i]);
            }
        }
        this._rows = [];
        for (const value of uniqueRows.values()) {
            this._rows.push(value);
        }
    }
    sort(sortByColumnIndicesArg, sortAscendingArg) {
        const size = this.getNumCols();
        // initialize
        const sortByColumnIndices = sortByColumnIndicesArg || [];
        if (sortByColumnIndicesArg === undefined) {
            for (let i = 0; i < size; i++) {
                sortByColumnIndices[i] = i;
            }
        }
        const sortAscending = sortAscendingArg || [];
        if (sortAscendingArg === undefined) {
            for (let i = 0; i < sortByColumnIndices.length; i++) {
                sortAscending[i] = true;
            }
        }
        // check indices
        if (sortByColumnIndices.length > size) {
            throw new Error('invalid sort cols');
        }
        for (let i = 0; i < sortByColumnIndices.length; i++) {
            if (sortByColumnIndices[i] >= size || sortByColumnIndices[i] < 0) {
                throw new Error('invalid sort cols');
            }
        }
        // check sort order array
        const sortByColumnIndicesLength = sortByColumnIndices.length;
        if (sortByColumnIndicesLength !== sortAscending.length) {
            throw new Error('invalid sort cols');
        }
        const sortByColumnIndicesTypes = sortByColumnIndices.map(index => this._schema.getType(index));
        const compare = function (rowA, rowB, col, mul, type) {
            const o1 = rowA[col];
            const o2 = rowB[col];
            if (o1 === null && o2 === null) {
                return 0;
            }
            else if (o1 === null && o2 !== null) {
                return mul * 1;
            }
            else if (o1 !== null && o2 === null) {
                return mul * -1;
            }
            switch (type) {
                case 'number':
                case 'date':
                case 'boolean':
                    return mul * (o1 - o2);
                case 'string':
                    return mul * (o1.localeCompare(o2));
                case 'null':
                    return 0;
            }
        };
        const compareAll = function (rowA, rowB) {
            let last = 0;
            for (let i = 0; i < sortByColumnIndicesLength; i++) {
                const mul = sortAscending[i] ? 1 : -1;
                const col = sortByColumnIndices[i];
                const type = sortByColumnIndicesTypes[i];
                last = compare(rowA, rowB, col, mul, type);
                if (last === 0) {
                    continue;
                }
                return last;
            }
            return last;
        };
        this._rows.sort(compareAll);
    }
    copy() {
        const res = new Table();
        res.setSchema(this.getSchema().copy());
        res.addRows(this.getRows());
        return res;
    }
    createRelation(name) {
        const relation = new Relation_1.Relation(name);
        relation.setSchema(this.getSchema().copy());
        relation.addRows(this.getRows());
        return relation;
    }
}
exports.Table = Table;

},{"./Relation":27,"./Schema":30,"./ValueExpr":34}],33:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Union = void 0;
const i18n = require("i18next");
const RANode_1 = require("./RANode");
const Table_1 = require("./Table");
/**
 * This is the Union operation
 * The two child expression must have a union compatible schema.
 * The schema of the left child is used as the output schema.
 *
 * Union is done by concatenating the two results (left||right)
 */
class Union extends RANode_1.RANodeBinary {
    constructor(child, child2) {
        super('', child, child2);
        this._schema = null;
        this._schema = null; // is set by check
    }
    getSchema() {
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        return this._schema;
    }
    getResult(session) {
        session = this._returnOrCreateSession(session);
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        const res = new Table_1.Table();
        const orgA = this.getChild().getResult(session);
        const orgB = this.getChild2().getResult(session);
        res.setSchema(this._schema);
        // copy
        res.addRows(orgA.getRows());
        res.addRows(orgB.getRows());
        res.eliminateDuplicateRows();
        this.setResultNumRows(res.getNumRows());
        return res;
    }
    check() {
        this._child.check();
        this._child2.check();
        if (this._child.getSchema().equalsTypeOnly(this._child2.getSchema()) === false) {
            this.throwExecutionError(i18n.t('db.messages.exec.error-schemas-not-unifiable', {
                schemaA: this._child.getSchema(),
                schemaB: this._child2.getSchema(),
            }));
        }
        // schema of union is the left schema
        this._schema = this._child.getSchema().copy();
    }
}
exports.Union = Union;

},{"./RANode":26,"./Table":32,"i18next":16}],34:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueExprGeneric = exports.ValueExprColumnValue = exports.ValueExpr = exports.printValue = void 0;
const ExecutionError_1 = require("./ExecutionError");
const Column_1 = require("./Column");
const i18n = require("i18next");
function isDate(value, type) {
    return type === 'date';
}
function isNumber(value, type) {
    return type === 'date';
}
function isString(value, type) {
    return type === 'date';
}
function isBoolean(value, type) {
    return type === 'date';
}
const MILLI_SEC_PER_DAY = 24 * 3600 * 1000;
/**
 * RegExp.escape
 * src: https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js
 *
 * @param s
 * @returns {string}
 */
function regExpEscape(s) {
    return String(s).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
}
function printValue(val, type) {
    if (val === null) {
        return 'null';
    }
    switch (type) {
        case 'number':
            return val;
        case 'string':
            return `'${val}'`;
        case 'date': {
            const v = val;
            const year = v.getFullYear();
            const month = (v.getMonth() + 1 < 10 ? '0' + (v.getMonth() + 1) : (v.getMonth() + 1));
            const day = (v.getDate() < 10 ? '0' + v.getDate() : v.getDate());
            return `${year}-${month}-${day}`;
        }
        case 'null':
            return 'null';
        case 'boolean':
            return val ? 'true' : 'false';
        default:
            throw new Error('unknown type ' + type);
    }
}
exports.printValue = printValue;
/**
 * the base class for all valueExpressions
 *
 * the calculation of an expression must follow the following 3 steps:
 * - the instances of the operators get plugged together building a operator tree
 *   at this stage no checking is done
 * - the `check()` function  is called recursively to check the correct nesting
 *   of the expressions like schema compatibility or existence of columns
 *   used in an projection
 *   The `check()` function also calculates the output schema for the specific
 *   operator.
 * - after check has been called the actual result is calculated when `evaluate()` is called
 * @constructor
 * @returns {ValueExpr}
 * @abstract
 */
class ValueExpr {
    constructor() {
        this.func = null;
        this.dataType = null;
        this._wrappedInParentheses = false;
        this._codeInfo = null;
    }
    setCodeInfoObject(codeInfo) {
        this._codeInfo = codeInfo;
        return this;
    }
    throwExecutionError(message) {
        throw new ExecutionError_1.ExecutionError(message, this._codeInfo);
    }
    /**
     * sets the indicator wether the expression was wrapped in parentheses in the code
     * this is used for getFormulaHtml because at this stage there is no more information
     * about the precedence of the operators and how the expression was created
     * @param {Boolean} wrappedInParentheses true when this (sub) expression was wrapped in parentheses
     */
    setWrappedInParentheses(wrappedInParentheses) {
        this._wrappedInParentheses = wrappedInParentheses;
    }
}
exports.ValueExpr = ValueExpr;
/**
 * value expression with no predefined datatype
 * @constructor
 * @param {String}               name                   the name of a column
 * @param {String}               relAlias               the relation alias of the column
 * @param {Number}               manuallySetColumnIndex the index of the column described; this allows
 *                                                      to set the index within a schema because sometimes
 *                                                      it can not be determined by the check function
 * @returns {ValueExprColumnValue}
 */
class ValueExprColumnValue extends ValueExpr {
    constructor(name, relAlias, manuallySetColumnIndex) {
        super();
        this._index = null;
        this._type = null;
        this._name = name;
        this._relAlias = relAlias;
        this._index = null;
        if (typeof manuallySetColumnIndex !== 'undefined') {
            this._index = manuallySetColumnIndex;
        }
    }
    getDataType() {
        if (this._type === null) {
            throw new Error(`type should have been set by check`);
        }
        return this._type;
    }
    check(schemaA, schemaB) {
        if (this._index === null) {
            // the index has not been set manually
            this._index = ValueExprColumnValue._getColumnIndex(schemaA, schemaB, this._name, this._relAlias);
        }
        this._type = ValueExprColumnValue._getType(schemaA, schemaB, this._index);
    }
    evaluate(tupleA, tupleB, row, statementSession) {
        if (this._index === null) {
            throw new Error(`index should have been set by check`);
        }
        if (this._index >= tupleA.length) {
            return tupleB[this._index - tupleA.length];
        }
        return tupleA[this._index];
    }
    toString() {
        return Column_1.Column.printColumn(this._name, this._relAlias);
    }
    getFormulaHtml() {
        const s = Column_1.Column.printColumn(this._name, this._relAlias);
        if (this._wrappedInParentheses === true) {
            return '(' + s + ')';
        }
        else {
            return s;
        }
    }
    static _getColumnIndex(schemaA, schemaB, name, relAlias) {
        if (!schemaB || schemaB === null) {
            return schemaA.getColumnIndex(name, relAlias, true);
        }
        // if 2 schemas are given make sure the given relAlias.name is not ambiguous
        const index = schemaA.getColumnIndex(name, relAlias, false);
        if (index === -1) {
            // must be in schemaB!
            return schemaB.getColumnIndex(name, relAlias, true) + schemaA.getSize();
        }
        else {
            if (schemaB.getColumnIndex(name, relAlias, false) !== -1) {
                // ambiguous!!
                // throw new Error('column ' + relAlias + '.' + name + ' found in both schemas: ' + schemaA.toString() + ' ' + schemaB.toString());
                return index; // deactivated error logic to allow join conditions after cross joins which may result in duplicate columns
            }
            else {
                return index;
            }
        }
    }
    static _getType(schemaA, schemaB, index) {
        if (index >= schemaA.getSize()) {
            return schemaB.getType(index - schemaA.getSize());
        }
        return schemaA.getType(index);
    }
}
exports.ValueExprColumnValue = ValueExprColumnValue;
/**
 * all value expressions that are not column values belong here
 * @constructor
 * @param {String} dataType the datatype the function returns
 * @param {String} func     the name of the function used
 * @param {Array}  args     array containing the specific arguments for the function
 */
class ValueExprGeneric extends ValueExpr {
    constructor(dataType, func, args) {
        super();
        this._func = func;
        this._dataType = dataType;
        this._dataTypeCalculated = null;
        this._args = args || [];
    }
    evaluate(tupleA, tupleB, row, statementSession) {
        switch (this._dataType) {
            case 'string':
                return this._evaluateString(tupleA, tupleB, row, statementSession);
            case 'number':
                return this._evaluateNumber(tupleA, tupleB, row, statementSession);
            case 'boolean':
                return this._evaluateBoolean(tupleA, tupleB, row, statementSession);
            case 'date':
                return this._evaluateDate(tupleA, tupleB, row, statementSession);
            case 'null':
                return this._evaluateNull(tupleA, tupleB, row, statementSession);
            default:
                throw new Error('this should not happen!');
        }
    }
    _parseIsoDate(str) {
        const regex = /^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$/;
        const groups = regex.exec(str);
        if (groups === null) {
            throw new ExecutionError_1.ExecutionError(i18n.t('db.messages.exec.error-invalid-date-format', { str: str }), this._codeInfo);
        }
        const year = parseInt(groups[1], 10);
        const month = parseInt(groups[2], 10) - 1;
        const day = parseInt(groups[3], 10);
        const date = new Date(year, month, day);
        if (date.getFullYear() !== year || date.getMonth() !== month || date.getDate() !== day) {
            this.throwExecutionError(i18n.t('db.messages.exec.error-invalid-date-format', { str: str }));
        }
        return date;
    }
    _evaluateNull(tupleA, tupleB, row, statementSession) {
        switch (this._func) {
            case 'constant':
                return null;
            case 'coalesce':
                // returns the first non null value or null if all are null
                for (let i = 0; i < this._args.length; i++) {
                    const value = this._args[i].evaluate(tupleA, tupleB, row, statementSession);
                    if (value !== null) {
                        return value;
                    }
                }
                return null;
            case 'caseWhen':
            case 'caseWhenElse':
                // conditions are on i%2 === 0
                // values on i%2 === 1
                // see http://www.postgresql.org/docs/9.3/static/functions-conditional.html
                for (let i = 0; i < this._args.length; i += 2) {
                    if (this._args[i].evaluate(tupleA, tupleB, row, statementSession) === true) {
                        return this._args[i + 1].evaluate(tupleA, tupleB, row, statementSession);
                    }
                }
                return null;
            default:
                throw new Error('this should not happen!');
        }
    }
    _evaluateDate(tupleA, tupleB, row, statementSession) {
        let a, b;
        if (this._func === 'transaction_timestamp'
            || this._func === 'statement_timestamp'
            || this._func === 'now'
            || this._func === 'clock_timestamp') {
            // dates are the same due to lack of transaction concept
            // now is alias of transaction_timestamp
            return statementSession.statement_timestamp;
        }
        a = this._args[0].evaluate(tupleA, tupleB, row, statementSession);
        b = this._args.length > 1 && this._args[1].evaluate(tupleA, tupleB, row, statementSession);
        if (a === null || this._args.length > 1 && b === null) {
            return null;
        }
        switch (this._func) {
            case 'date':
                return this._parseIsoDate(a);
            case 'adddate':
                return new Date(a.getTime() + b * MILLI_SEC_PER_DAY);
            case 'subdate':
                return new Date(a.getTime() - b * MILLI_SEC_PER_DAY);
            default:
                throw new Error('this should not happen!');
        }
    }
    _checkDate(schemaA, schemaB) {
        switch (this._func) {
            case 'transaction_timestamp':
            case 'statement_timestamp':
            case 'clock_timestamp':
            case 'now':
                return true;
            case 'date':
                return this._checkArgsDataType(schemaA, schemaB, ['string']);
            case 'adddate':
            case 'subdate':
                return this._checkArgsDataType(schemaA, schemaB, ['date', 'number']);
            default:
                throw new Error('this should not happen!');
        }
    }
    _evaluateBoolean(tupleA, tupleB, row, statementSession) {
        let a, b, typeA;
        if (this._func === 'constant') {
            return this._args[0];
        }
        a = this._args[0].evaluate(tupleA, tupleB, row, statementSession);
        b = this._args.length > 1 && this._args[1].evaluate(tupleA, tupleB, row, statementSession);
        switch (this._func) {
            case 'not':
                if (a === 'unknown') {
                    return a;
                }
                return !a;
            case 'and':
                if (a === false || b === false) {
                    return false;
                }
                if (a === true && b === true) {
                    return true;
                }
                return 'unknown';
            case 'or':
                if (a === true || b === true) {
                    return true;
                }
                if (a === false && b === false) {
                    return false;
                }
                return 'unknown';
            case 'xor':
                if (a === 'unknown' || b === 'unknown') {
                    return 'unknown';
                }
                return (a !== b);
            case '=':
            case '>=':
            case '<=':
            case '>':
            case '<':
            case '!=':
                typeA = this._args[0].getDataType();
                return ValueExprGeneric._condition_compare(a, b, typeA, this._func);
            case 'like':
            case 'ilike':
                if (!this._regex) {
                    throw new Error(`regex should have been set by check`);
                }
                return this._regex.test(a);
            default:
                throw new Error('this should not happen!');
        }
    }
    static _condition_compare(valueA, valueB, type, comparator) {
        if (valueA === null || valueB === null) {
            // null compared with any not null value => 'unknown'
            switch (comparator) {
                case '=':
                case '>=':
                case '<=':
                    if (valueA === valueB) {
                        return true;
                    }
                    return 'unknown';
                case '<':
                case '>':
                    if (valueA === valueB) {
                        return false;
                    }
                    return 'unknown';
                case '!=':
                    return valueA !== valueB;
                default:
                    throw new Error('unknown operator');
            }
        }
        switch (type) {
            case 'number':
            case 'string':
                switch (comparator) {
                    case '=':
                        return valueA === valueB;
                    case '>':
                        return valueA > valueB;
                    case '<':
                        return valueA < valueB;
                    case '>=':
                        return valueA >= valueB;
                    case '<=':
                        return valueA <= valueB;
                    case '!=':
                        return valueA !== valueB;
                    default:
                        throw new Error('unknown operator');
                }
            case 'date':
                switch (comparator) {
                    case '=':
                        return valueA.getTime() === valueB.getTime();
                    case '>':
                        return valueA > valueB;
                    case '<':
                        return valueA < valueB;
                    case '>=':
                        return valueA >= valueB;
                    case '<=':
                        return valueA <= valueB;
                    case '!=':
                        return valueA.getTime() !== valueB.getTime();
                    default:
                        throw new Error('unknown operator');
                }
            case 'boolean':
                if (typeof valueA !== 'boolean' || typeof valueB !== 'boolean') {
                    throw new Error('operands have different type');
                }
                switch (comparator) {
                    case '=':
                        return valueA === valueB;
                    case '>':
                        return valueA > valueB;
                    case '<':
                        return valueA < valueB;
                    case '>=':
                        return valueA >= valueB;
                    case '<=':
                        return valueA <= valueB;
                    case '!=':
                        return valueA !== valueB;
                    default:
                        throw new Error('unknown operator');
                }
            default:
                throw new Error('unknown type ' + type);
        }
    }
    _checkBoolean(schemaA, schemaB) {
        let typeA, typeB;
        switch (this._func) {
            case 'constant':
                return true;
            case 'not':
                return this._checkArgsDataType(schemaA, schemaB, ['boolean']);
            case 'and':
            case 'or':
            case 'xor':
                return this._checkArgsDataType(schemaA, schemaB, ['boolean', 'boolean']);
            case '=':
            case '>=':
            case '<=':
            case '>':
            case '<':
            case '!=':
                // check if the datatypes are identical
                this._args[0].check(schemaA, schemaB);
                this._args[1].check(schemaA, schemaB);
                typeA = this._args[0].getDataType();
                typeB = this._args[1].getDataType();
                if (typeA === 'null' || typeB === 'null') {
                    return true;
                }
                else if (typeA === typeB) {
                    return true;
                }
                else {
                    this.throwExecutionError(i18n.t('db.messages.exec.error-could-not-compare-different-types', {
                        typeA: typeA,
                        typeB: typeB,
                    }));
                }
                return this._checkArgsDataType(schemaA, schemaB, ['boolean', 'boolean']);
            case 'like':
            case 'ilike':
                // http://www.postgresql.org/docs/9.4/static/functions-matching.html#FUNCTIONS-LIKE
                this._args[0].check(schemaA, schemaB);
                if (this._args[1].getDataType() !== 'string' || this._args[1]._func !== 'constant') {
                    return false;
                }
                // cache regex
                const value = this._args[1]._args[0]; // direct access of constant value
                let regex_str = regExpEscape(value);
                regex_str = regex_str.replace(/([^\\]?)_/g, '$1.');
                regex_str = regex_str.replace(/([^\\]?)%/g, '$1.*');
                const flags = this._func === 'ilike' ? 'i' : '';
                this._regex = new RegExp('^' + regex_str + '$', flags);
                break;
            default:
                throw new Error('this should not happen!');
        }
    }
    _evaluateString(tupleA, tupleB, row, statementSession) {
        switch (this._func) {
            case 'constant':
                return this._args[0];
            case 'lower':
            case 'upper':
                const a = this._args[0].evaluate(tupleA, tupleB, row, statementSession);
                if (a === null) {
                    return null;
                }
                else if (this._func === 'lower') {
                    return a.toLowerCase();
                }
                else {
                    return a.toUpperCase();
                }
            case 'concat':
                let value = '';
                for (let i = 0; i < this._args.length; i++) {
                    const a = this._args[i].evaluate(tupleA, tupleB, row, statementSession);
                    if (a === null) {
                        return null;
                    }
                    value += a;
                }
                return value;
            default:
                throw new Error('this should not happen!');
        }
    }
    _evaluateNumber(tupleA, tupleB, row, statementSession) {
        // no args
        switch (this._func) {
            case 'constant':
                return this._args[0];
        }
        // unary and binary functions
        const valueA = this._args.length > 0 ? this._args[0].evaluate(tupleA, tupleB, row, statementSession) : undefined;
        const valueB = this._args.length > 1 ? this._args[1].evaluate(tupleA, tupleB, row, statementSession) : undefined;
        switch (this._func) {
            case 'add':
                if (valueA === null || valueB === null) {
                    return null;
                }
                return valueA + valueB;
            case 'sub':
                if (valueA === null || valueB === null) {
                    return null;
                }
                return valueA - valueB;
            case 'mul':
                if (valueA === null || valueB === null) {
                    return null;
                }
                return valueA * valueB;
            case 'div':
                if (valueA === null || valueB === null) {
                    return null;
                }
                return valueA / valueB;
            case 'mod':
                if (valueA === null || valueB === null) {
                    return null;
                }
                return valueA % valueB;
            case 'abs':
                if (valueA === null) {
                    return null;
                }
                return Math.abs(valueA);
            case 'floor':
                if (valueA === null) {
                    return null;
                }
                return Math.floor(valueA);
            case 'ceil':
                if (valueA === null) {
                    return null;
                }
                return Math.ceil(valueA);
            case 'round':
                if (valueA === null) {
                    return null;
                }
                return Math.round(valueA);
            case 'minus':
                if (valueA === null) {
                    return null;
                }
                return -valueA;
            case 'rand':
                return Math.random();
            case 'rownum':
                return row + 1;
            case 'strlen':
                if (valueA === null) {
                    return null;
                }
                return valueA.length;
            case 'year':
                if (valueA === null) {
                    return null;
                }
                return valueA.getFullYear();
            case 'month':
                if (valueA === null) {
                    return null;
                }
                return valueA.getMonth() + 1;
            case 'dayofmonth':
                if (valueA === null) {
                    return null;
                }
                return valueA.getDate();
            case 'hour':
                if (valueA === null) {
                    return null;
                }
                return valueA.getHours();
            case 'minute':
                if (valueA === null) {
                    return null;
                }
                return valueA.getMinutes();
            case 'second':
                if (valueA === null) {
                    return null;
                }
                return valueA.getSeconds();
            default:
                throw new Error('this should not happen!');
        }
    }
    _checkArgsDataType(schemaA, schemaB, types_expected) {
        const types_given = [];
        if (this._args.length !== types_expected.length) {
            throw new Error('this should not happen: #args != #types');
        }
        for (let i = 0; i < types_expected.length; i++) {
            this._args[i].check(schemaA, schemaB);
            types_given.push(this._args[i].getDataType());
        }
        for (let i = 0; i < types_given.length; i++) {
            if (types_given[i] !== types_expected[i]) {
                this.throwExecutionError(i18n.t('db.messages.exec.error-function-expects-type', {
                    func: this._func,
                    expected: types_expected,
                    given: types_given,
                }));
            }
        }
        return true;
    }
    getDataType() {
        if (this._dataTypeCalculated !== null) {
            return this._dataTypeCalculated;
        }
        return this._dataType;
    }
    check(schemaA, schemaB) {
        switch (this._dataType) {
            case 'string':
                return this._checkString(schemaA, schemaB);
            case 'number':
                return this._checkNumber(schemaA, schemaB);
            case 'boolean':
                return this._checkBoolean(schemaA, schemaB);
            case 'date':
                return this._checkDate(schemaA, schemaB);
            case 'null':
                return this._checkNull(schemaA, schemaB);
            default:
                throw new Error('this should not happen!');
        }
    }
    _checkNull(schemaA, schemaB) {
        switch (this._func) {
            case 'constant':
                return true;
            case 'coalesce':
                if (this._args.length === 0) {
                    throw new Error('this should not happen!');
                }
                // all arguments must be of same type or null
                this._args[0].check(schemaA, schemaB);
                this._dataTypeCalculated = this._args[0].getDataType();
                for (let i = 1; i < this._args.length; i++) {
                    this._args[i].check(schemaA, schemaB);
                    const dataType = this._args[i].getDataType();
                    if (this._dataType === 'null' && dataType !== 'null') {
                        this._dataTypeCalculated = dataType;
                    }
                    else if (dataType !== 'null' && this._dataType !== dataType) {
                        this.throwExecutionError(i18n.t('db.messages.exec.error-function-expects-arguments-of-same-type', { func: 'COALESCE()' }));
                    }
                }
                break;
            case 'caseWhen':
            case 'caseWhenElse':
                // conditions are on i%2 === 0
                // values on i%2 === 1
                // check conditions to be boolean
                for (let i = 0; i < this._args.length; i += 2) {
                    this._args[i].check(schemaA, schemaB);
                    if (this._args[i].getDataType() !== 'boolean') {
                        this.throwExecutionError(i18n.t('db.messages.exec.error-case-when-condition-must-be-boolean'));
                    }
                }
                // all values must be of same type
                this._args[1].check(schemaA, schemaB);
                this._dataTypeCalculated = this._args[1].getDataType();
                for (let i = 3; i < this._args.length; i += 2) {
                    this._args[i].check(schemaA, schemaB);
                    const dataType = this._args[i].getDataType();
                    if (this._dataType === 'null' && dataType !== 'null') {
                        this._dataTypeCalculated = dataType;
                    }
                    else if (dataType !== 'null' && this._dataType !== dataType) {
                        this.throwExecutionError(i18n.t('db.messages.exec.error-case-when-expects-results-of-same-type'));
                    }
                }
                break;
            default:
                throw new Error('this should not happen!');
        }
    }
    _checkString(schemaA, schemaB) {
        switch (this._func) {
            case 'constant':
                return true;
            case 'lower':
            case 'upper':
                return this._checkArgsDataType(schemaA, schemaB, ['string']);
            case 'concat':
                if (this._args.length === 0) {
                    throw new Error('this should not happen!');
                }
                // all arguments must be of type String or null
                this._args[0].check(schemaA, schemaB);
                this._dataTypeCalculated = 'string';
                for (let i = 1; i < this._args.length; i++) {
                    this._args[i].check(schemaA, schemaB);
                    const dataType = this._args[i].getDataType();
                    if (this._dataType === 'null' && dataType !== 'null') {
                        this._dataTypeCalculated = dataType;
                    }
                    else if (dataType !== 'null' && this._dataType !== dataType) {
                        this.throwExecutionError(i18n.t('db.messages.exec.error-function-expects-arguments-of-same-type', { func: 'CONCAT()' }));
                    }
                }
                break;
            default:
                throw new Error('this should not happen!');
        }
    }
    _checkNumber(schemaA, schemaB) {
        switch (this._func) {
            case 'constant':
            case 'rand':
            case 'rownum':
                return true;
            case 'add':
            case 'sub':
            case 'mul':
            case 'div':
            case 'mod':
                return this._checkArgsDataType(schemaA, schemaB, ['number', 'number']);
            case 'abs':
            case 'floor':
            case 'ceil':
            case 'round':
            case 'minus':
                return this._checkArgsDataType(schemaA, schemaB, ['number']);
            case 'strlen':
                return this._checkArgsDataType(schemaA, schemaB, ['string']);
            case 'year':
            case 'month':
            case 'dayofmonth':
            case 'hour':
            case 'minute':
            case 'second':
                return this._checkArgsDataType(schemaA, schemaB, ['date']);
            default:
                throw new Error('this should not happen!');
        }
    }
    toString() {
        let str = this._func + '(';
        for (let i = 0; i < this._args.length; i++) {
            if (i !== 0) {
                str += ', ';
            }
            str += this._args[i] === null ? 'null' : this._args[i].toString();
        }
        return str + ')';
    }
    getFormulaHtml() {
        const printFunction = (func_name) => {
            let str = (func_name || this._func) + '(';
            for (let i = 0; i < this._args.length; i++) {
                if (i !== 0) {
                    str += ', ';
                }
                str += this._args[i].getFormulaHtml();
            }
            return str + ')';
        };
        const printCase = (hasElse) => {
            // conditions are on i%2 === 0
            // values on i%2 === 1
            // else is the very last element (if present)
            let str = 'CASE';
            for (let i = 0; i < this._args.length - (hasElse ? 2 : 0); i += 2) {
                str += ` WHEN ${this._args[i].getFormulaHtml()} THEN ${this._args[i + 1].getFormulaHtml()}`;
            }
            if (hasElse === true) {
                str += ' ELSE ' + this._args[this._args.length - 1].getFormulaHtml();
            }
            return str + ' END';
        };
        const binary = (func_name) => {
            let s = '';
            s += `<span> ${(func_name || this._func)} </span>`;
            s = this._args[0].getFormulaHtml() + s;
            s += this._args[1].getFormulaHtml();
            return `<span>${s}</span>`;
        };
        function getFormula() {
            const { _func } = this;
            switch (_func) {
                case 'constant': {
                    const value = this._args[0];
                    const type = this._dataTypeCalculated || this._dataType;
                    return printValue(value, type);
                }
                case 'rand':
                case 'rownum':
                case 'abs':
                case 'ceil':
                case 'floor':
                case 'round':
                case 'year':
                case 'month':
                case 'dayofmonth':
                case 'hour':
                case 'minute':
                case 'second':
                case 'adddate':
                case 'subdate':
                case 'concat':
                case 'upper':
                case 'lower':
                case 'date':
                    return printFunction.call(this, _func.toUpperCase());
                case 'strlen':
                    return printFunction.call(this, 'length');
                case 'minus':
                    return printFunction.call(this, '-');
                case 'not':
                    return printFunction.call(this, '!');
                case 'caseWhen':
                case 'caseWhenElse':
                    return printCase.call(this, this._func === 'caseWhenElse');
                case 'add':
                    return binary.call(this, '+');
                case 'sub':
                    return binary.call(this, '-');
                case 'mul':
                    return binary.call(this, '*');
                case 'div':
                    return binary.call(this, '/');
                case 'mod':
                    return binary.call(this, '%');
                case 'and':
                case 'or':
                case 'xor':
                case 'like':
                case 'ilike':
                case '=':
                    return binary.call(this, _func);
                case '>=':
                    return binary.call(this, '');
                case '<=':
                    return binary.call(this, '');
                case '>':
                    return binary.call(this, '&gt;');
                case '<':
                    return binary.call(this, '&lt;');
                case '!=':
                    return binary.call(this, '');
            }
            return this.toString();
        }
        if (this._wrappedInParentheses === true) {
            return `(${getFormula.call(this)})`;
        }
        else {
            return (getFormula.call(this)).toString();
        }
    }
}
exports.ValueExprGeneric = ValueExprGeneric;

},{"./Column":18,"./ExecutionError":21,"i18next":16}],35:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AntiJoin = void 0;
const Join_1 = require("./Join");
/**
 * relational algebra anti-join operator
 */
class AntiJoin extends Join_1.Join {
    constructor(child, child2, condition) {
        super(child, child2, '', condition, false, true);
    }
    _checkSchema(schemaA, schemaB) {
        try {
            this._schema = this._child.getSchema().copy();
            this._rowCreatorMatched = function (rowA, rowB) {
                return rowA;
            };
            this._rowCreatorNotMatched = function (rowA, rowB) {
                return rowA;
            };
        }
        catch (e) {
            // throw (new) error in the join-context
            this.throwExecutionError(e.message);
        }
    }
    getResult(session) {
        return super._getResult(session, true);
    }
}
exports.AntiJoin = AntiJoin;

},{"./Join":39}],36:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrossJoin = void 0;
const i18n = require("i18next");
const Schema_1 = require("../Schema");
const ValueExpr = require("../ValueExpr");
const Join_1 = require("./Join");
/**
 * relational algebra inner Join operator
 *
 * this is just a wrapper for {@link Join} with true as condition
 */
class CrossJoin extends Join_1.Join {
    constructor(child, child2) {
        const joinCondition = new ValueExpr.ValueExprGeneric('boolean', 'constant', [true]);
        super(child, child2, '', {
            type: 'theta',
            joinExpression: joinCondition,
        }, false);
    }
    _checkSchema(schemaA, schemaB) {
        try {
            // check columns appearing in both schemas
            const conflicts = schemaA.getConflictingColumnsArray(schemaB);
            if (conflicts.length > 0) {
                this.throwExecutionError(i18n.t('db.messages.exec.error-join-would-produce-non-unique-columns', { conflicts: conflicts.join(', ') }));
            }
            this._schema = Schema_1.Schema.concat(this._child.getSchema(), this._child2.getSchema());
            this._rowCreatorMatched = function (rowA, rowB) {
                return rowA.concat(rowB);
            };
            this._rowCreatorNotMatched = null;
        }
        catch (e) {
            // throw (new) error in the join-context
            this.throwExecutionError(e.message);
        }
    }
    getResult(session) {
        return super._getResult(session, true);
    }
    getArgumentHtml() {
        // do not display the boolean true
        return '';
    }
}
exports.CrossJoin = CrossJoin;

},{"../Schema":30,"../ValueExpr":34,"./Join":39,"i18next":16}],37:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FullOuterJoin = void 0;
const i18n = require("i18next");
const Schema_1 = require("../Schema");
const Table_1 = require("../Table");
const Join_1 = require("./Join");
/**
 * relational algebra full outer Join operator
 *
 * A full outer join B = (A left outer join B) union (A right outer join B)
 *
 * @extends RANode
 * @constructor
 * @param   {RANode}               child     the left child expression
 * @param   {RANode}               child2    the right child expression
 * @param   {null|ValueExpr|Array} condition see condition of {@link Join}
 * @returns {FullOuterJoin}
 */
class FullOuterJoin extends Join_1.Join {
    constructor(child, child2, condition) {
        super(child, child2, '', condition, false);
    }
    setChild2(child2) {
        this._child2 = child2;
    }
    _checkSchema(schemaA, schemaB) {
        try {
            // full outer join always has a concatenated schema
            // check columns appearing in both schemas
            const conflicts = schemaA.getConflictingColumnsArray(schemaB);
            if (conflicts.length > 0) {
                this.throwExecutionError(i18n.t('db.messages.exec.error-join-would-produce-non-unique-columns', { conflicts: conflicts.join(', ') }));
            }
            this._schema = Schema_1.Schema.concat(this._child.getSchema(), this._child2.getSchema());
            this._rowCreatorMatched = function (rowA, rowB) {
                return rowA.concat(rowB);
            };
            this._rowCreatorNotMatched = function (rowA, rowB) {
                return rowA.concat(rowB);
            };
        }
        catch (e) {
            // throw (new) error in the join-context
            this.throwExecutionError(e.message);
        }
    }
    getResult(session) {
        session = this._returnOrCreateSession(session);
        if (this._joinConditionEvaluator === null || this._rowCreatorMatched === null || this._rowCreatorNotMatched === null) {
            throw new Error(`check not called`);
        }
        const resultTable = new Table_1.Table();
        resultTable.setSchema(this.getSchema());
        // left join
        Join_1.Join.calcNestedLoopJoin(session, this.getChild(), this.getChild2(), resultTable, false, false, this._joinConditionEvaluator, this._rowCreatorMatched, this._rowCreatorNotMatched);
        // right join
        Join_1.Join.calcNestedLoopJoin(session, this.getChild(), this.getChild2(), resultTable, true, false, this._joinConditionEvaluator, this._rowCreatorMatched, this._rowCreatorNotMatched);
        resultTable.eliminateDuplicateRows();
        this.setResultNumRows(resultTable.getNumRows());
        return resultTable;
    }
}
exports.FullOuterJoin = FullOuterJoin;

},{"../Schema":30,"../Table":32,"./Join":39,"i18next":16}],38:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InnerJoin = void 0;
const i18n = require("i18next");
const Schema_1 = require("../Schema");
const Join_1 = require("./Join");
/**
 * relational algebra inner Join operator
 *
 * this is just a wrapper for {@link Join}
 */
class InnerJoin extends Join_1.Join {
    constructor(child, child2, condition) {
        super(child, child2, '', condition, false);
    }
    _checkSchema(schemaA, schemaB) {
        try {
            if (this._joinConditionOptions.type === 'natural') {
                const tmp = Schema_1.Schema.concatNatural(schemaA, schemaB, true, this._joinConditionOptions.restrictToColumns);
                const keepColumns = tmp.keep;
                this._schema = tmp.schema;
                this._rowCreatorMatched = function (rowA, rowB) {
                    return Join_1.Join.createNaturalRowArray(rowA, rowB, keepColumns.size, keepColumns.keepIndicesA, keepColumns.keepIndicesB);
                };
            }
            else {
                // theta join
                // check columns appearing in both schemas
                const conflicts = schemaA.getConflictingColumnsArray(schemaB);
                if (conflicts.length > 0) {
                    this.throwExecutionError(i18n.t('db.messages.exec.error-join-would-produce-non-unique-columns', { conflicts: conflicts.join(', ') }));
                }
                this._schema = Schema_1.Schema.concat(this._child.getSchema(), this._child2.getSchema());
                this._rowCreatorMatched = function (rowA, rowB) {
                    return rowA.concat(rowB);
                };
            }
            this._rowCreatorNotMatched = null;
        }
        catch (e) {
            // throw (new) error in the join-context
            this.throwExecutionError(e.message);
        }
    }
    getResult(session) {
        return super._getResult(session, true);
    }
}
exports.InnerJoin = InnerJoin;

},{"../Schema":30,"./Join":39,"i18next":16}],39:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Join = void 0;
const i18n = require("i18next");
const ExecutionError_1 = require("../ExecutionError");
const RANode_1 = require("../RANode");
const Table_1 = require("../Table");
const ValueExpr = require("../ValueExpr");
/**
 * relational algebra Join operator
 *
 * @extends RANode
 * @constructor
 * @param   {RANode}               child     the left child expression
 * @param   {RANode}               child2    the right child expression
 * @param   {null|ValueExpr|Array} condition condition is either a ValueExpr evaluating to boolean
 *                                         or an Array of unqualified column names as strings for the using clause or
 *                                         null for a natural join
 * @param   {String}               joinType  joinType is either inner, left or right
 * @returns {Join}
 */
class Join extends RANode_1.RANodeBinary {
    constructor(child, child2, functionName, 
    /** condition is either a ValueExpr evaluating to boolean
     * or an Array of unqualified column names as strings for the using clause or
     * null for a natural join
     */
    joinCondition, isRightJoin, isAntiJoin = false) {
        super(functionName, child, child2);
        this._joinConditionBooleanExpr = null;
        this._joinConditionEvaluator = null;
        this._schema = null;
        this._rowCreatorMatched = null;
        this._rowCreatorNotMatched = null; // used for outer joins
        this._isAntiJoin = isAntiJoin;
        this._isRightJoin = isRightJoin;
        this._joinConditionOptions = joinCondition;
    }
    getSchema() {
        if (this._schema === null) {
            throw new Error(`check not called`);
        }
        return this._schema;
    }
    /**
     * sets the _joinConditionEvaluator based on the _joinCondition options
     */
    check() {
        this._child.check();
        this._child2.check();
        const schemaA = this._child.getSchema();
        const schemaB = this._child2.getSchema();
        if (this._joinConditionOptions.type === 'natural') {
            const { restrictToColumns } = this._joinConditionOptions;
            // check if columns of using clause appear in both schemas
            if (restrictToColumns !== null) {
                for (let i = 0; i < restrictToColumns.length; i++) {
                    if (schemaA.getColumnIndexArray(restrictToColumns[i], null).length === 0 || schemaB.getColumnIndexArray(restrictToColumns[i], null).length === 0) {
                        this.throwExecutionError(i18n.t('db.messages.exec.error-column-not-in-both-schemas', { column: restrictToColumns[i] }));
                    }
                }
            }
            // generate natural condition
            this._joinConditionBooleanExpr = Join.getNaturalJoinCondition(schemaA, schemaB, restrictToColumns);
            this.setMetaData('naturalJoinConditions', Join.getNaturalJoinConditionArray(schemaA, schemaB, restrictToColumns));
        }
        else {
            // theta joins
            this._joinConditionBooleanExpr = this._joinConditionOptions.joinExpression;
        }
        this._joinConditionBooleanExpr.check(schemaA, schemaB);
        if (this._joinConditionBooleanExpr.getDataType() !== 'boolean') {
            throw new ExecutionError_1.ExecutionError('db.messages.exec.error-condition-must-be-boolean', this._codeInfo);
        }
        const expr = this._joinConditionBooleanExpr;
        this._joinConditionEvaluator = (rowA, rowB, rowNumber, session) => {
            // the boolean expression evaluation returns either true,false or 'unknown'!
            return expr.evaluate(rowA, rowB, rowNumber, session) === true;
        };
        // the schema specific part of the check process
        this._checkSchema(schemaA, schemaB);
    }
    _getResult(session, doEliminateDuplicateRows) {
        session = this._returnOrCreateSession(session);
        if (this._joinConditionEvaluator === null) {
            throw new Error(`check not called`);
        }
        const resultTable = new Table_1.Table();
        resultTable.setSchema(this.getSchema());
        this._executionStart = Date.now();
        Join.calcNestedLoopJoin(session, this.getChild(), this.getChild2(), resultTable, this._isRightJoin, this._isAntiJoin, this._joinConditionEvaluator, this._rowCreatorMatched, this._rowCreatorNotMatched);
        // can be omitted if join is known to produce no new duplicates (e.g semi join) 
        if (doEliminateDuplicateRows === true) {
            resultTable.eliminateDuplicateRows();
        }
        this.setResultNumRows(resultTable.getNumRows());
        this._executedEnd = Date.now() - this._executionStart;
        return resultTable;
    }
    static createNullArray(size) {
        return new Array(size).fill(null);
    }
    /**
     * returns an function to evaluate the given boolean expression
     */
    static getCheckedEvaluatorBooleanExpression(schemaA, schemaB, expr, codeInfo) {
        expr.check(schemaA, schemaB);
        if (expr.getDataType() !== 'boolean') {
            throw new ExecutionError_1.ExecutionError('db.messages.exec.error-condition-must-be-boolean', codeInfo);
        }
        return function (rowA, rowB, rowNumber, session) {
            // the boolean expression evaluation returns either true,false or 'unknown'!
            return expr.evaluate(rowA, rowB, rowNumber, session) === true;
        };
    }
    static getCheckedEvaluatorNaturalJoin(schemaA, schemaB, expr, codeInfo) {
    }
    static calcNestedLoopJoin(session, childA, childB, targetTable, isRightJoin, isAntiJoin, evalJoinCondition, createRowToAddIfMatched, createRowToAddIfNOTMatched) {
        const orgA = childA.getResult(session);
        const orgB = childB.getResult(session);
        const numRowsA = orgA.getNumRows();
        const numRowsB = orgB.getNumRows();
        const numColsA = orgA.getNumCols();
        const numColsB = orgB.getNumCols();
        if (isRightJoin === false) { // left (outer) joins
            let nullArrayRight;
            if (createRowToAddIfNOTMatched !== null) {
                nullArrayRight = Join.createNullArray(targetTable.getSchema().getSize() - numColsA); // == size of new A
            }
            const antiJoinDict = {};
            for (let i = 0; i < numRowsA; i++) {
                const rowA = orgA.getRow(i);
                let match = false;
                if (isAntiJoin) {
                    antiJoinDict[i] = false;
                }
                for (let j = 0; j < numRowsB; j++) {
                    const rowB = orgB.getRow(j);
                    if (evalJoinCondition(rowA, rowB, i, session) !== true) {
                        continue;
                    }
                    else {
                        // add row
                        match = true;
                        if (createRowToAddIfMatched !== null) {
                            const row = createRowToAddIfMatched(rowA, rowB);
                            if (isAntiJoin) {
                                antiJoinDict[i] = false;
                            }
                            else {
                                targetTable.addRow(row);
                            }
                        }
                    }
                }
                if (match === false && createRowToAddIfNOTMatched !== null) {
                    const row = createRowToAddIfNOTMatched(rowA, nullArrayRight);
                    if (row === null) {
                        continue;
                    }
                    if (isAntiJoin) {
                        antiJoinDict[i] = true;
                    }
                    else {
                        targetTable.addRow(row);
                    }
                }
            }
            if (isAntiJoin) {
                for (let i = 0; i < numRowsA; i++) {
                    if (antiJoinDict[i] === true) {
                        targetTable.addRow(orgA.getRow(i));
                    }
                }
            }
        }
        else { // right (outer) joins
            let nullArrayLeft;
            if (createRowToAddIfNOTMatched !== null) {
                nullArrayLeft = Join.createNullArray(targetTable.getSchema().getSize() - numColsB); // == size of new B
            }
            for (let i = 0; i < numRowsB; i++) {
                const rowB = orgB.getRow(i);
                let match = false;
                for (let j = 0; j < numRowsA; j++) {
                    const rowA = orgA.getRow(j);
                    if (evalJoinCondition(rowA, rowB, i, session) !== true) {
                        continue;
                    }
                    else {
                        // add row
                        match = true;
                        if (createRowToAddIfMatched !== null) {
                            const row = createRowToAddIfMatched(rowA, rowB);
                            targetTable.addRow(row);
                        }
                    }
                }
                if (match === false && createRowToAddIfNOTMatched !== null) {
                    const row = createRowToAddIfNOTMatched(nullArrayLeft, rowB);
                    if (row === null) {
                        continue;
                    }
                    targetTable.addRow(row);
                }
            }
        }
    }
    getArgumentHtml() {
        if (this._joinConditionBooleanExpr === null) {
            throw new Error(`check not called`);
        }
        if (this._joinConditionOptions.type === 'natural') {
            return '';
        }
        else {
            return this._joinConditionBooleanExpr.getFormulaHtml();
        }
    }
    static checkForDuplicates(schema) {
        const cols = {};
        for (let i = 0; i < schema.getSize(); i++) {
            const name = schema.getColumn(i).getName();
            if (name in cols) {
                return true;
            }
            cols[name] = true;
        }
        return false;
    }
    static getNaturalJoinConditionArray(schemaA, schemaB, restrictToColumns = null) {
        const numColsA = schemaA.getSize();
        const conditions = [];
        const hasDuplicateCols = Join.checkForDuplicates(schemaA) || Join.checkForDuplicates(schemaB);
        // find columns with the same name in schemaA and schemaB
        for (let i = 0; i < numColsA; i++) {
            const a = schemaA.getColumn(i);
            if (restrictToColumns !== null && restrictToColumns.indexOf(a.getName() + '') === -1) {
                // skip all but certain columns (for joins with USING())
                continue;
            }
            let indices = [];
            if (hasDuplicateCols) {
                indices = schemaB.getColumnIndexArray(a.getName(), a.getRelAlias());
            }
            else {
                indices = schemaB.getColumnIndexArray(a.getName(), null);
            }
            for (let j = 0; j < indices.length; j++) {
                const index = indices[j];
                const b = schemaB.getColumn(index);
                // the column indices are set manually
                const equals = new ValueExpr.ValueExprGeneric('boolean', '=', [
                    new ValueExpr.ValueExprColumnValue(a.getName(), a.getRelAlias(), i),
                    new ValueExpr.ValueExprColumnValue(b.getName(), b.getRelAlias(), numColsA + index),
                ]);
                conditions.push(equals);
            }
        }
        return conditions;
    }
    static getNaturalJoinCondition(schemaA, schemaB, restrictToColumns = null) {
        const conditions = Join.getNaturalJoinConditionArray(schemaA, schemaB, restrictToColumns);
        const length = conditions.length;
        switch (length) {
            case 0:
                return new ValueExpr.ValueExprGeneric('boolean', 'constant', [true]);
            case 1:
                return conditions[0];
            default:
                let cond = new ValueExpr.ValueExprGeneric('boolean', 'and', [conditions[0], conditions[1]]);
                for (let i = 2; i < length; i++) {
                    cond = new ValueExpr.ValueExprGeneric('boolean', 'and', [cond, conditions[i]]);
                }
                return cond;
        }
    }
}
exports.Join = Join;
Join.createNaturalRowArray = function (rowA, rowB, newRowSize, keepIndicesA, keepIndicesB) {
    const row = new Array(newRowSize);
    let col = 0;
    for (let k = 0; k < keepIndicesA.length; k++) {
        row[col++] = rowA[keepIndicesA[k]];
    }
    for (let k = 0; k < keepIndicesB.length; k++) {
        row[col++] = rowB[keepIndicesB[k]];
    }
    return row;
};

},{"../ExecutionError":21,"../RANode":26,"../Table":32,"../ValueExpr":34,"i18next":16}],40:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LeftOuterJoin = void 0;
const i18n = require("i18next");
const Schema_1 = require("../Schema");
const Join_1 = require("./Join");
/**
 * relational algebra left outer Join operator
 *
 * this is just a wrapper for {@link Join}
 *
 * @extends RANode
 * @constructor
 * @param   {RANode}               child     the left child expression
 * @param   {RANode}               child2    the right child expression
 * @param   {null|ValueExpr|Array} condition see condition of {@link Join}
 * @returns {LeftOuterJoin}
 */
class LeftOuterJoin extends Join_1.Join {
    constructor(child, child2, condition) {
        super(child, child2, '', condition, false);
    }
    _checkSchema(schemaA, schemaB) {
        try {
            if (this._joinConditionOptions.type === 'natural') {
                const tmp = Schema_1.Schema.concatNatural(schemaA, schemaB, true, this._joinConditionOptions.restrictToColumns);
                const keepColumns = tmp.keep;
                this._schema = tmp.schema;
                this._rowCreatorMatched = function (rowA, rowB) {
                    return Join_1.Join.createNaturalRowArray(rowA, rowB, keepColumns.size, keepColumns.keepIndicesA, keepColumns.keepIndicesB);
                };
            }
            else {
                // theta join
                // check columns appearing in both schemas
                const conflicts = schemaA.getConflictingColumnsArray(schemaB);
                if (conflicts.length > 0) {
                    this.throwExecutionError(i18n.t('db.messages.exec.error-join-would-produce-non-unique-columns', { conflicts: conflicts.join(', ') }));
                }
                this._schema = Schema_1.Schema.concat(this._child.getSchema(), this._child2.getSchema());
                this._rowCreatorMatched = function (rowA, rowB) {
                    return rowA.concat(rowB);
                };
            }
            this._rowCreatorNotMatched = function (rowA, rowB) {
                return rowA.concat(rowB);
            };
        }
        catch (e) {
            // throw (new) error in the join-context
            this.throwExecutionError(e.message);
        }
    }
    getResult(session) {
        return super._getResult(session, true);
    }
}
exports.LeftOuterJoin = LeftOuterJoin;

},{"../Schema":30,"./Join":39,"i18next":16}],41:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RightOuterJoin = void 0;
const i18n = require("i18next");
const Schema_1 = require("../Schema");
const Join_1 = require("./Join");
/**
 * relational algebra right outer Join operator
 *
 * this is just a wrapper for {@link Join}
 * @param   {RANode}               child     the left child expression
 * @param   {RANode}               child2    the right child expression
 * @param   {null|ValueExpr|Array} condition see condition of {@link Join}
 * @returns {RightOuterJoin}
 * @extends RANode
 * @constructor
 */
class RightOuterJoin extends Join_1.Join {
    constructor(child, child2, condition) {
        super(child, child2, '', condition, true);
    }
    _checkSchema(schemaA, schemaB) {
        try {
            if (this._joinConditionOptions.type === 'natural') {
                const tmp = Schema_1.Schema.concatNatural(schemaA, schemaB, false, this._joinConditionOptions.restrictToColumns);
                const keepColumns = tmp.keep;
                this._schema = tmp.schema;
                this._rowCreatorMatched = function (rowA, rowB) {
                    return Join_1.Join.createNaturalRowArray(rowA, rowB, keepColumns.size, keepColumns.keepIndicesA, keepColumns.keepIndicesB);
                };
            }
            else {
                // theta join
                // check columns appearing in both schemas
                const conflicts = schemaA.getConflictingColumnsArray(schemaB);
                if (conflicts.length > 0) {
                    this.throwExecutionError(i18n.t('db.messages.exec.error-join-would-produce-non-unique-columns', { conflicts: conflicts.join(', ') }));
                }
                this._schema = Schema_1.Schema.concat(this._child.getSchema(), this._child2.getSchema());
                this._rowCreatorMatched = function (rowA, rowB) {
                    return rowA.concat(rowB);
                };
            }
            this._rowCreatorNotMatched = function (rowA, rowB) {
                return rowA.concat(rowB);
            };
        }
        catch (e) {
            // throw (new) error in the join-context
            this.throwExecutionError(e.message);
        }
    }
    getResult(session) {
        return super._getResult(session, true);
    }
}
exports.RightOuterJoin = RightOuterJoin;

},{"../Schema":30,"./Join":39,"i18next":16}],42:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SemiJoin = void 0;
const Join_1 = require("./Join");
/**
 * relational algebra semi-join operator
 *
 * @extends RANode
 * @constructor
 * @param   {RANode}        child          the left child expression
 * @param   {RANode}        child2         the right child expression
 * @param   {Boolean}       isLeftSemiJoin true if if is a left semi join; false for right semi join
 * @returns {SemiJoin}
 */
class SemiJoin extends Join_1.Join {
    constructor(child, child2, isLeftSemiJoin) {
        super(child, child2, (isLeftSemiJoin ? '' : ''), {
            type: 'natural',
            restrictToColumns: null,
        }, !isLeftSemiJoin);
    }
    _checkSchema(schemaA, schemaB) {
        // semi join uses only either the left or the right schema
        if (this._isRightJoin) {
            this._schema = schemaB.copy();
            this._rowCreatorMatched = function (rowA, rowB) {
                return rowB;
            };
        }
        else {
            this._schema = schemaA.copy();
            this._rowCreatorMatched = function (rowA, rowB) {
                return rowA;
            };
        }
        this._rowCreatorNotMatched = null;
    }
    getResult(session) {
        return super._getResult(session, true);
    }
}
exports.SemiJoin = SemiJoin;

},{"./Join":39}],43:[function(require,module,exports){
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { start: peg$parsestart },
      peg$startRuleFunction  = peg$parsestart,

      peg$c0 = function(r) { return r; },
      peg$c1 = peg$anyExpectation(),
      peg$c2 = "\r\n",
      peg$c3 = peg$literalExpectation("\r\n", false),
      peg$c4 = "\n",
      peg$c5 = peg$literalExpectation("\n", false),
      peg$c6 = peg$otherExpectation("-- "),
      peg$c7 = "--",
      peg$c8 = peg$literalExpectation("--", false),
      peg$c9 = /^[ \t]/,
      peg$c10 = peg$classExpectation([" ", "\t"], false, false),
      peg$c11 = function() { return ''; },
      peg$c12 = function(text) { return text; },
      peg$c13 = "/*",
      peg$c14 = peg$literalExpectation("/*", false),
      peg$c15 = "*/",
      peg$c16 = peg$literalExpectation("*/", false),
      peg$c17 = peg$otherExpectation("whitespace"),
      peg$c18 = /^[ \t\r\n]/,
      peg$c19 = peg$classExpectation([" ", "\t", "\r", "\n"], false, false),
      peg$c20 = peg$otherExpectation("optional whitespace"),
      peg$c21 = peg$otherExpectation("whitespace without comments"),
      peg$c22 = /^[\r\n\t ]/,
      peg$c23 = peg$classExpectation(["\r", "\n", "\t", " "], false, false),
      peg$c24 = peg$otherExpectation("optional whitespace without comments"),
      peg$c25 = peg$otherExpectation("string"),
      peg$c26 = "'",
      peg$c27 = peg$literalExpectation("'", false),
      peg$c28 = /^[^'\n]/,
      peg$c29 = peg$classExpectation(["'", "\n"], true, false),
      peg$c30 = function(a) { return a; },
      peg$c31 = "-",
      peg$c32 = peg$literalExpectation("-", false),
      peg$c33 = /^[0-9]/,
      peg$c34 = peg$classExpectation([["0", "9"]], false, false),
      peg$c35 = function(a) {return parseInt(a, 10); },
      peg$c36 = ".",
      peg$c37 = peg$literalExpectation(".", false),
      peg$c38 = function(a) {return parseFloat(a); },
      peg$c39 = peg$otherExpectation("date in ISO format (YYYY-MM-DD)"),
      peg$c40 = function(year, month, day) {
      		year = parseInt(year, 10);
      		month = parseInt(month, 10)-1;
      		day = parseInt(day, 10);
      		var date = new Date(year, month, day);

      		if(date.getFullYear() != year || date.getMonth() != month ||  date.getDate() != day){
      			error(t('db.messages.parser.error-invalid-date-format', {str: text()}));
      		}
      		return date;
      	},
      peg$c41 = "true",
      peg$c42 = peg$literalExpectation("true", true),
      peg$c43 = function() { return true; },
      peg$c44 = "false",
      peg$c45 = peg$literalExpectation("false", true),
      peg$c46 = function() { return false; },
      peg$c47 = "=",
      peg$c48 = peg$literalExpectation("=", false),
      peg$c49 = peg$otherExpectation("relationName"),
      peg$c50 = /^[0-9a-zA-Z_]/,
      peg$c51 = peg$classExpectation([["0", "9"], ["a", "z"], ["A", "Z"], "_"], false, false),
      peg$c52 = /^[a-zA-Z]/,
      peg$c53 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
      peg$c54 = function(a) {
      		return a;
      	},
      peg$c55 = function(relAlias, name) {
      		if(relAlias != null)
      			relAlias = relAlias[0];

      		return {
      			type: 'columnName',
      			name: name,
      			relAlias: relAlias
      		};
      	},
      peg$c56 = "[",
      peg$c57 = peg$literalExpectation("[", false),
      peg$c58 = "]",
      peg$c59 = peg$literalExpectation("]", false),
      peg$c60 = function(relAlias, index) {
      		if(relAlias != null)
      			relAlias = relAlias[0];

      		return {
      			type: 'columnName',
      			name: parseInt(index, 10),
      			relAlias: relAlias
      		};
      	},
      peg$c61 = "\u03C0",
      peg$c62 = peg$literalExpectation("\u03C0", false),
      peg$c63 = function() { return getNodeInfo('pi'); },
      peg$c64 = function(o) { return o; },
      peg$c65 = "pi",
      peg$c66 = peg$literalExpectation("pi", true),
      peg$c67 = "\u03C3",
      peg$c68 = peg$literalExpectation("\u03C3", false),
      peg$c69 = function() { return getNodeInfo('sigma'); },
      peg$c70 = "sigma",
      peg$c71 = peg$literalExpectation("sigma", true),
      peg$c72 = "\u03C1",
      peg$c73 = peg$literalExpectation("\u03C1", false),
      peg$c74 = function() { return getNodeInfo('rho'); },
      peg$c75 = "rho",
      peg$c76 = peg$literalExpectation("rho", true),
      peg$c77 = "\u2190",
      peg$c78 = peg$literalExpectation("\u2190", false),
      peg$c79 = function() { return getNodeInfo('arrowLeft'); },
      peg$c80 = "<-",
      peg$c81 = peg$literalExpectation("<-", false),
      peg$c82 = "\u2192",
      peg$c83 = peg$literalExpectation("\u2192", false),
      peg$c84 = function() { return getNodeInfo('arrowRight'); },
      peg$c85 = "->",
      peg$c86 = peg$literalExpectation("->", false),
      peg$c87 = "\u03C8",
      peg$c88 = peg$literalExpectation("\u03C8", false),
      peg$c89 = function() { return getNodeInfo('psi'); },
      peg$c90 = "psi",
      peg$c91 = peg$literalExpectation("psi", true),
      peg$c92 = "\u03C4",
      peg$c93 = peg$literalExpectation("\u03C4", false),
      peg$c94 = function() { return getNodeInfo('tau'); },
      peg$c95 = "tau",
      peg$c96 = peg$literalExpectation("tau", true),
      peg$c97 = "\u03B3",
      peg$c98 = peg$literalExpectation("\u03B3", false),
      peg$c99 = function() { return getNodeInfo('gamma'); },
      peg$c100 = "gamma",
      peg$c101 = peg$literalExpectation("gamma", true),
      peg$c102 = "\u222A",
      peg$c103 = peg$literalExpectation("\u222A", false),
      peg$c104 = function() { return getNodeInfo('unionOperator'); },
      peg$c105 = "union",
      peg$c106 = peg$literalExpectation("union", true),
      peg$c107 = "\u2229",
      peg$c108 = peg$literalExpectation("\u2229", false),
      peg$c109 = function() { return getNodeInfo('intersectOperator'); },
      peg$c110 = "intersect",
      peg$c111 = peg$literalExpectation("intersect", true),
      peg$c112 = "\xF7",
      peg$c113 = peg$literalExpectation("\xF7", false),
      peg$c114 = "/",
      peg$c115 = peg$literalExpectation("/", false),
      peg$c116 = function() { return getNodeInfo('divisionOperator'); },
      peg$c117 = "\\",
      peg$c118 = peg$literalExpectation("\\", false),
      peg$c119 = function() { return getNodeInfo('differenceOperator'); },
      peg$c120 = "except",
      peg$c121 = peg$literalExpectation("except", true),
      peg$c122 = "\u2A2F",
      peg$c123 = peg$literalExpectation("\u2A2F", false),
      peg$c124 = "x",
      peg$c125 = peg$literalExpectation("x", false),
      peg$c126 = function() { return getNodeInfo('crossJoinOperator'); },
      peg$c127 = "cross",
      peg$c128 = peg$literalExpectation("cross", true),
      peg$c129 = "join",
      peg$c130 = peg$literalExpectation("join", true),
      peg$c131 = "\u2A1D",
      peg$c132 = peg$literalExpectation("\u2A1D", false),
      peg$c133 = "\u22C8",
      peg$c134 = peg$literalExpectation("\u22C8", false),
      peg$c135 = function() { return getNodeInfo('innerJoinOperator'); },
      peg$c136 = "inner",
      peg$c137 = peg$literalExpectation("inner", true),
      peg$c138 = function() { return getNodeInfo('naturalJoinOperator'); },
      peg$c139 = "natural",
      peg$c140 = peg$literalExpectation("natural", true),
      peg$c141 = "\u22C9",
      peg$c142 = peg$literalExpectation("\u22C9", false),
      peg$c143 = function() { return getNodeInfo('leftSemiJoinOperator'); },
      peg$c144 = "left",
      peg$c145 = peg$literalExpectation("left", true),
      peg$c146 = "semi",
      peg$c147 = peg$literalExpectation("semi", true),
      peg$c148 = "\u22CA",
      peg$c149 = peg$literalExpectation("\u22CA", false),
      peg$c150 = function() { return getNodeInfo('rightSemiJoinOperator'); },
      peg$c151 = "right",
      peg$c152 = peg$literalExpectation("right", true),
      peg$c153 = "\u25B7",
      peg$c154 = peg$literalExpectation("\u25B7", false),
      peg$c155 = function() { return getNodeInfo('antiJoinOperator'); },
      peg$c156 = "anti",
      peg$c157 = peg$literalExpectation("anti", true),
      peg$c158 = "\u27D5",
      peg$c159 = peg$literalExpectation("\u27D5", false),
      peg$c160 = function() { return getNodeInfo('leftOuterJoinOperator'); },
      peg$c161 = "outer",
      peg$c162 = peg$literalExpectation("outer", true),
      peg$c163 = "\u27D6",
      peg$c164 = peg$literalExpectation("\u27D6", false),
      peg$c165 = function() { return getNodeInfo('rightOuterJoinOperator'); },
      peg$c166 = "\u27D7",
      peg$c167 = peg$literalExpectation("\u27D7", false),
      peg$c168 = function() { return getNodeInfo('fullOuterJoinOperator'); },
      peg$c169 = "full",
      peg$c170 = peg$literalExpectation("full", true),
      peg$c171 = function(n) { usedRelationNames.push(n); },
      peg$c172 = function(n, e) {
      		e.assignmentName = n;
      		return {
      			type: 'assignment',
      			name: n,
      			child: e,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c173 = function(a, dst) {
      		return {
      			type: 'namedColumnExpr',
      			name: dst,
      			relAlias: null,
      			child: a,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c174 = function(dst, a) {
      		return {
      			type: 'namedColumnExpr',
      			name: dst,
      			relAlias: null,
      			child: a,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c175 = ",",
      peg$c176 = peg$literalExpectation(",", false),
      peg$c177 = function(a, b) {
      		var t = [a];
      		if(b !== null){
      			for(var i in b){
      				t.push(b[i][3]);
      			}
      		}
      		return t;
      	},
      peg$c178 = function(dst, src) {
      		return {
      			type: 'colAssignment',
      			src: src,
      			dst: dst,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c179 = function(src, dst) {
      		return {
      			type: 'colAssignment',
      			src: src,
      			dst: dst,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c180 = function(a, b) {
      	var t = [a];
      	if(b !== null){
      		for(var i in b){
      			t.push(b[i][3]);
      		}
      	}
      	return t;
      },
      peg$c181 = "asc",
      peg$c182 = peg$literalExpectation("asc", true),
      peg$c183 = "desc",
      peg$c184 = peg$literalExpectation("desc", true),
      peg$c185 = function(a, asc) {
      		if(asc == null)
      			asc = true;
      		else
      			asc = asc[1];

      		return {
      			col: a,
      			asc: asc
      		};
      	},
      peg$c186 = "sum",
      peg$c187 = peg$literalExpectation("sum", true),
      peg$c188 = "count",
      peg$c189 = peg$literalExpectation("count", true),
      peg$c190 = "avg",
      peg$c191 = peg$literalExpectation("avg", true),
      peg$c192 = "min",
      peg$c193 = peg$literalExpectation("min", true),
      peg$c194 = "max",
      peg$c195 = peg$literalExpectation("max", true),
      peg$c196 = "(",
      peg$c197 = peg$literalExpectation("(", false),
      peg$c198 = ")",
      peg$c199 = peg$literalExpectation(")", false),
      peg$c200 = function(func, col) {
      		return {
      			aggFunction: func.toUpperCase(),
      			col: col
      		};
      	},
      peg$c201 = "count(*)",
      peg$c202 = peg$literalExpectation("count(*)", true),
      peg$c203 = function() {
      		return {
      			aggFunction: 'COUNT_ALL',
      			col: null
      		};
      	},
      peg$c204 = function(func, name) {
      		func.name = name;
      		return func;
      	},
      peg$c205 = function(name, func) {
      		func.name = name;
      		return func;
      	},
      peg$c206 = function(a) {
      		/*
      		if the expression is only a single unqualified column
      		it could also be a relation and should not have been interpreted
      		as an expression

      		therefore the name of the "column" is checked against all known
      		relation-names; if it matches the whole `booleanExprWithTrailingWhitspace` match fails

      		if there is a boolean column that should form the whole expression
      		the user has to wrap it in parentheses
      		*/
      		if(a.type === 'valueExpr' && a.func === 'columnValue' && !a.wrappedInParentheses && a.args[1] === null){
      			for(var i = 0; i < usedRelationNames.length; i++){
      				if(usedRelationNames[i] === a.args[0]){
      					return false;
      				}
      			}
      			// not found in the known relations; seems to be a column
      			return true;
      		}
      		return true;
      	},
      peg$c207 = function(a2, a) {
      		var assignments = [a];
      		for(var i in a2){
      			assignments.push(a2[i][0]);
      		}
      		checkAssignments(assignments);

      		return {
      			type: 'relalgRoot',
      			assignments: assignments,
      			child: null,
      			operatorPositions: operatorPositions,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c208 = function(a, e) {
      		var assignments = [];
      		for(var i = 0; i < a.length; i++){
      			assignments.push(a[i][0]);
      		}
      		checkAssignments(assignments);

      		return {
      			type: 'relalgRoot',
      			assignments: assignments,
      			child: e,
      			operatorPositions: operatorPositions,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c209 = function(a) {
      		var groups = [];
      		
      		for(var i = 0; i < a.length; i++){
      			groups.push(a[i][1]);
      		}
      		checkGroupNamesUnique(groups);

      		return {
      			type: 'Root',
      			groups: groups,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c210 = function(a, b) {
      		var headers = [];
      		
      		headers.push(a);

      		b.map(function(e){
      			var header = e[1];

      			headers.push(header);
      		});

      		return headers;
      	},
      peg$c211 = "en",
      peg$c212 = peg$literalExpectation("en", false),
      peg$c213 = "de",
      peg$c214 = peg$literalExpectation("de", false),
      peg$c215 = "es",
      peg$c216 = peg$literalExpectation("es", false),
      peg$c217 = function(lang) {
      		return lang.toLocalLowerCase();
      	},
      peg$c218 = "exampleSql",
      peg$c219 = peg$literalExpectation("exampleSql", false),
      peg$c220 = " - {",
      peg$c221 = peg$literalExpectation(" - {", false),
      peg$c222 = /^[0-9 * a-z A-Z ( ) \n = . , ; - \/ \t]/,
      peg$c223 = peg$classExpectation([["0", "9"], " ", "*", " ", ["a", "z"], " ", ["A", "Z"], " ", "(", " ", ")", " ", "\n", " ", "=", " ", ".", " ", ",", " ", ";", [" ", " "], "/", " ", "\t"], false, false),
      peg$c224 = "}",
      peg$c225 = peg$literalExpectation("}", false),
      peg$c226 = function(a, query) {
      	return query;
      },
      peg$c227 = "exampleRelAlg",
      peg$c228 = peg$literalExpectation("exampleRelAlg", false),
      peg$c229 = function(query) {
      	return query;
      },
      peg$c230 = /^[a-z@]/,
      peg$c231 = peg$classExpectation([["a", "z"], "@"], false, false),
      peg$c232 = ":",
      peg$c233 = peg$literalExpectation(":", false),
      peg$c234 = /^[a-z]/,
      peg$c235 = peg$classExpectation([["a", "z"]], false, false),
      peg$c236 = "@",
      peg$c237 = peg$literalExpectation("@", false),
      peg$c238 = function(name, lang, text) {
      		return {
      			name: name,
      			lang: !lang ? null : lang[1],
      			text: text,
      		};
      	},
      peg$c239 = "[[",
      peg$c240 = peg$literalExpectation("[[", false),
      peg$c241 = "\\]]",
      peg$c242 = peg$literalExpectation("\\]]", false),
      peg$c243 = "]]",
      peg$c244 = peg$literalExpectation("]]", false),
      peg$c245 = function(name, lang, text) {
      		

      		text = text.replace(/\\]]/g, ']]');
      		text = text.replace(/\\\\]]/g, '\\]]');

      		return {
      			name: name,
      			lang: !lang ? null : lang[1],
      			text: text,
      		};
      	},
      peg$c246 = function(headers, s, r, a) {
      	
      	
      		var assignments = [];
      		for(var i = 0; i < a.length; i++){
      			assignments.push(a[i][1]);
      		}
      		checkAssignments(assignments);

      		// check headers
      		for(let i = 0; i < headers.length; i++){
      			const header = headers[i];

      			if(
      				header.name !== 'group' 
      				&& header.name !== 'description'
      				&& header.name !== 'category'
      			){
      				error(t('db.messages.parser.error-group-unknown-header', {name: header.name}));
      			}

      			// check for duplicates (O(n^2))
      			for(let j = 0; j < headers.length; j++){
      				if(i !== j && header.name === headers[j].name && header.lang === headers[j].lang){
      					console.warn(`duplicate header found: ${header.name}`, headers, text());
      					error(t('db.messages.parser.error-group-duplicate-header', {name: header.name}));
      				}
      			}
      		}

      		const groupHeader = headers.find(h => h.name === 'group');
      		if(groupHeader === undefined){
      			error(t('db.messages.parser.error-group-header-name-missing')+': "group: ..........\\n"');
      		}
      		else if(groupHeader.text.trim().length === 0){
      			error(t('error-group-header-name-empty'));
      		}

      		// check for exampleSql
      		let exampleSql = '';
      		if(s && s.length > 0) {
      			if(Array.isArray(s)) {
      				exampleSql = s[0][1]
      			}
      		}
      		exampleSql = exampleSql.trim();
      		
      		// check for exampleRelAlg
      		let exampleRelAlg = '';
      		if(r && r.length > 0) {
          	if(Array.isArray(r)) {
          			exampleRelAlg = r[0][1]
          	}
          }
      		exampleRelAlg = exampleRelAlg.trim();
      		

      		return {
      			type: 'tableGroup',
      			headers: headers,
      			assignments: assignments,
      			exampleSql: exampleSql,
      			exampleRA: exampleRelAlg,
      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c247 = function(first, rest) { return buildBinary(first, rest); },
      peg$c248 = function(e) {
      		e.wrappedInParentheses = true;
      		return e;
      	},
      peg$c249 = function(o, c) {
      		operatorPositions.push(o);
      		return {type: 'intersect', child2: c, codeInfo: getCodeInfo()};
      	},
      peg$c250 = function(o, c) {
      		operatorPositions.push(o);
      		return {type: 'union', child2: c, codeInfo: getCodeInfo()};
      	},
      peg$c251 = function(o, c) {
      		operatorPositions.push(o);
      		return {type: 'difference', child2: c, codeInfo: getCodeInfo()};
      	},
      peg$c252 = function(o, c) {
      		operatorPositions.push(o);
      		return {type: 'crossJoin', child2: c, codeInfo: getCodeInfo()};
      	},
      peg$c253 = function(o, a, c) {
      		operatorPositions.push(o);
      		return {type: 'thetaJoin', child2: c, arg:a, codeInfo: getCodeInfo()};
      	},
      peg$c254 = function(o, c) {
      		operatorPositions.push(o);
      		return {type: 'naturalJoin', child2: c, codeInfo: getCodeInfo()};
      	},
      peg$c255 = function(o, a, c) {
      		operatorPositions.push(o);
      		return {type: 'leftOuterJoin', child2: c, arg:a, codeInfo: getCodeInfo()};
      	},
      peg$c256 = function(o, a, c) {
      		operatorPositions.push(o);
      		return {type: 'rightOuterJoin', child2: c, arg:a, codeInfo: getCodeInfo()};
      	},
      peg$c257 = function(o, a, c) {
      		operatorPositions.push(o);
      		return {type: 'fullOuterJoin', child2: c, arg:a, codeInfo: getCodeInfo()};
      	},
      peg$c258 = function(o, c) {
      		operatorPositions.push(o);
      		return {type: 'leftSemiJoin', child2: c, codeInfo: getCodeInfo()};
      	},
      peg$c259 = function(o, c) {
      		operatorPositions.push(o);
      		return {type: 'rightSemiJoin', child2: c, codeInfo: getCodeInfo()};
      	},
      peg$c260 = function(o, a, c) {
      		operatorPositions.push(o);
      		return {type: 'antiJoin', child2: c, arg:a, codeInfo: getCodeInfo()};
      	},
      peg$c261 = function(o, c) {
      		operatorPositions.push(o);
      		return {type: 'division', child2: c, codeInfo: getCodeInfo()};
      	},
      peg$c262 = function(o, a, c) {
      		operatorPositions.push(o);
      		return {
      			type: 'projection',
      			child: c,
      			arg: a,
      			codeInfo: getCodeInfo(),
      		};
      	},
      peg$c263 = function(o, a, c) {
      		operatorPositions.push(o);
      		return {
      			type: 'selection',
      			child: c,
      			arg: a,
      			codeInfo: getCodeInfo(),
      		};
      	},
      peg$c264 = function(o, a, c) {
      		operatorPositions.push(o);
      		return {
      			type: 'renameColumns',
      			child: c,
      			arg: a,
      			codeInfo: getCodeInfo(),
      		};
      	},
      peg$c265 = function(o, a, c) {
      		operatorPositions.push(o);
      		return {
      			type: 'renameRelation',
      			child: c,
      			newRelAlias: a,
      			codeInfo: getCodeInfo(),
      		};
      	},
      peg$c266 = ";",
      peg$c267 = peg$literalExpectation(";", false),
      peg$c268 = function(o, arg, arg2, c) {
      		operatorPositions.push(o);
      		return {
      			type: 'groupBy',
      			child: c,
      			group: arg,
      			aggregate: arg2,
      			codeInfo: getCodeInfo(),
      		};
      	},
      peg$c269 = function(o, arg2, child) {
      		operatorPositions.push(o);
      		return {
      			type: 'groupBy',
      			child: child,
      			group: [],
      			aggregate: arg2,
      			codeInfo: getCodeInfo(),
      		};
      	},
      peg$c270 = function(o, a, c) {
      		operatorPositions.push(o);
      		return {
      			type: 'orderBy',
      			child: c,
      			arg: a,
      			codeInfo: getCodeInfo(),
      		};
      	},
      peg$c271 = function(a) {
      		return {
      			type: 'relation',
      			name: a,
      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c272 = "!=",
      peg$c273 = peg$literalExpectation("!=", false),
      peg$c274 = "\u2260",
      peg$c275 = peg$literalExpectation("\u2260", false),
      peg$c276 = "<>",
      peg$c277 = peg$literalExpectation("<>", false),
      peg$c278 = function() { return '!='; },
      peg$c279 = ">=",
      peg$c280 = peg$literalExpectation(">=", false),
      peg$c281 = "\u2265",
      peg$c282 = peg$literalExpectation("\u2265", false),
      peg$c283 = function() { return '>='; },
      peg$c284 = ">",
      peg$c285 = peg$literalExpectation(">", false),
      peg$c286 = "<=",
      peg$c287 = peg$literalExpectation("<=", false),
      peg$c288 = "\u2264",
      peg$c289 = peg$literalExpectation("\u2264", false),
      peg$c290 = function() { return '<='; },
      peg$c291 = "<",
      peg$c292 = peg$literalExpectation("<", false),
      peg$c293 = peg$otherExpectation("logical AND"),
      peg$c294 = "and",
      peg$c295 = peg$literalExpectation("and", true),
      peg$c296 = "\u2227",
      peg$c297 = peg$literalExpectation("\u2227", false),
      peg$c298 = peg$otherExpectation("logical XOR"),
      peg$c299 = "xor",
      peg$c300 = peg$literalExpectation("xor", true),
      peg$c301 = "\u22BB",
      peg$c302 = peg$literalExpectation("\u22BB", false),
      peg$c303 = "\u2295",
      peg$c304 = peg$literalExpectation("\u2295", false),
      peg$c305 = peg$otherExpectation("logical OR"),
      peg$c306 = "or",
      peg$c307 = peg$literalExpectation("or", true),
      peg$c308 = "\u2228",
      peg$c309 = peg$literalExpectation("\u2228", false),
      peg$c310 = peg$otherExpectation("logical NOT"),
      peg$c311 = "!",
      peg$c312 = peg$literalExpectation("!", false),
      peg$c313 = "\xAC",
      peg$c314 = peg$literalExpectation("\xAC", false),
      peg$c315 = peg$otherExpectation("delimiter"),
      peg$c316 = "string",
      peg$c317 = peg$literalExpectation("string", true),
      peg$c318 = "number",
      peg$c319 = peg$literalExpectation("number", true),
      peg$c320 = "date",
      peg$c321 = peg$literalExpectation("date", true),
      peg$c322 = "boolean",
      peg$c323 = peg$literalExpectation("boolean", true),
      peg$c324 = function(col, type) {
      		return {
      			name: col.name,
      			relAlias: col.relAlias,
      			type: type === null ? null : type[1].toLowerCase()
      		};
      	},
      peg$c325 = function(v) {
      		return {
      			type: 'date',
      			value: v
      		};
      	},
      peg$c326 = "null",
      peg$c327 = peg$literalExpectation("null", false),
      peg$c328 = "NULL",
      peg$c329 = peg$literalExpectation("NULL", false),
      peg$c330 = function() {
      		return {
      			type: 'null',
      			value: null
      		};
      	},
      peg$c331 = function(a) {
      		return {
      			type: 'boolean',
      			value: a,
      			quoted: false
      		};
      	},
      peg$c332 = /^[\-_a-z0-9.]/i,
      peg$c333 = peg$classExpectation(["-", "_", ["a", "z"], ["0", "9"], "."], false, true),
      peg$c334 = function(a) {
      		return {
      			type: 'string',
      			value: a,
      			quoted: false
      		};
      	},
      peg$c335 = function(a) {
      		return {
      			type: 'string',
      			value: a,
      			quoted: true
      		};
      	},
      peg$c336 = "\"",
      peg$c337 = peg$literalExpectation("\"", false),
      peg$c338 = /^[^"\n]/,
      peg$c339 = peg$classExpectation(["\"", "\n"], true, false),
      peg$c340 = function(a, b) {
      		var cols = [a];
      		var newCol;
      		for(var i = 0; i < b.length; i++){
      			newCol = b[i][1];

      			// attributes must be unique
      			for(var j = 0; j < cols.length; j++){
      				if(cols[j].name == newCol.name && cols[j].relAlias == newCol.relAlias){
      					var n = newCol.relAlias == null ? '' : newCol.relAlias+'.';
      					error(t('db.messages.parser.error-group-non-unique-attribute', {name: n+newCol.name, index: i+2}));
      				}
      			}

      			cols.push(newCol);
      		}

      		return cols;
      	},
      peg$c341 = function(a, b) {
      		var t = [a];
      		for(var i = 0; i < b.length; i++){
      			t.push(b[i][1]);
      		}

      		return t;
      	},
      peg$c342 = "{",
      peg$c343 = peg$literalExpectation("{", false),
      peg$c344 = function(cols, trows) {
      		var numCols = cols.length;

      		var rows = [], row, val, newRow;
      		for(var i = 0; i < trows.length; i++){
      			row = trows[i][2];

      			if(row.length != numCols)
      				error('expected '+numCols+' columns in row '+(i+1)+' but '+row.length+' found');

      			// check types
      			newRow = new Array(numCols); // for blank data only
      			for(var j = 0; j < numCols; j++){
      				val = row[j];

      				if(val.type === 'null'){
      					newRow[j] = null;
      					continue;
      				}

      				// type not defined yet: define column type by first not null value
      				if(cols[j].type === null){
      					if(val.type == 'date')
      						cols[j].type = 'date';
      					else if(val.type == 'boolean')
      						cols[j].type = 'boolean';
      					else if(val.type == 'number' || val.value.match(/^-?[0-9]+(\.[0-9]+)?$/) && !val.quoted)
      						cols[j].type = 'number';
      					else if(val.type == 'string')
      						cols[j].type = 'string';
      				}

      				switch(cols[j].type){
      					case 'date':
      						if(val.type !== 'date'){
      							error('no valid date in row '+(i+1)+' column '+(j+1));
      						}
      						newRow[j] = val.value;
      						break;

      					case 'number':
      						if(val.type === 'number'){
      							newRow[j] = val.value;
      						}
      						else if(val.value.match(/^-?[0-9]+$/)){
      							newRow[j] = parseInt(val.value, 10);
      						}
      						else if(val.value.match(/^-?[0-9]+\.[0-9]+$/)){
      							newRow[j] = parseFloat(val.value);
      						}
      						else{
      							error('no number in row '+(i+1)+' column '+(j+1) + '; found: "'+val.value+'"');
      						}
      						break;

      					case 'string':
      						newRow[j] = val.value.toString();
      						break;

      					case 'boolean':
      						newRow[j] = val.value;
      						break;

      					default:
      						throw new Error('should not happen: '+cols[j].type);
      				}
      			}

      			rows.push(newRow);
      		}

      		// check if types are set for all columns (could be missing if table has no rows or only null values in a column)
      		for(var i = 0; i < numCols; i++){
      			if(cols[i].type === null){
      				error('type for column '+cols[i].name+' must be set explicitly');
      			}
      		}


      		return {
      			type: 'table',
      			name: '_inlineRelation'+(inlineTableNum++),
      			columns: cols,
      			rows: rows,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c345 = peg$otherExpectation("boolean expression"),
      peg$c346 = function(right) {
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: 'or',
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c347 = "||",
      peg$c348 = peg$literalExpectation("||", false),
      peg$c349 = function(right) {
      		return {
      			type: 'valueExpr',
      			datatype: 'string',
      			func: 'concat',
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c350 = function(right) {
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: 'xor',
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c351 = function(right) {
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: 'and',
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c352 = function(o, right) {
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: o,
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c353 = "like",
      peg$c354 = peg$literalExpectation("like", true),
      peg$c355 = "ilike",
      peg$c356 = peg$literalExpectation("ilike", true),
      peg$c357 = function(o, right) {
      		if(right.datatype !== 'string'){
      			error(t('db.messages.parser.error-valueexpr-like-operand-no-string'));
      		}
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: o.toLowerCase(),
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c358 = "+",
      peg$c359 = peg$literalExpectation("+", false),
      peg$c360 = function(o, right) {
      		o = {
      			'+': 'add',
      			'-': 'sub'
      		}[o];

      		return {
      			type: 'valueExpr',
      			datatype: 'number',
      			func: o,
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c361 = "*",
      peg$c362 = peg$literalExpectation("*", false),
      peg$c363 = "%",
      peg$c364 = peg$literalExpectation("%", false),
      peg$c365 = function(o, right) {
      		o = {
      			'*': 'mul',
      			'/': 'div',
      			'%': 'mod'
      		}[o];

      		return {
      			type: 'valueExpr',
      			datatype: 'number',
      			func: o,
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c366 = function(a) {
      		return {
      			type: 'valueExpr',
      			datatype: 'number',
      			func: 'minus',
      			args: [a],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c367 = function(a) {
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: 'not',
      			args: [a],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c368 = "coalesce",
      peg$c369 = peg$literalExpectation("coalesce", true),
      peg$c370 = function() { return ['coalesce', 'null']; },
      peg$c371 = "concat",
      peg$c372 = peg$literalExpectation("concat", true),
      peg$c373 = function() { return ['concat', 'string']; },
      peg$c374 = function(func, arg0, argn) {
      		var args = [arg0];
      		for(var i = 0; i < argn.length; i++){
      			args.push(argn[i][2]);
      		}

      		return {
      			type: 'valueExpr',
      			datatype: func[1],
      			func: func[0],
      			args: args,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c375 = "adddate",
      peg$c376 = peg$literalExpectation("adddate", true),
      peg$c377 = function() { return ['adddate', 'date']; },
      peg$c378 = "subdate",
      peg$c379 = peg$literalExpectation("subdate", true),
      peg$c380 = function() { return ['subdate', 'date']; },
      peg$c381 = "mod",
      peg$c382 = peg$literalExpectation("mod", true),
      peg$c383 = function() { return ['mod', 'number']; },
      peg$c384 = "add",
      peg$c385 = peg$literalExpectation("add", true),
      peg$c386 = function() { return ['add', 'number']; },
      peg$c387 = "sub",
      peg$c388 = peg$literalExpectation("sub", true),
      peg$c389 = function() { return ['sub', 'number']; },
      peg$c390 = "mul",
      peg$c391 = peg$literalExpectation("mul", true),
      peg$c392 = function() { return ['mul', 'number']; },
      peg$c393 = "div",
      peg$c394 = peg$literalExpectation("div", true),
      peg$c395 = function() { return ['div', 'number']; },
      peg$c396 = function(func, arg0, arg1) {
      		return {
      			type: 'valueExpr',
      			datatype: func[1],
      			func: func[0],
      			args: [arg0, arg1],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c397 = "upper",
      peg$c398 = peg$literalExpectation("upper", true),
      peg$c399 = function() { return ['upper', 'string']; },
      peg$c400 = "ucase",
      peg$c401 = peg$literalExpectation("ucase", true),
      peg$c402 = "lower",
      peg$c403 = peg$literalExpectation("lower", true),
      peg$c404 = function() { return ['lower', 'string']; },
      peg$c405 = "lcase",
      peg$c406 = peg$literalExpectation("lcase", true),
      peg$c407 = "length",
      peg$c408 = peg$literalExpectation("length", true),
      peg$c409 = function() { return ['strlen', 'number']; },
      peg$c410 = "abs",
      peg$c411 = peg$literalExpectation("abs", true),
      peg$c412 = function() { return ['abs', 'number']; },
      peg$c413 = "floor",
      peg$c414 = peg$literalExpectation("floor", true),
      peg$c415 = function() { return ['floor', 'number']; },
      peg$c416 = "ceil",
      peg$c417 = peg$literalExpectation("ceil", true),
      peg$c418 = function() { return ['ceil', 'number']; },
      peg$c419 = "round",
      peg$c420 = peg$literalExpectation("round", true),
      peg$c421 = function() { return ['round', 'number']; },
      peg$c422 = function() { return ['date', 'date']; },
      peg$c423 = "year",
      peg$c424 = peg$literalExpectation("year", true),
      peg$c425 = function() { return ['year', 'number']; },
      peg$c426 = "month",
      peg$c427 = peg$literalExpectation("month", true),
      peg$c428 = function() { return ['month', 'number']; },
      peg$c429 = "day",
      peg$c430 = peg$literalExpectation("day", true),
      peg$c431 = function() { return ['dayofmonth', 'number']; },
      peg$c432 = "hour",
      peg$c433 = peg$literalExpectation("hour", true),
      peg$c434 = function() { return ['hour', 'number']; },
      peg$c435 = "minute",
      peg$c436 = peg$literalExpectation("minute", true),
      peg$c437 = function() { return ['minute', 'number']; },
      peg$c438 = "second",
      peg$c439 = peg$literalExpectation("second", true),
      peg$c440 = function() { return ['second', 'number']; },
      peg$c441 = "dayofmonth",
      peg$c442 = peg$literalExpectation("dayofmonth", true),
      peg$c443 = function(func, arg0) {
      		return {
      			type: 'valueExpr',
      			datatype: func[1],
      			func: func[0],
      			args: [arg0],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c444 = "rand",
      peg$c445 = peg$literalExpectation("rand", true),
      peg$c446 = function() { return ['rand', 'number']; },
      peg$c447 = "rownum",
      peg$c448 = peg$literalExpectation("rownum", true),
      peg$c449 = function() { return ['rownum', 'number']; },
      peg$c450 = "now",
      peg$c451 = peg$literalExpectation("now", true),
      peg$c452 = function() { return ['now', 'date']; },
      peg$c453 = "current_timestamp",
      peg$c454 = peg$literalExpectation("current_timestamp", true),
      peg$c455 = "transaction_timestamp",
      peg$c456 = peg$literalExpectation("transaction_timestamp", true),
      peg$c457 = function() { return ['transaction_timestamp', 'date']; },
      peg$c458 = "statement_timestamp",
      peg$c459 = peg$literalExpectation("statement_timestamp", true),
      peg$c460 = function() { return ['statement_timestamp', 'date']; },
      peg$c461 = "clock_timestamp",
      peg$c462 = peg$literalExpectation("clock_timestamp", true),
      peg$c463 = function() { return ['clock_timestamp', 'date']; },
      peg$c464 = "sysdate",
      peg$c465 = peg$literalExpectation("sysdate", true),
      peg$c466 = function(func) {
      		return {
      			type: 'valueExpr',
      			datatype: func[1],
      			func: func[0],
      			args: [],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c467 = function(v) { return [v, 'number']; },
      peg$c468 = function(v) { return [v, 'boolean']; },
      peg$c469 = function(v) { return [v, 'string']; },
      peg$c470 = function(a) {
      		return {
      			type: 'valueExpr',
      			datatype: a[1],
      			func: 'constant',
      			args: [a[0]],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c471 = peg$literalExpectation("null", true),
      peg$c472 = function(a) {
      		return {
      			type: 'valueExpr',
      			datatype: 'null',
      			func: 'constant',
      			args: [null],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c473 = function(a) {
      		return {
      			type: 'valueExpr',
      			datatype: 'null',
      			func: 'columnValue',
      			args: [a.name, a.relAlias],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c474 = "case",
      peg$c475 = peg$literalExpectation("case", true),
      peg$c476 = "when",
      peg$c477 = peg$literalExpectation("when", true),
      peg$c478 = "then",
      peg$c479 = peg$literalExpectation("then", true),
      peg$c480 = function(c, r) { return {w: c, t:r} },
      peg$c481 = "else",
      peg$c482 = peg$literalExpectation("else", true),
      peg$c483 = function(wt, r) { return r },
      peg$c484 = "end",
      peg$c485 = peg$literalExpectation("end", true),
      peg$c486 = function(wt, e) {
      		var args = [], i;
      		for(i = 0; i < wt.length; i++){
      			// when on i%2 === 0
      			args.push(wt[i].w);

      			// then on i%2 === 1
      			args.push(wt[i].t);
      		}

      		// else part
      		if(e !== null){
      			// when on i%2 === 0
      			// constant true is used to give all args a unified interface
      			args.push({
      				type: 'valueExpr',
      				datatype: 'boolean',
      				func: 'constant',
      				args: [true],

      				codeInfo: getCodeInfo()
      			});

      			// then on i%2 === 1
      			args.push(e);
      		}

      		return {
      			type: 'valueExpr',
      			datatype: 'null',
      			func: e === null ? 'caseWhen' : 'caseWhenElse',
      			args: args,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c487 = function(first, rest) { return buildBinaryValueExpr(first, rest); },
      peg$c488 = "not",
      peg$c489 = peg$literalExpectation("not", true),
      peg$c490 = "natual",
      peg$c491 = peg$literalExpectation("natual", true),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsestart() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseroot();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsegroupStart() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parsegroupRoot();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseEOF() {
    var s0, s1;

    s0 = peg$currPos;
    peg$silentFails++;
    if (input.length > peg$currPos) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1); }
    }
    peg$silentFails--;
    if (s1 === peg$FAILED) {
      s0 = void 0;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseendOfLine() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c2) {
      s0 = peg$c2;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c3); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c4;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
    }

    return s0;
  }

  function peg$parsecomment() {
    var s0;

    s0 = peg$parsesingleLineComment();
    if (s0 === peg$FAILED) {
      s0 = peg$parsemultiLineComment();
    }

    return s0;
  }

  function peg$parsesingleLineComment() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c7) {
      s1 = peg$c7;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c8); }
    }
    if (s1 !== peg$FAILED) {
      if (peg$c9.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c10); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseendOfLine();
        if (s4 === peg$FAILED) {
          s4 = peg$parseEOF();
        }
        peg$silentFails--;
        if (s4 !== peg$FAILED) {
          peg$currPos = s3;
          s3 = void 0;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c7) {
        s1 = peg$c7;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseendOfLine();
        if (s3 === peg$FAILED) {
          s3 = peg$parseEOF();
        }
        peg$silentFails--;
        if (s3 !== peg$FAILED) {
          peg$currPos = s2;
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c7) {
          s1 = peg$c7;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        if (s1 !== peg$FAILED) {
          if (peg$c9.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c10); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseendOfLine();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c1); }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parseendOfLine();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c1); }
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            if (s4 !== peg$FAILED) {
              s3 = input.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseendOfLine();
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              peg$silentFails--;
              if (s5 !== peg$FAILED) {
                peg$currPos = s4;
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c6); }
    }

    return s0;
  }

  function peg$parsemultiLineComment() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c13) {
      s1 = peg$c13;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c14); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      s4 = peg$currPos;
      s5 = peg$currPos;
      peg$silentFails++;
      if (input.substr(peg$currPos, 2) === peg$c15) {
        s6 = peg$c15;
        peg$currPos += 2;
      } else {
        s6 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }
      peg$silentFails--;
      if (s6 === peg$FAILED) {
        s5 = void 0;
      } else {
        peg$currPos = s5;
        s5 = peg$FAILED;
      }
      if (s5 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1); }
        }
        if (s6 !== peg$FAILED) {
          s5 = [s5, s6];
          s4 = s5;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c15) {
          s6 = peg$c15;
          peg$currPos += 2;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c16); }
        }
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = void 0;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c1); }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c15) {
          s3 = peg$c15;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c16); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c12(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parse__() {
    var s0, s1, s2, s3, s4, s5, s6;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = [];
    s4 = peg$parsecomment();
    while (s4 !== peg$FAILED) {
      s3.push(s4);
      s4 = peg$parsecomment();
    }
    if (s3 !== peg$FAILED) {
      s4 = [];
      if (peg$c18.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c19); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c18.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c19); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = [];
        s6 = peg$parsecomment();
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          s6 = peg$parsecomment();
        }
        if (s5 !== peg$FAILED) {
          s3 = [s3, s4, s5];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$parsecomment();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsecomment();
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c18.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c19); }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c18.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c19); }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsecomment();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsecomment();
            }
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c11();
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c17); }
    }

    return s0;
  }

  function peg$parse_() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    s1 = peg$parsecomment();
    if (s1 === peg$FAILED) {
      if (peg$c18.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c19); }
      }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parsecomment();
      if (s1 === peg$FAILED) {
        if (peg$c18.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c19); }
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c20); }
    }

    return s0;
  }

  function peg$parse__nc() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c22.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c23); }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c22.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c23); }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c21); }
    }

    return s0;
  }

  function peg$parse_nc() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c22.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c23); }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      if (peg$c22.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c23); }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c24); }
    }

    return s0;
  }

  function peg$parse__sl() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = [];
    s4 = peg$parsecomment();
    while (s4 !== peg$FAILED) {
      s3.push(s4);
      s4 = peg$parsecomment();
    }
    if (s3 !== peg$FAILED) {
      s4 = [];
      if (peg$c9.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c10); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c9.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c10); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = [];
        s6 = peg$parsecomment();
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          s6 = peg$parsecomment();
        }
        if (s5 !== peg$FAILED) {
          s3 = [s3, s4, s5];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$parsecomment();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsecomment();
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c9.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c10); }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c9.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c10); }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsecomment();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsecomment();
            }
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c11();
    }
    s0 = s1;

    return s0;
  }

  function peg$parse_sl() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsecomment();
    if (s2 === peg$FAILED) {
      if (peg$c9.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c10); }
      }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsecomment();
      if (s2 === peg$FAILED) {
        if (peg$c9.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c11();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsestring() {
    var s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c26;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c27); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$c28.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c29); }
      }
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        if (peg$c28.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c29); }
        }
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c26;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c27); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c30(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c25); }
    }

    return s0;
  }

  function peg$parseinteger() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s3 = peg$c31;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c32); }
    }
    if (s3 === peg$FAILED) {
      s3 = null;
    }
    if (s3 !== peg$FAILED) {
      s4 = [];
      if (peg$c33.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c33.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c35(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsefloat() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s3 = peg$c31;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c32); }
    }
    if (s3 === peg$FAILED) {
      s3 = null;
    }
    if (s3 !== peg$FAILED) {
      s4 = [];
      if (peg$c33.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c33.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s5 = peg$c36;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        if (s5 !== peg$FAILED) {
          s6 = [];
          if (peg$c33.test(input.charAt(peg$currPos))) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s7 !== peg$FAILED) {
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              if (peg$c33.test(input.charAt(peg$currPos))) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c34); }
              }
            }
          } else {
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            s3 = [s3, s4, s5, s6];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c38(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsenumber() {
    var s0;

    s0 = peg$parsefloat();
    if (s0 === peg$FAILED) {
      s0 = peg$parseinteger();
    }

    return s0;
  }

  function peg$parsedateIso() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$currPos;
    if (peg$c33.test(input.charAt(peg$currPos))) {
      s3 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c34); }
    }
    if (s3 !== peg$FAILED) {
      if (peg$c33.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s4 !== peg$FAILED) {
        if (peg$c33.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c34); }
        }
        if (s5 !== peg$FAILED) {
          if (peg$c33.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s6 !== peg$FAILED) {
            s3 = [s3, s4, s5, s6];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c31;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$currPos;
        if (peg$c33.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c34); }
        }
        if (s5 !== peg$FAILED) {
          if (peg$c33.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = input.substring(s3, peg$currPos);
        } else {
          s3 = s4;
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s4 = peg$c31;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c32); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$currPos;
            if (peg$c33.test(input.charAt(peg$currPos))) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c34); }
            }
            if (s7 !== peg$FAILED) {
              if (peg$c33.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c34); }
              }
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s5 = input.substring(s5, peg$currPos);
            } else {
              s5 = s6;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c40(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c39); }
    }

    return s0;
  }

  function peg$parseboolean() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c41) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c42); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c43();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c44) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c46();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseassignmentOperator() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 61) {
        s2 = peg$c47;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c48); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetestQueryOperator() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c31;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parserelationName() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parseRESERVED_KEYWORD_RELALG();
    if (s3 !== peg$FAILED) {
      s4 = peg$currPos;
      peg$silentFails++;
      s5 = [];
      if (peg$c50.test(input.charAt(peg$currPos))) {
        s6 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s6 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s6 !== peg$FAILED) {
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
        }
      } else {
        s5 = peg$FAILED;
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = [];
      if (peg$c52.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c52.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$currPos;
        s6 = [];
        if (peg$c50.test(input.charAt(peg$currPos))) {
          s7 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s7 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c51); }
        }
        while (s7 !== peg$FAILED) {
          s6.push(s7);
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
        }
        if (s6 !== peg$FAILED) {
          s5 = input.substring(s5, peg$currPos);
        } else {
          s5 = s6;
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c49); }
    }

    return s0;
  }

  function peg$parseunqualifiedColumnName() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parseRESERVED_KEYWORD_RELALG();
    if (s3 !== peg$FAILED) {
      s4 = peg$currPos;
      peg$silentFails++;
      s5 = [];
      if (peg$c50.test(input.charAt(peg$currPos))) {
        s6 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s6 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s6 !== peg$FAILED) {
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
        }
      } else {
        s5 = peg$FAILED;
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = [];
      if (peg$c52.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c52.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$currPos;
        s6 = [];
        if (peg$c50.test(input.charAt(peg$currPos))) {
          s7 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s7 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c51); }
        }
        while (s7 !== peg$FAILED) {
          s6.push(s7);
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
        }
        if (s6 !== peg$FAILED) {
          s5 = input.substring(s5, peg$currPos);
        } else {
          s5 = s6;
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecolumnName() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parserelationName();
    if (s2 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 46) {
        s3 = peg$c36;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c37); }
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseunqualifiedColumnName();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c55(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parserelationName();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c36;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 91) {
          s2 = peg$c56;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c57); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = [];
          if (peg$c33.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c33.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c34); }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s3 = input.substring(s3, peg$currPos);
          } else {
            s3 = s4;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s4 = peg$c58;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c59); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c60(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsepi() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 960) {
        s3 = peg$c61;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c62); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c63();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c65) {
          s3 = input.substr(peg$currPos, 2);
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c66); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c63();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsesigma() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 963) {
        s3 = peg$c67;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c68); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c69();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c70) {
          s3 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c71); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c69();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parserho() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 961) {
        s3 = peg$c72;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c73); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c74();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c75) {
          s3 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c76); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c74();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsearrowLeft() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 8592) {
        s3 = peg$c77;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c78); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c79();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c80) {
          s3 = peg$c80;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c81); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c79();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsearrowRight() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 8594) {
        s3 = peg$c82;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c84();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c85) {
          s3 = peg$c85;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c86); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c84();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsepsi() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 968) {
        s3 = peg$c87;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c88); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c89();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c90) {
          s3 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c91); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c89();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsetau() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 964) {
        s3 = peg$c92;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c93); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c94();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c95) {
          s3 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c96); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c94();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsegamma() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 947) {
        s3 = peg$c97;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c98); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c99();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c100) {
          s3 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c101); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c99();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseunionOperator() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 8746) {
        s3 = peg$c102;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c103); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c104();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c105) {
          s3 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c106); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c104();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseintersectOperator() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 8745) {
        s3 = peg$c107;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c108); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c109();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c110) {
          s3 = input.substr(peg$currPos, 9);
          peg$currPos += 9;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c111); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c109();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsedivisionOperator() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 247) {
        s3 = peg$c112;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c113); }
      }
      if (s3 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s3 = peg$c114;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c115); }
        }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c116();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsedifferenceOperator() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s3 = peg$c31;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s3 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c117;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c118); }
        }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c119();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c120) {
          s3 = input.substr(peg$currPos, 6);
          peg$currPos += 6;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c121); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c119();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsecrossJoinOperator() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 10799) {
        s3 = peg$c122;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c123); }
      }
      if (s3 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 120) {
          s3 = peg$c124;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c125); }
        }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c126();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c127) {
          s4 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c128); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c130); }
            }
            if (s6 !== peg$FAILED) {
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c126();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseinnerJoinOperator() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 10781) {
        s3 = peg$c131;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c132); }
      }
      if (s3 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 8904) {
          s3 = peg$c133;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c134); }
        }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c135();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        s4 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c136) {
          s5 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c137); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
            s5 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c130); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c135();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsenaturalJoinOperator() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 10781) {
        s3 = peg$c131;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c132); }
      }
      if (s3 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 8904) {
          s3 = peg$c133;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c134); }
        }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c138();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        s4 = peg$currPos;
        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c139) {
          s5 = input.substr(peg$currPos, 7);
          peg$currPos += 7;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c140); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
            s5 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c130); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c138();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseleftSemiJoinOperator() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 8905) {
        s3 = peg$c141;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c142); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c143();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c144) {
          s4 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c145); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c146) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c147); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse__();
              if (s7 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
                  s8 = input.substr(peg$currPos, 4);
                  peg$currPos += 4;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c130); }
                }
                if (s8 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7, s8];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c143();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parserightSemiJoinOperator() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 8906) {
        s3 = peg$c148;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c149); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c150();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c151) {
          s4 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c152); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c146) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c147); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse__();
              if (s7 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
                  s8 = input.substr(peg$currPos, 4);
                  peg$currPos += 4;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c130); }
                }
                if (s8 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7, s8];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c150();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseantiJoinOperator() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 9655) {
        s3 = peg$c153;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c154); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c155();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c156) {
          s4 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c157); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c146) {
              s7 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c147); }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
                s7 = input.substr(peg$currPos, 4);
                peg$currPos += 4;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c130); }
              }
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c155();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseleftOuterJoinOperator() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 10197) {
        s3 = peg$c158;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c159); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c160();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c144) {
          s4 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c145); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {
              s7 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c162); }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
                s7 = input.substr(peg$currPos, 4);
                peg$currPos += 4;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c130); }
              }
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c160();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parserightOuterJoinOperator() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 10198) {
        s3 = peg$c163;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c164); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c165();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c151) {
          s4 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c152); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {
              s7 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c162); }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
                s7 = input.substr(peg$currPos, 4);
                peg$currPos += 4;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c130); }
              }
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c165();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsefullOuterJoinOperator() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 10199) {
        s3 = peg$c166;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c167); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c168();
      }
      s2 = s3;
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c169) {
          s4 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c170); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {
              s7 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c162); }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
                s7 = input.substr(peg$currPos, 4);
                peg$currPos += 4;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c130); }
              }
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c168();
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseassignment() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parserelationName();
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c171(s1);
      if (s2) {
        s2 = peg$FAILED;
      } else {
        s2 = void 0;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseassignmentOperator();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpression_precedence4();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c172(s1, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenamedColumnExpr() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence9();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsearrowRight();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseunqualifiedColumnName();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c173(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseunqualifiedColumnName();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsearrowLeft();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexpr_precedence9();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c174(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsecolumnName();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c54(s1);
        }
        s0 = s1;
      }
    }

    return s0;
  }

  function peg$parselistOfNamedColumnExpressions() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parsenamedColumnExpr();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c175;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c176); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsenamedColumnExpr();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c175;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c176); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsenamedColumnExpr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c177(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parselistOfColumns() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parsecolumnName();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c175;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c176); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecolumnName();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c175;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c176); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecolumnName();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c177(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecolAssignment() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseunqualifiedColumnName();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsearrowLeft();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecolumnName();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c178(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsecolumnName();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsearrowRight();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseunqualifiedColumnName();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c179(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parselistOfColAssignments() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parsecolAssignment();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c175;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c176); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecolAssignment();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c175;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c176); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecolAssignment();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c180(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseorderDirection() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c181) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c182); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c43();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c183) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c184); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c46();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseorderByArg() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsecolumnName();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseorderDirection();
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c185(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parselistOfOrderByArgs() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseorderByArg();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c175;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c176); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseorderByArg();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c175;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c176); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseorderByArg();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c180(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseaggFunction() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c186) {
      s2 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c187); }
    }
    if (s2 === peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c188) {
        s2 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c189); }
      }
      if (s2 === peg$FAILED) {
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c190) {
          s2 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c191); }
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c192) {
            s2 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c193); }
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c194) {
              s2 = input.substr(peg$currPos, 3);
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c195); }
            }
          }
        }
      }
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c196;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c197); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsecolumnName();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c198;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c199); }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c200(s1, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c201) {
        s1 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c202); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c203();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseaggFunctionArgument() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseaggFunction();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsearrowRight();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseunqualifiedColumnName();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c204(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseunqualifiedColumnName();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsearrowLeft();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseaggFunction();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c205(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parselistOfAggFunctionArguments() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseaggFunctionArgument();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c175;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c176); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseaggFunctionArgument();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c175;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c176); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseaggFunctionArgument();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c177(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsebooleanExprWithTrailingWhitspace() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsebooleanExpr();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s3 = peg$c206(s1);
        if (s3) {
          s3 = void 0;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c30(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseroot() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseassignment();
      if (s4 !== peg$FAILED) {
        s5 = peg$parse__();
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseassignment();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseassignment();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c207(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseassignment();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseassignment();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexpression_precedence4();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c208(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsegroupRoot() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parse_nc();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_nc();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsetableGroup();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_nc();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetableGroup();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_nc();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c209(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetableGroupHeaders() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parsetableGroupHeader();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parsetableGroupHeader();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsetableGroupHeader();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c210(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseisoLanguageCode() {
    var s0, s1, s2, s3, s4;

    if (input.substr(peg$currPos, 2) === peg$c211) {
      s0 = peg$c211;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c212); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c213) {
        s0 = peg$c213;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c214); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c215) {
          s0 = peg$c215;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c216); }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          if (peg$c52.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
          if (s3 !== peg$FAILED) {
            if (peg$c52.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c53); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s2;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c217(s1);
          }
          s0 = s1;
        }
      }
    }

    return s0;
  }

  function peg$parseexampleSql() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = [];
    if (input.substr(peg$currPos, 10) === peg$c218) {
      s3 = peg$c218;
      peg$currPos += 10;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c219); }
    }
    if (s3 !== peg$FAILED) {
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (input.substr(peg$currPos, 10) === peg$c218) {
          s3 = peg$c218;
          peg$currPos += 10;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c219); }
        }
      }
    } else {
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      if (input.substr(peg$currPos, 4) === peg$c220) {
        s3 = peg$c220;
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c221); }
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$c222.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c223); }
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c222.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c223); }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 125) {
          s3 = peg$c224;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c225); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c226(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexampleQueryRelAlg() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = [];
    if (input.substr(peg$currPos, 13) === peg$c227) {
      s3 = peg$c227;
      peg$currPos += 13;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c228); }
    }
    if (s3 !== peg$FAILED) {
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (input.substr(peg$currPos, 13) === peg$c227) {
          s3 = peg$c227;
          peg$currPos += 13;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c228); }
        }
      }
    } else {
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      if (input.substr(peg$currPos, 4) === peg$c220) {
        s3 = peg$c220;
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c221); }
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$c222.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c223); }
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c222.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c223); }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 125) {
          s3 = peg$c224;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c225); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c229(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetableGroupHeader() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = [];
    if (peg$c230.test(input.charAt(peg$currPos))) {
      s4 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s4 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c231); }
    }
    if (s4 !== peg$FAILED) {
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        if (peg$c230.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c231); }
        }
      }
    } else {
      s3 = peg$FAILED;
    }
    if (s3 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 58) {
        s4 = peg$c232;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c233); }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 !== peg$FAILED) {
      peg$currPos = s1;
      s1 = void 0;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$c234.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c235); }
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c234.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c235); }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
          s4 = peg$c236;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c237); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseisoLanguageCode();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c232;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c233); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$currPos;
            s8 = peg$currPos;
            peg$silentFails++;
            s9 = peg$parseendOfLine();
            peg$silentFails--;
            if (s9 === peg$FAILED) {
              s8 = void 0;
            } else {
              peg$currPos = s8;
              s8 = peg$FAILED;
            }
            if (s8 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s9 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c1); }
              }
              if (s9 !== peg$FAILED) {
                s8 = [s8, s9];
                s7 = s8;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$currPos;
              s8 = peg$currPos;
              peg$silentFails++;
              s9 = peg$parseendOfLine();
              peg$silentFails--;
              if (s9 === peg$FAILED) {
                s8 = void 0;
              } else {
                peg$currPos = s8;
                s8 = peg$FAILED;
              }
              if (s8 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s9 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c1); }
                }
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = input.substring(s5, peg$currPos);
            } else {
              s5 = s6;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c238(s2, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$currPos;
      s3 = [];
      if (peg$c230.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c231); }
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c230.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c231); }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c239) {
          s4 = peg$c239;
          peg$currPos += 2;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c240); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      peg$silentFails--;
      if (s2 !== peg$FAILED) {
        peg$currPos = s1;
        s1 = void 0;
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        if (peg$c234.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c235); }
        }
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c234.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c235); }
            }
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = input.substring(s2, peg$currPos);
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 64) {
            s4 = peg$c236;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c237); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseisoLanguageCode();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c239) {
              s4 = peg$c239;
              peg$currPos += 2;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c240); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = [];
              if (input.substr(peg$currPos, 3) === peg$c241) {
                s7 = peg$c241;
                peg$currPos += 3;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c242); }
              }
              if (s7 === peg$FAILED) {
                s7 = peg$currPos;
                s8 = peg$currPos;
                peg$silentFails++;
                if (input.substr(peg$currPos, 2) === peg$c243) {
                  s9 = peg$c243;
                  peg$currPos += 2;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c244); }
                }
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = void 0;
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                if (s8 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s9 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c1); }
                  }
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              }
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                if (input.substr(peg$currPos, 3) === peg$c241) {
                  s7 = peg$c241;
                  peg$currPos += 3;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c242); }
                }
                if (s7 === peg$FAILED) {
                  s7 = peg$currPos;
                  s8 = peg$currPos;
                  peg$silentFails++;
                  if (input.substr(peg$currPos, 2) === peg$c243) {
                    s9 = peg$c243;
                    peg$currPos += 2;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c244); }
                  }
                  peg$silentFails--;
                  if (s9 === peg$FAILED) {
                    s8 = void 0;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s9 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c1); }
                    }
                    if (s9 !== peg$FAILED) {
                      s8 = [s8, s9];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = input.substring(s5, peg$currPos);
              } else {
                s5 = s6;
              }
              if (s5 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c243) {
                  s6 = peg$c243;
                  peg$currPos += 2;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c244); }
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c245(s2, s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsetableGroup() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsetableGroupHeaders();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$currPos;
        s5 = peg$parse__();
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parseexampleSql();
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$currPos;
          s5 = peg$parse__();
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseexampleSql();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parse__();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$parseexampleQueryRelAlg();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$parse__();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parseexampleQueryRelAlg();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$parse__();
            if (s7 === peg$FAILED) {
              s7 = null;
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parseassignment();
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$currPos;
                s7 = peg$parse__();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseassignment();
                  if (s8 !== peg$FAILED) {
                    s7 = [s7, s8];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c246(s2, s3, s4, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_precedence4() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpression_precedence3();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseunion();
      if (s3 === peg$FAILED) {
        s3 = peg$parsedifference();
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseunion();
          if (s3 === peg$FAILED) {
            s3 = peg$parsedifference();
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c247(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpression_precedence3();
    }

    return s0;
  }

  function peg$parseexpression_precedence3() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpression_precedence2();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseintersect();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseintersect();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c247(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpression_precedence2();
    }

    return s0;
  }

  function peg$parseexpression_precedence2() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpression_precedence1();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsecrossJoin();
      if (s3 === peg$FAILED) {
        s3 = peg$parsethetaJoin();
        if (s3 === peg$FAILED) {
          s3 = peg$parsenaturalJoin();
          if (s3 === peg$FAILED) {
            s3 = peg$parseleftOuterJoin();
            if (s3 === peg$FAILED) {
              s3 = peg$parserightOuterJoin();
              if (s3 === peg$FAILED) {
                s3 = peg$parsefullOuterJoin();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseleftSemiJoin();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parserightSemiJoin();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parseantiJoin();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parsedivision();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsecrossJoin();
          if (s3 === peg$FAILED) {
            s3 = peg$parsethetaJoin();
            if (s3 === peg$FAILED) {
              s3 = peg$parsenaturalJoin();
              if (s3 === peg$FAILED) {
                s3 = peg$parseleftOuterJoin();
                if (s3 === peg$FAILED) {
                  s3 = peg$parserightOuterJoin();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parsefullOuterJoin();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parseleftSemiJoin();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parserightSemiJoin();
                        if (s3 === peg$FAILED) {
                          s3 = peg$parseantiJoin();
                          if (s3 === peg$FAILED) {
                            s3 = peg$parsedivision();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c247(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpression_precedence1();
    }

    return s0;
  }

  function peg$parseexpression_precedence1() {
    var s0;

    s0 = peg$parseorderBy();
    if (s0 === peg$FAILED) {
      s0 = peg$parsegroupBy();
      if (s0 === peg$FAILED) {
        s0 = peg$parserenameRelation();
        if (s0 === peg$FAILED) {
          s0 = peg$parserenameColumns();
          if (s0 === peg$FAILED) {
            s0 = peg$parseselection();
            if (s0 === peg$FAILED) {
              s0 = peg$parseprojection();
              if (s0 === peg$FAILED) {
                s0 = peg$parseexpression_precedence0();
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseexpression_precedence0() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$parsetable();
    if (s0 === peg$FAILED) {
      s0 = peg$parserelation();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c196;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c197); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexpression_precedence4();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c198;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c199); }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c248(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parseintersect() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseintersectOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_precedence2();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c249(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseunion() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseunionOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_precedence3();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c250(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsedifference() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsedifferenceOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_precedence3();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c251(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecrossJoin() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsecrossJoinOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_precedence1();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c252(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsethetaJoin() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseinnerJoinOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsebooleanExprWithTrailingWhitspace();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpression_precedence1();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c253(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenaturalJoin() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsenaturalJoinOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_precedence1();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c254(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseleftOuterJoin() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseleftOuterJoinOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsebooleanExprWithTrailingWhitspace();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpression_precedence1();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c255(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parserightOuterJoin() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parserightOuterJoinOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsebooleanExprWithTrailingWhitspace();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpression_precedence1();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c256(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsefullOuterJoin() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsefullOuterJoinOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsebooleanExprWithTrailingWhitspace();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpression_precedence1();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c257(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseleftSemiJoin() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseleftSemiJoinOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_precedence1();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c258(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parserightSemiJoin() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parserightSemiJoinOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_precedence1();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c259(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseantiJoin() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseantiJoinOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsebooleanExprWithTrailingWhitspace();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpression_precedence1();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c260(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsedivision() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsedivisionOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_precedence1();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c261(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseprojection() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsepi();
    if (s1 !== peg$FAILED) {
      s2 = peg$parselistOfNamedColumnExpressions();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpression_precedence1();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c262(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselection() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsesigma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsebooleanExpr();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpression_precedence1();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c263(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parserenameColumns() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parserho();
    if (s1 !== peg$FAILED) {
      s2 = peg$parselistOfColAssignments();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpression_precedence1();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c264(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parserenameRelation() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parserho();
    if (s1 !== peg$FAILED) {
      s2 = peg$parserelationName();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpression_precedence1();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c265(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsegroupBy() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$parsegamma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parselistOfColumns();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 59) {
            s4 = peg$c266;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c267); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parselistOfAggFunctionArguments();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse__();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseexpression_precedence1();
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c268(s1, s2, s6, s8);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsegamma();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 59) {
            s4 = peg$c266;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c267); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parselistOfAggFunctionArguments();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse__();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseexpression_precedence1();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c269(s1, s4, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseorderBy() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsetau();
    if (s1 !== peg$FAILED) {
      s2 = peg$parselistOfOrderByArgs();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpression_precedence1();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c270(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parserelation() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parserelationName();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c271(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecomparisonOperators() {
    var s0;

    s0 = peg$parsecomparisonOperatorEquals();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecomparisonOperatorNotEquals();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecomparisonOperatorGreaterEquals();
        if (s0 === peg$FAILED) {
          s0 = peg$parsecomparisonOperatorLesserEquals();
          if (s0 === peg$FAILED) {
            s0 = peg$parsecomparisonOperatorGreater();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecomparisonOperatorLesser();
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsecomparisonOperatorsIsOrIsNot() {
    var s0;

    s0 = peg$parsecomparisonOperatorEquals();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecomparisonOperatorNotEquals();
    }

    return s0;
  }

  function peg$parsecomparisonOperatorEquals() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 61) {
      s0 = peg$c47;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c48); }
    }

    return s0;
  }

  function peg$parsecomparisonOperatorNotEquals() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c272) {
      s1 = peg$c272;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c273); }
    }
    if (s1 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 8800) {
        s1 = peg$c274;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c275); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c276) {
          s1 = peg$c276;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c277); }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c278();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecomparisonOperatorGreaterEquals() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c279) {
      s1 = peg$c279;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c280); }
    }
    if (s1 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 8805) {
        s1 = peg$c281;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c282); }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c283();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecomparisonOperatorGreater() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 62) {
      s0 = peg$c284;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c285); }
    }

    return s0;
  }

  function peg$parsecomparisonOperatorLesserEquals() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c286) {
      s1 = peg$c286;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c287); }
    }
    if (s1 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 8804) {
        s1 = peg$c288;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c289); }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c290();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecomparisonOperatorLesser() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 60) {
      s0 = peg$c291;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c292); }
    }

    return s0;
  }

  function peg$parseand() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c294) {
        s2 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c295); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 8743) {
          s2 = peg$c296;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c297); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c293); }
    }

    return s0;
  }

  function peg$parsexor() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c299) {
        s2 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c300); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 8891) {
          s2 = peg$c301;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c302); }
        }
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 8853) {
            s2 = peg$c303;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c304); }
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c298); }
    }

    return s0;
  }

  function peg$parseor() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c306) {
        s2 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c307); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 8744) {
          s2 = peg$c308;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c309); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c305); }
    }

    return s0;
  }

  function peg$parsenot() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 33) {
        s2 = peg$c311;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c312); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 172) {
          s2 = peg$c313;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c314); }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c310); }
    }

    return s0;
  }

  function peg$parsetableDelimiter() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_sl();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 44) {
        s2 = peg$c175;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c176); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_sl();
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_sl();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 59) {
          s2 = peg$c266;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c267); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_sl();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parse__sl();
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c315); }
    }

    return s0;
  }

  function peg$parsetableColumnName() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsecolumnName();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s3 = peg$c232;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c233); }
      }
      if (s3 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c316) {
          s4 = input.substr(peg$currPos, 6);
          peg$currPos += 6;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c317); }
        }
        if (s4 === peg$FAILED) {
          if (input.substr(peg$currPos, 6).toLowerCase() === peg$c318) {
            s4 = input.substr(peg$currPos, 6);
            peg$currPos += 6;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c319); }
          }
          if (s4 === peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c320) {
              s4 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c321); }
            }
            if (s4 === peg$FAILED) {
              if (input.substr(peg$currPos, 7).toLowerCase() === peg$c322) {
                s4 = input.substr(peg$currPos, 7);
                peg$currPos += 7;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c323); }
              }
            }
          }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c324(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetableValue() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsedateIso();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c325(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c326) {
        s1 = peg$c326;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c327); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c328) {
          s1 = peg$c328;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c329); }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c330();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseboolean();
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          s3 = peg$parsetableDelimiter();
          if (s3 === peg$FAILED) {
            s3 = peg$parseendOfLine();
            if (s3 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s3 = peg$c224;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c225); }
              }
            }
          }
          peg$silentFails--;
          if (s3 !== peg$FAILED) {
            peg$currPos = s2;
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c331(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];
          if (peg$c332.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c333); }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c332.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c333); }
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s2;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c334(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 39) {
              s1 = peg$c26;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c27); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = [];
              if (peg$c28.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c29); }
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                if (peg$c28.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c29); }
                }
              }
              if (s3 !== peg$FAILED) {
                s2 = input.substring(s2, peg$currPos);
              } else {
                s2 = s3;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s3 = peg$c26;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c27); }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c335(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 34) {
                s1 = peg$c336;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c337); }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];
                if (peg$c338.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c339); }
                }
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c338.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c339); }
                  }
                }
                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 34) {
                    s3 = peg$c336;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c337); }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c335(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsetableHeader() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parsetableColumnName();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parsetableDelimiter();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsetableColumnName();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parsetableDelimiter();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsetableColumnName();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c340(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetableRow() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parsetableValue();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parsetableDelimiter();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsetableValue();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parsetableDelimiter();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsetableValue();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c341(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetable() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c342;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c343); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsetableHeader();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_sl();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$parseendOfLine();
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsetableRow();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parse_sl();
                  if (s10 !== peg$FAILED) {
                    s7 = [s7, s8, s9, s10];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$parseendOfLine();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsetableRow();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse_sl();
                    if (s10 !== peg$FAILED) {
                      s7 = [s7, s8, s9, s10];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s7 = peg$c224;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c225); }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c344(s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsebooleanExpr() {
    var s0, s1;

    peg$silentFails++;
    s0 = peg$parseexpr_precedence9();
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c345); }
    }

    return s0;
  }

  function peg$parseexpr_rest_boolean_disj() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseor();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpr_precedence8();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c346(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_rest_string_concat() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c347) {
        s2 = peg$c347;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c348); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence8();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c349(s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_rest_boolean_xdisj() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsexor();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpr_precedence7();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c350(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_rest_boolean_conj() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseand();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpr_precedence6();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c351(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_rest_boolean_comparison() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecomparisonOperatorsIsOrIsNot();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsevalueExprConstantNull();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c352(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecomparisonOperators();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseexpr_precedence4();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c352(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c353) {
            s2 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c354); }
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c355) {
              s2 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c356); }
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsevalueExprConstants();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c357(s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parseexpr_rest_number_add() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c31;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s2 = peg$c358;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c359); }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence3();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c360(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_rest_number_mul() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 42) {
        s2 = peg$c361;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c362); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s2 = peg$c114;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c115); }
        }
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 37) {
            s2 = peg$c363;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c364); }
          }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence2();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c365(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_number_minus() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c31;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpr_precedence1();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c366(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_boolean_negation() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsenot();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpr_precedence0();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c367(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprFunctionsNary() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c368) {
      s2 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c369); }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = s1;
      s2 = peg$c370();
    }
    s1 = s2;
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c371) {
        s2 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c372); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c373();
      }
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c196;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c197); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence9();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s8 = peg$c175;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c176); }
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parseexpr_precedence9();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parse_();
                    if (s11 !== peg$FAILED) {
                      s8 = [s8, s9, s10, s11];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s8 = peg$c175;
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c176); }
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse_();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parseexpr_precedence9();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse_();
                      if (s11 !== peg$FAILED) {
                        s8 = [s8, s9, s10, s11];
                        s7 = s8;
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              }
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s7 = peg$c198;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c199); }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c374(s1, s4, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprFunctionsBinary() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c375) {
      s2 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c376); }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = s1;
      s2 = peg$c377();
    }
    s1 = s2;
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c378) {
        s2 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c379); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c380();
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c381) {
          s2 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c382); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c383();
        }
        s1 = s2;
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c384) {
            s2 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c385); }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c386();
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c387) {
              s2 = input.substr(peg$currPos, 3);
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c388); }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s1;
              s2 = peg$c389();
            }
            s1 = s2;
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c390) {
                s2 = input.substr(peg$currPos, 3);
                peg$currPos += 3;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c391); }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c392();
              }
              s1 = s2;
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c393) {
                  s2 = input.substr(peg$currPos, 3);
                  peg$currPos += 3;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c394); }
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c395();
                }
                s1 = s2;
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c196;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c197); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence9();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s6 = peg$c175;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c176); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseexpr_precedence9();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s10 = peg$c198;
                        peg$currPos++;
                      } else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c199); }
                      }
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c396(s1, s4, s8);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprFunctionsUnary() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c397) {
      s2 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c398); }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = s1;
      s2 = peg$c399();
    }
    s1 = s2;
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c400) {
        s2 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c401); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c399();
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c402) {
          s2 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c403); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c404();
        }
        s1 = s2;
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c405) {
            s2 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c406); }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c404();
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c407) {
              s2 = input.substr(peg$currPos, 6);
              peg$currPos += 6;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c408); }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s1;
              s2 = peg$c409();
            }
            s1 = s2;
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c410) {
                s2 = input.substr(peg$currPos, 3);
                peg$currPos += 3;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c411); }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c412();
              }
              s1 = s2;
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c413) {
                  s2 = input.substr(peg$currPos, 5);
                  peg$currPos += 5;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c414); }
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c415();
                }
                s1 = s2;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c416) {
                    s2 = input.substr(peg$currPos, 4);
                    peg$currPos += 4;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c417); }
                  }
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s2 = peg$c418();
                  }
                  s1 = s2;
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c419) {
                      s2 = input.substr(peg$currPos, 5);
                      peg$currPos += 5;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c420); }
                    }
                    if (s2 !== peg$FAILED) {
                      peg$savedPos = s1;
                      s2 = peg$c421();
                    }
                    s1 = s2;
                    if (s1 === peg$FAILED) {
                      s1 = peg$currPos;
                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c320) {
                        s2 = input.substr(peg$currPos, 4);
                        peg$currPos += 4;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c321); }
                      }
                      if (s2 !== peg$FAILED) {
                        peg$savedPos = s1;
                        s2 = peg$c422();
                      }
                      s1 = s2;
                      if (s1 === peg$FAILED) {
                        s1 = peg$currPos;
                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c423) {
                          s2 = input.substr(peg$currPos, 4);
                          peg$currPos += 4;
                        } else {
                          s2 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c424); }
                        }
                        if (s2 !== peg$FAILED) {
                          peg$savedPos = s1;
                          s2 = peg$c425();
                        }
                        s1 = s2;
                        if (s1 === peg$FAILED) {
                          s1 = peg$currPos;
                          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c426) {
                            s2 = input.substr(peg$currPos, 5);
                            peg$currPos += 5;
                          } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c427); }
                          }
                          if (s2 !== peg$FAILED) {
                            peg$savedPos = s1;
                            s2 = peg$c428();
                          }
                          s1 = s2;
                          if (s1 === peg$FAILED) {
                            s1 = peg$currPos;
                            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c429) {
                              s2 = input.substr(peg$currPos, 3);
                              peg$currPos += 3;
                            } else {
                              s2 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c430); }
                            }
                            if (s2 !== peg$FAILED) {
                              peg$savedPos = s1;
                              s2 = peg$c431();
                            }
                            s1 = s2;
                            if (s1 === peg$FAILED) {
                              s1 = peg$currPos;
                              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c432) {
                                s2 = input.substr(peg$currPos, 4);
                                peg$currPos += 4;
                              } else {
                                s2 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c433); }
                              }
                              if (s2 !== peg$FAILED) {
                                peg$savedPos = s1;
                                s2 = peg$c434();
                              }
                              s1 = s2;
                              if (s1 === peg$FAILED) {
                                s1 = peg$currPos;
                                if (input.substr(peg$currPos, 6).toLowerCase() === peg$c435) {
                                  s2 = input.substr(peg$currPos, 6);
                                  peg$currPos += 6;
                                } else {
                                  s2 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c436); }
                                }
                                if (s2 !== peg$FAILED) {
                                  peg$savedPos = s1;
                                  s2 = peg$c437();
                                }
                                s1 = s2;
                                if (s1 === peg$FAILED) {
                                  s1 = peg$currPos;
                                  if (input.substr(peg$currPos, 6).toLowerCase() === peg$c438) {
                                    s2 = input.substr(peg$currPos, 6);
                                    peg$currPos += 6;
                                  } else {
                                    s2 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c439); }
                                  }
                                  if (s2 !== peg$FAILED) {
                                    peg$savedPos = s1;
                                    s2 = peg$c440();
                                  }
                                  s1 = s2;
                                  if (s1 === peg$FAILED) {
                                    s1 = peg$currPos;
                                    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c441) {
                                      s2 = input.substr(peg$currPos, 10);
                                      peg$currPos += 10;
                                    } else {
                                      s2 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c442); }
                                    }
                                    if (s2 !== peg$FAILED) {
                                      peg$savedPos = s1;
                                      s2 = peg$c431();
                                    }
                                    s1 = s2;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c196;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c197); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence9();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c198;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c199); }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c443(s1, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprFunctionsNullary() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c444) {
      s2 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c445); }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = s1;
      s2 = peg$c446();
    }
    s1 = s2;
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c447) {
        s2 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c448); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c449();
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c450) {
          s2 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c451); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c452();
        }
        s1 = s2;
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 17).toLowerCase() === peg$c453) {
            s2 = input.substr(peg$currPos, 17);
            peg$currPos += 17;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c454); }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c452();
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.substr(peg$currPos, 21).toLowerCase() === peg$c455) {
              s2 = input.substr(peg$currPos, 21);
              peg$currPos += 21;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c456); }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s1;
              s2 = peg$c457();
            }
            s1 = s2;
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.substr(peg$currPos, 19).toLowerCase() === peg$c458) {
                s2 = input.substr(peg$currPos, 19);
                peg$currPos += 19;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c459); }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c460();
              }
              s1 = s2;
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.substr(peg$currPos, 15).toLowerCase() === peg$c461) {
                  s2 = input.substr(peg$currPos, 15);
                  peg$currPos += 15;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c462); }
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c463();
                }
                s1 = s2;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  if (input.substr(peg$currPos, 7).toLowerCase() === peg$c464) {
                    s2 = input.substr(peg$currPos, 7);
                    peg$currPos += 7;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c465); }
                  }
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s2 = peg$c463();
                  }
                  s1 = s2;
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c196;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c197); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s4 = peg$c198;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c199); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c466(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprConstants() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parsenumber();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s1;
      s2 = peg$c467(s2);
    }
    s1 = s2;
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      s2 = peg$parseboolean();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c468(s2);
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$parsestring();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c469(s2);
        }
        s1 = s2;
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c470(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parsevalueExprConstantNull();
    }

    return s0;
  }

  function peg$parsevalueExprConstantNull() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c326) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c471); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c472(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsevalueExprColumn() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsecolumnName();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 40) {
        s3 = peg$c196;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c197); }
      }
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c473(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprCaseWhen() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c474) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c475); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c476) {
          s5 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c477); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseexpr_precedence5();
            if (s7 !== peg$FAILED) {
              s8 = peg$parse__();
              if (s8 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c478) {
                  s9 = input.substr(peg$currPos, 4);
                  peg$currPos += 4;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c479); }
                }
                if (s9 !== peg$FAILED) {
                  s10 = peg$parse__();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parseexpr_precedence5();
                    if (s11 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c480(s7, s11);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c476) {
              s5 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c477); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseexpr_precedence5();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c478) {
                      s9 = input.substr(peg$currPos, 4);
                      peg$currPos += 4;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c479); }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseexpr_precedence5();
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c480(s7, s11);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c481) {
            s5 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c482); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseexpr_precedence5();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c483(s2, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c484) {
              s5 = input.substr(peg$currPos, 3);
              peg$currPos += 3;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c485); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c486(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_precedence9() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence8();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_boolean_disj();
      if (s3 === peg$FAILED) {
        s3 = peg$parseexpr_rest_string_concat();
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_boolean_disj();
          if (s3 === peg$FAILED) {
            s3 = peg$parseexpr_rest_string_concat();
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c487(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence8();
    }

    return s0;
  }

  function peg$parseexpr_precedence8() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence7();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_boolean_xdisj();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_boolean_xdisj();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c487(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence7();
    }

    return s0;
  }

  function peg$parseexpr_precedence7() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence6();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_boolean_conj();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_boolean_conj();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c487(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence6();
    }

    return s0;
  }

  function peg$parseexpr_precedence6() {
    var s0;

    s0 = peg$parsevalueExprCaseWhen();
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence5();
    }

    return s0;
  }

  function peg$parseexpr_precedence5() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence4();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_boolean_comparison();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_boolean_comparison();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c487(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence4();
    }

    return s0;
  }

  function peg$parseexpr_precedence4() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence3();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_number_add();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_number_add();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c487(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence3();
    }

    return s0;
  }

  function peg$parseexpr_precedence3() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence2();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_number_mul();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_number_mul();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c487(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence2();
    }

    return s0;
  }

  function peg$parseexpr_precedence2() {
    var s0;

    s0 = peg$parseexpr_number_minus();
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence1();
    }

    return s0;
  }

  function peg$parseexpr_precedence1() {
    var s0;

    s0 = peg$parseexpr_boolean_negation();
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence0();
    }

    return s0;
  }

  function peg$parseexpr_precedence0() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$parsevalueExprConstants();
    if (s0 === peg$FAILED) {
      s0 = peg$parsevalueExprFunctionsNullary();
      if (s0 === peg$FAILED) {
        s0 = peg$parsevalueExprFunctionsUnary();
        if (s0 === peg$FAILED) {
          s0 = peg$parsevalueExprFunctionsBinary();
          if (s0 === peg$FAILED) {
            s0 = peg$parsevalueExprFunctionsNary();
            if (s0 === peg$FAILED) {
              s0 = peg$parsevalueExprColumn();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 40) {
                  s1 = peg$c196;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c197); }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parse_();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseexpr_precedence9();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parse_();
                      if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                          s5 = peg$c198;
                          peg$currPos++;
                        } else {
                          s5 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c199); }
                        }
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c248(s3);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseRESERVED_KEYWORD_RELALG() {
    var s0;

    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c65) {
      s0 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c66); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c70) {
        s0 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c71); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c75) {
          s0 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c76); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c95) {
            s0 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c96); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c100) {
              s0 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c101); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c294) {
                s0 = input.substr(peg$currPos, 3);
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c295); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2).toLowerCase() === peg$c306) {
                  s0 = input.substr(peg$currPos, 2);
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c307); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3).toLowerCase() === peg$c488) {
                    s0 = input.substr(peg$currPos, 3);
                    peg$currPos += 3;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c489); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c105) {
                      s0 = input.substr(peg$currPos, 5);
                      peg$currPos += 5;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c106); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c110) {
                        s0 = input.substr(peg$currPos, 9);
                        peg$currPos += 9;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c111); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c120) {
                          s0 = input.substr(peg$currPos, 6);
                          peg$currPos += 6;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c121); }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
                            s0 = input.substr(peg$currPos, 4);
                            peg$currPos += 4;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c130); }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c127) {
                              s0 = input.substr(peg$currPos, 5);
                              peg$currPos += 5;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c128); }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {
                                s0 = input.substr(peg$currPos, 4);
                                peg$currPos += 4;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c130); }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c144) {
                                  s0 = input.substr(peg$currPos, 4);
                                  peg$currPos += 4;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c145); }
                                }
                                if (s0 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 5).toLowerCase() === peg$c151) {
                                    s0 = input.substr(peg$currPos, 5);
                                    peg$currPos += 5;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c152); }
                                  }
                                  if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {
                                      s0 = input.substr(peg$currPos, 5);
                                      peg$currPos += 5;
                                    } else {
                                      s0 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c162); }
                                    }
                                    if (s0 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c169) {
                                        s0 = input.substr(peg$currPos, 4);
                                        peg$currPos += 4;
                                      } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c170); }
                                      }
                                      if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c490) {
                                          s0 = input.substr(peg$currPos, 6);
                                          peg$currPos += 6;
                                        } else {
                                          s0 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$c491); }
                                        }
                                        if (s0 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c146) {
                                            s0 = input.substr(peg$currPos, 4);
                                            peg$currPos += 4;
                                          } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$c147); }
                                          }
                                          if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c156) {
                                              s0 = input.substr(peg$currPos, 4);
                                              peg$currPos += 4;
                                            } else {
                                              s0 = peg$FAILED;
                                              if (peg$silentFails === 0) { peg$fail(peg$c157); }
                                            }
                                            if (s0 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c183) {
                                                s0 = input.substr(peg$currPos, 4);
                                                peg$currPos += 4;
                                              } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) { peg$fail(peg$c184); }
                                              }
                                              if (s0 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c181) {
                                                  s0 = input.substr(peg$currPos, 3);
                                                  peg$currPos += 3;
                                                } else {
                                                  s0 = peg$FAILED;
                                                  if (peg$silentFails === 0) { peg$fail(peg$c182); }
                                                }
                                                if (s0 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c474) {
                                                    s0 = input.substr(peg$currPos, 4);
                                                    peg$currPos += 4;
                                                  } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) { peg$fail(peg$c475); }
                                                  }
                                                  if (s0 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c476) {
                                                      s0 = input.substr(peg$currPos, 4);
                                                      peg$currPos += 4;
                                                    } else {
                                                      s0 = peg$FAILED;
                                                      if (peg$silentFails === 0) { peg$fail(peg$c477); }
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c478) {
                                                        s0 = input.substr(peg$currPos, 4);
                                                        peg$currPos += 4;
                                                      } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) { peg$fail(peg$c479); }
                                                      }
                                                      if (s0 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c481) {
                                                          s0 = input.substr(peg$currPos, 4);
                                                          peg$currPos += 4;
                                                        } else {
                                                          s0 = peg$FAILED;
                                                          if (peg$silentFails === 0) { peg$fail(peg$c482); }
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c484) {
                                                            s0 = input.substr(peg$currPos, 3);
                                                            peg$currPos += 3;
                                                          } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) { peg$fail(peg$c485); }
                                                          }
                                                          if (s0 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c41) {
                                                              s0 = input.substr(peg$currPos, 4);
                                                              peg$currPos += 4;
                                                            } else {
                                                              s0 = peg$FAILED;
                                                              if (peg$silentFails === 0) { peg$fail(peg$c42); }
                                                            }
                                                            if (s0 === peg$FAILED) {
                                                              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c44) {
                                                                s0 = input.substr(peg$currPos, 5);
                                                                peg$currPos += 5;
                                                              } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) { peg$fail(peg$c45); }
                                                              }
                                                              if (s0 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c326) {
                                                                  s0 = input.substr(peg$currPos, 4);
                                                                  peg$currPos += 4;
                                                                } else {
                                                                  s0 = peg$FAILED;
                                                                  if (peg$silentFails === 0) { peg$fail(peg$c471); }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }


  	function t(key, obj){
  		obj = obj || {};

  		if(options.i18n){
  			return options.i18n.t(key, obj);
  		}

  		// fallback
  		return key+' '+JSON.stringify(obj);
  	}

  	function getCodeInfo(){
  		return {
  			location: location(),
  			text: text()
  		};
  	}
  	
  	/** merges the codeInfo objects of a binary operation 
  	 * it is assumed that the right node follows the left one
  	 */
  	function mergeCodeInfo(left, right){
  		var out = {
  			location: {
  				start: left.location.start,
  				end: right.location.end,
  			},
  			text: left.text + right.text,
  		};
  		
  		// start = min of both ends
  		if(left.location.end.offset <= right.location.start.offset === false){
  			console.error("mergeCodeInfo: nodes not next to each other (+- whitespace): ", left, right);
  		}
  		
  		return out;
  	}
  	
  	function getNodeInfo(nodeName){
  		return {
  			type: 'nodeInfo',
  			name: nodeName,
  			location: location(),
  		};
  	}

  	function checkAssignments(assignments){
  		// check if the defined variable names are unique
  		var tmp = {}, name;

  		for(var i = 0; i < assignments.length; i++){
  			name = assignments[i].name;
  			if(tmp[name]){
  				error(t('db.messages.parser.error-duplicate-variable', {name: name}));
  			}

  			tmp[name] = true;
  		}
  	};

  	var inlineTableNum = 1;

  	function buildBinary(first, rest){
  		// all members of rest have a child2

  		var root = rest[0];
  		root.child = first;
  		root.codeInfo = mergeCodeInfo(root.child.codeInfo, root.codeInfo);

  		var n;
  		for(var i = 1; i < rest.length; i++){
  			n = rest[i];

  			n.child = root;
  			n.codeInfo = mergeCodeInfo(n.child.codeInfo, n.codeInfo);

  			root = n;
  		}

  		return root;
  	}

  	// builds a binary valueExpression (fills the args array)
  	function buildBinaryValueExpr(first, rest){
  		// all members of rest have a member args in the form [undefined, child2]

  		var root = rest[0];
  		root.args[0] = first;
  		root.codeInfo = getCodeInfo();

  		var n;
  		for(var i = 1; i < rest.length; i++){
  			n = rest[i];

  			n.args[0] = root;
  			n.codeInfo = getCodeInfo();

  			root = n;
  		}

  		return root;
  	}

  	// options.relationNames must be an array of strings
  	// containing the names of the relations
  	var usedRelationNames = options.relationNames || [];
  	var operatorPositions = [];

  	function checkGroupNamesUnique(groups){
  		// check if the defined variable names are unique
  		const tmp = {};

  		for(let i = 0; i < groups.length; i++){
  			const groupHeader = groups[i].headers.find(g => g.name === 'group');
  			if(!groupHeader){
  				continue;
  				
  			}
  			const name = groupHeader.text;

  			if(tmp[name]){
  				error(t('db.messages.parser.error-group-non-unique-group-name', {name: name}));
  			}

  			tmp[name] = true;
  		}
  	};


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};

},{}],44:[function(require,module,exports){
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { start: peg$parsestart },
      peg$startRuleFunction  = peg$parsestart,

      peg$c0 = function(r) { return r; },
      peg$c1 = peg$anyExpectation(),
      peg$c2 = "\r\n",
      peg$c3 = peg$literalExpectation("\r\n", false),
      peg$c4 = "\n",
      peg$c5 = peg$literalExpectation("\n", false),
      peg$c6 = peg$otherExpectation("-- "),
      peg$c7 = "--",
      peg$c8 = peg$literalExpectation("--", false),
      peg$c9 = /^[ \t]/,
      peg$c10 = peg$classExpectation([" ", "\t"], false, false),
      peg$c11 = "/*",
      peg$c12 = peg$literalExpectation("/*", false),
      peg$c13 = "*/",
      peg$c14 = peg$literalExpectation("*/", false),
      peg$c15 = peg$otherExpectation("whitespace"),
      peg$c16 = /^[ \t\r\n]/,
      peg$c17 = peg$classExpectation([" ", "\t", "\r", "\n"], false, false),
      peg$c18 = function() { return ''; },
      peg$c19 = peg$otherExpectation("optional whitespace"),
      peg$c20 = peg$otherExpectation("whitespace without comments"),
      peg$c21 = /^[\r\n\t ]/,
      peg$c22 = peg$classExpectation(["\r", "\n", "\t", " "], false, false),
      peg$c23 = peg$otherExpectation("optional whitespace without comments"),
      peg$c24 = peg$otherExpectation("string"),
      peg$c25 = "\"",
      peg$c26 = peg$literalExpectation("\"", false),
      peg$c27 = /^[^"\^\n]/,
      peg$c28 = peg$classExpectation(["\"", "^", "\n"], true, false),
      peg$c29 = function() { error(t('db.messages.parser.error-sql-string-use-single-quotes')); },
      peg$c30 = "'",
      peg$c31 = peg$literalExpectation("'", false),
      peg$c32 = /^[^'\^\n]/,
      peg$c33 = peg$classExpectation(["'", "^", "\n"], true, false),
      peg$c34 = function(a) { return a; },
      peg$c35 = "-",
      peg$c36 = peg$literalExpectation("-", false),
      peg$c37 = /^[0-9]/,
      peg$c38 = peg$classExpectation([["0", "9"]], false, false),
      peg$c39 = function(a) {return parseInt(a, 10); },
      peg$c40 = ".",
      peg$c41 = peg$literalExpectation(".", false),
      peg$c42 = function(a) {return parseFloat(a); },
      peg$c43 = "true",
      peg$c44 = peg$literalExpectation("true", true),
      peg$c45 = function() { return true; },
      peg$c46 = "false",
      peg$c47 = peg$literalExpectation("false", true),
      peg$c48 = function() { return false; },
      peg$c49 = peg$otherExpectation("relationName"),
      peg$c50 = /^[0-9a-zA-Z_]/,
      peg$c51 = peg$classExpectation([["0", "9"], ["a", "z"], ["A", "Z"], "_"], false, false),
      peg$c52 = /^[a-zA-Z]/,
      peg$c53 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
      peg$c54 = function(a) {
      		var b = a.toLowerCase();
      		if(b === 'true' || b === 'false')
      			error(t('db.messages.parser.error-sql-invalid-relation-name', {str: a}));
      		return a;
      	},
      peg$c55 = function(a) {
      		var b = a.toLowerCase();
      		if(b === 'true' || b === 'false')
      			error(t('db.messages.parser.error-sql-invalid-column-name', {str: a}));
      		return a;
      	},
      peg$c56 = function(a) {
      		return {
      			type: 'relation',
      			name: a,
      			relAlias: null,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c57 = "date",
      peg$c58 = peg$literalExpectation("date", true),
      peg$c59 = "('",
      peg$c60 = peg$literalExpectation("('", false),
      peg$c61 = "')",
      peg$c62 = peg$literalExpectation("')", false),
      peg$c63 = function(d) {
      		return d;
      	},
      peg$c64 = peg$otherExpectation("date in ISO format (YYYY-MM-DD)"),
      peg$c65 = function(year, month, day) {
      		year = parseInt(year, 10);
      		month = parseInt(month, 10)-1;
      		day = parseInt(day, 10);
      		var date = new Date(year, month, day);

      		if(date.getFullYear() != year || date.getMonth() != month ||  date.getDate() != day){
      			error(t('db.messages.parser.error-invalid-date-format', {str: text()}));
      		}
      		return date;
      	},
      peg$c66 = function(relAlias, name) {
      		return {
      			type: 'column',
      			name: name,
      			relAlias: relAlias ? relAlias[0] : null
      		};
      	},
      peg$c67 = "*",
      peg$c68 = peg$literalExpectation("*", false),
      peg$c69 = function(relAlias) {
      		return {
      			type: 'column',
      			name: '*',
      			relAlias: relAlias ? relAlias[0] : null
      		};
      	},
      peg$c70 = function(index) {
      		return {
      			type: 'column',
      			name: parseInt(index, 10),
      			relAlias: null
      		};
      	},
      peg$c71 = "sum",
      peg$c72 = peg$literalExpectation("sum", true),
      peg$c73 = "count",
      peg$c74 = peg$literalExpectation("count", true),
      peg$c75 = "avg",
      peg$c76 = peg$literalExpectation("avg", true),
      peg$c77 = "min",
      peg$c78 = peg$literalExpectation("min", true),
      peg$c79 = "max",
      peg$c80 = peg$literalExpectation("max", true),
      peg$c81 = "(",
      peg$c82 = peg$literalExpectation("(", false),
      peg$c83 = "all",
      peg$c84 = peg$literalExpectation("ALL", true),
      peg$c85 = ")",
      peg$c86 = peg$literalExpectation(")", false),
      peg$c87 = function(func, col) {
      		return {
      			type: 'aggFunction',
      			aggFunction: func.toUpperCase(),
      			col: col
      		};
      	},
      peg$c88 = "count(*)",
      peg$c89 = peg$literalExpectation("count(*)", true),
      peg$c90 = function() {
      		return {
      			type: 'aggFunction',
      			aggFunction: 'COUNT_ALL',
      			col: null
      		};
      	},
      peg$c91 = "as",
      peg$c92 = peg$literalExpectation("as", true),
      peg$c93 = function(f, as) {
      		f.name = as;
      		return f;
      	},
      peg$c94 = function(f) {
      		error('aggregation columns must be named');
      	},
      peg$c95 = function(col) {
      		col.alias = null;
      		return col;
      	},
      peg$c96 = function(col, dst) {
      		col.alias = dst;
      		return col;
      	},
      peg$c97 = function(a, dst) {
      		return {
      			type: 'namedColumnExpr',
      			name: dst,
      			relAlias: null,
      			child: a,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c98 = ",",
      peg$c99 = peg$literalExpectation(",", false),
      peg$c100 = function(a, b) {
      		var t = [a];

      		if(b != null){
      			for(var i = 0; i < b.length; i++){
      				var col = b[i][3];
      				t.push(col);
      			}
      		}
      		return t;
      	},
      peg$c101 = function(a, b) {
      		var t = [a];
      		if(b != null){
      			for(var i in b){
      				t.push(b[i][3]);
      			}
      		}
      		return t;
      	},
      peg$c102 = "asc",
      peg$c103 = peg$literalExpectation("asc", true),
      peg$c104 = function() {
      		return true;
      	},
      peg$c105 = "desc",
      peg$c106 = peg$literalExpectation("desc", true),
      peg$c107 = function() {
      		return false;
      	},
      peg$c108 = function(a, asc) {
      		if(asc == null)
      			asc = true;
      		else
      			asc = asc[1];

      		return {
      			col: a,
      			asc: asc
      		};
      	},
      peg$c109 = function(a, b) {
      	var t = [a];
      	if(b != null){
      		for(var i in b){
      			t.push(b[i][3]);
      		}
      	}

      	return {
      		value: t,

      		codeInfo: getCodeInfo()
      	};
      },
      peg$c110 = function(a, b) {
      	var t = [a];
      	if(b != null){
      		for(var i in b){
      			t.push(b[i][3]);
      		}
      	}

      	return t;
      },
      peg$c111 = function(name, sub) {
      		sub.wrappedInParentheses = true;
      		return {
      			type: 'assignment',
      			name: name,
      			child: {
      				type: 'relationFromSubstatement',
      				statement: sub,
      				relAlias: name,

      				codeInfo: getCodeInfo()
      			},

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c112 = ";",
      peg$c113 = peg$literalExpectation(";", false),
      peg$c114 = function(a, e) {
      		var assignments = [];
      		if(a !== null){
      			assignments = a;
      			checkAssignments(assignments);
      		}

      		return {
      			type: 'sqlRoot',
      			assignments: assignments,
      			child: e,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c115 = "with",
      peg$c116 = peg$literalExpectation("with", true),
      peg$c117 = function(first, rest) {
      		var assignments = [first];
      		for(var i = 0; i < rest.length; i++){
      			assignments.push(rest[i][3]);
      		}
      		return assignments;
      	},
      peg$c118 = "select",
      peg$c119 = peg$literalExpectation("select", true),
      peg$c120 = "distinct",
      peg$c121 = peg$literalExpectation("distinct", true),
      peg$c122 = function(d, cols) {
      		return {
      			type: 'select',
      			distinct: (d !== null),
      			arg: cols,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c123 = "order",
      peg$c124 = peg$literalExpectation("order", true),
      peg$c125 = "by",
      peg$c126 = peg$literalExpectation("by", true),
      peg$c127 = function(arg) {
      		return {
      			type: 'orderBy',
      			child: null,
      			arg: arg,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c128 = function(s, o, l) {
      		var n = s;
      		if(o !== null){
      			o[1].child = n;
      			n = o[1];
      		}
      		if(l !== null){
      			l[1].child = n;
      			n = l[1];
      		}
      		return n;
      	},
      peg$c129 = function(first, rest) { return buildBinary(first, rest); },
      peg$c130 = "from",
      peg$c131 = peg$literalExpectation("from", true),
      peg$c132 = "group",
      peg$c133 = peg$literalExpectation("group", true),
      peg$c134 = function(s, f, w, g, h) {
      		// check if group clause is missing: if a agg column in combination with a non agg column appears group by must be set
      		var col;
      		var numAggregationColumns = 0;
      		for(var i = 0; i < s.arg.length; i++){
      			if(s.arg[i].type === 'aggFunction')
      				numAggregationColumns++;
      		}

      		if(numAggregationColumns > 0 && numAggregationColumns != s.arg.length && g === null){
      			error(t('db.messages.parser.error-sql-group-by-missing'));
      		}

      		if(h && !g && numAggregationColumns === 0){
      			error(t('db.messages.parser.error-sql-having-without-group-by'));
      		}


      		return {
      			type: 'statement',
      			select: s,
      			from: f,
      			where: w ? w[1] : null,
      			groupBy: g ? g[5] : null,
      			having: h ? h[1] : null,

      			numAggregationColumns: numAggregationColumns,
      			wrappedInParentheses: false,
      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c135 = function(e) {
      		e.wrappedInParentheses = true;
      		return e;
      	},
      peg$c136 = "union",
      peg$c137 = peg$literalExpectation("union", true),
      peg$c138 = peg$literalExpectation("all", true),
      peg$c139 = function(all, c) { return {type: 'union', child2: c, all: all}; },
      peg$c140 = "except",
      peg$c141 = peg$literalExpectation("except", true),
      peg$c142 = function(all, c) { return {type: 'except', child2: c, all: all}; },
      peg$c143 = "intersect",
      peg$c144 = peg$literalExpectation("intersect", true),
      peg$c145 = function(all, c) { return {type: 'intersect', child2: c, all: all}; },
      peg$c146 = function(name, alias) {
      		var relation = {
      			type: 'relation',
      			name: name,
      			relAlias: null,

      			codeInfo: getCodeInfo()
      		};

      		if(alias !== null){
      			return {
      				type: 'renameRelation',
      				child: relation,
      				newRelAlias: alias[3],
      				codeInfo: getCodeInfo()
      			};
      		}
      		else{
      			return relation;
      		}
      	},
      peg$c147 = function(sub, alias) {
      		sub.wrappedInParentheses = true;
      		return {
      			type: 'relationFromSubstatement',
      			statement: sub,
      			relAlias: alias,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c148 = "cross",
      peg$c149 = peg$literalExpectation("cross", true),
      peg$c150 = "join",
      peg$c151 = peg$literalExpectation("join", true),
      peg$c152 = function(c) { return {type: 'crossJoin', child2: c, cond: null}; },
      peg$c153 = "natural",
      peg$c154 = peg$literalExpectation("natural", true),
      peg$c155 = function(c) { return {type: 'naturalJoin', child2: c, cond: null}; },
      peg$c156 = "inner",
      peg$c157 = peg$literalExpectation("inner", true),
      peg$c158 = function() { return 'innerJoin'; },
      peg$c159 = "left",
      peg$c160 = peg$literalExpectation("left", true),
      peg$c161 = "outer",
      peg$c162 = peg$literalExpectation("outer", true),
      peg$c163 = function() { return 'leftOuterJoin'; },
      peg$c164 = "right",
      peg$c165 = peg$literalExpectation("right", true),
      peg$c166 = function() { return 'rightOuterJoin'; },
      peg$c167 = "full",
      peg$c168 = peg$literalExpectation("full", true),
      peg$c169 = function() { return 'fullOuterJoin'; },
      peg$c170 = "on",
      peg$c171 = peg$literalExpectation("on", true),
      peg$c172 = function(type, c, expr) { return expr; },
      peg$c173 = "using",
      peg$c174 = peg$literalExpectation("using", true),
      peg$c175 = function(type, c, first, rest) {
      			var restrictToColumns = [first];
      			for(var i = 0; i < rest.length; i++){
      				restrictToColumns.push(rest[i][3]);
      			}
      			return restrictToColumns;
      		},
      peg$c176 = function(type, c) { return null; },
      peg$c177 = function(type, c, condition) {
      		return {
      			type: type,
      			child2: c,
      			cond: condition
      		};
      	},
      peg$c178 = "where",
      peg$c179 = peg$literalExpectation("where", true),
      peg$c180 = function(cond) {
      		return {
      			type: 'where',
      			arg: cond,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c181 = "having",
      peg$c182 = peg$literalExpectation("having", true),
      peg$c183 = function(cond) {
      		return {
      			type: 'having',
      			arg: cond,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c184 = function() { return -1; },
      peg$c185 = function(a) {
      		if(a < 0)
      			error(t('db.messages.parser.error-sql-negative-limit'));
      		return a;
      	},
      peg$c186 = "limit",
      peg$c187 = peg$literalExpectation("limit", true),
      peg$c188 = function(o, l) {
      		return {
      			type: 'limit',
      			limit: l,
      			offset: 0,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c189 = "offset",
      peg$c190 = peg$literalExpectation("offset", true),
      peg$c191 = function(l, o) {
      		return {
      			type: 'limit',
      			limit: l,
      			offset: o,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c192 = function(l) {
      		return {
      			type: 'limit',
      			limit: l,
      			offset: 0,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c193 = "rows",
      peg$c194 = peg$literalExpectation("rows", true),
      peg$c195 = "row",
      peg$c196 = peg$literalExpectation("row", true),
      peg$c197 = function(o) {
      		return o;
      	},
      peg$c198 = "fetch",
      peg$c199 = peg$literalExpectation("fetch", true),
      peg$c200 = "first",
      peg$c201 = peg$literalExpectation("first", true),
      peg$c202 = "next",
      peg$c203 = peg$literalExpectation("next", true),
      peg$c204 = "only",
      peg$c205 = peg$literalExpectation("only", true),
      peg$c206 = function(l) {
      		if(l < 0)
      			error(t('db.messages.parser.error-sql-negative-limit'));
      		return l;
      	},
      peg$c207 = function(o, l) { return [o, l]; },
      peg$c208 = function(o) { return [o, -1]; },
      peg$c209 = function(l) { return [0, l]; },
      peg$c210 = function(a) {
      		return {
      			type: 'limit',
      			child: null,
      			limit: a[1],
      			offset: a[0],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c211 = "is",
      peg$c212 = peg$literalExpectation("is", true),
      peg$c213 = "not",
      peg$c214 = peg$literalExpectation("not", true),
      peg$c215 = function() { return '!='; },
      peg$c216 = function() { return '='; },
      peg$c217 = "=",
      peg$c218 = peg$literalExpectation("=", false),
      peg$c219 = "<>",
      peg$c220 = peg$literalExpectation("<>", false),
      peg$c221 = "!=",
      peg$c222 = peg$literalExpectation("!=", false),
      peg$c223 = ">=",
      peg$c224 = peg$literalExpectation(">=", false),
      peg$c225 = function() { return '>='; },
      peg$c226 = ">",
      peg$c227 = peg$literalExpectation(">", false),
      peg$c228 = "<=",
      peg$c229 = peg$literalExpectation("<=", false),
      peg$c230 = function() { return '<='; },
      peg$c231 = "<",
      peg$c232 = peg$literalExpectation("<", false),
      peg$c233 = peg$otherExpectation("logical AND"),
      peg$c234 = "and",
      peg$c235 = peg$literalExpectation("and", true),
      peg$c236 = function() { return 'AND'; },
      peg$c237 = peg$otherExpectation("logical XOR"),
      peg$c238 = "xor",
      peg$c239 = peg$literalExpectation("xor", true),
      peg$c240 = peg$otherExpectation("logical OR"),
      peg$c241 = "or",
      peg$c242 = peg$literalExpectation("or", true),
      peg$c243 = function() { return 'OR'; },
      peg$c244 = peg$otherExpectation("logical NOT"),
      peg$c245 = "!",
      peg$c246 = peg$literalExpectation("!", false),
      peg$c247 = function() { return 'NOT'; },
      peg$c248 = peg$literalExpectation("not", false),
      peg$c249 = "exists",
      peg$c250 = peg$literalExpectation("exists", true),
      peg$c251 = function(negation, sub) {
      		return {
      			type: 'existsSubstatement',
      			statement: sub,
      			negation: (negation != null),

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c252 = function() { return { type: 'comment' }; },
      peg$c253 = "#",
      peg$c254 = peg$literalExpectation("#", false),
      peg$c255 = /^[^\n]/,
      peg$c256 = peg$classExpectation(["\n"], true, false),
      peg$c257 = "`",
      peg$c258 = peg$literalExpectation("`", false),
      peg$c259 = "drop",
      peg$c260 = peg$literalExpectation("drop", true),
      peg$c261 = "table",
      peg$c262 = peg$literalExpectation("table", true),
      peg$c263 = "if",
      peg$c264 = peg$literalExpectation("if", true),
      peg$c265 = function() { return { type: 'dropTable' }; },
      peg$c266 = "lock",
      peg$c267 = peg$literalExpectation("lock", true),
      peg$c268 = "tables",
      peg$c269 = peg$literalExpectation("tables", true),
      peg$c270 = function() { return { type: 'lockTable' }; },
      peg$c271 = "unlock",
      peg$c272 = peg$literalExpectation("unlock", true),
      peg$c273 = function() { return { type: 'unlockTable' }; },
      peg$c274 = function(a) {
      		var tables = {};
      		var column_indices = {};
      		var e, i, j, k, row, type;
      		var groupName = '';

      		for(i = 0; i < a.length; i++){
      			e = a[i][0];
      			if(!e.type || e.type !== 'table' && e.type !== 'insert' && e.type !== 'groupName')
      				continue;

      			if(e.type == 'table'){ // create
      				if(tables[e.name])
      					error('table '+e.name+' already created');

      				tables[e.name] = e;

      				column_indices[e.name] = {};
      				for(j = 0; j < e.columns.length; j++){
      					column_indices[e.name][e.columns[j].name] = j;
      				}
      			}
      			else if(e.type === 'groupName'){
      				groupName = e.name;
      			}
      			else if(e.type === 'insert'){ // insert
      				if(!tables[e.name])
      					error('table '+e.name+' not created');

      				for(j = 0; j < e.values.length; j++){
      					if(e.columns.length === 0){
      						row = e.values[j];
      					}
      					else{
      						row = new Array(tables[e.name].columns.length);

      						for(k = 0; k < e.values[j].length; k++){
      							row[ column_indices[e.name][e.columns[k]] ] = e.values[j][k];
      						}
      					}

      					// type check
      					if(row.length !== tables[e.name].columns.length)
      						error(t('db.messages.parser.error-sqldump-invalid-column-number', {line: e.codeInfo.line}));

      					for(k = 0; k < row.length; k++){
      						type = tables[e.name].columns[k].type;

      						if(row[k] === null)
      							continue;

      						switch(type){
      							case 'number':
      								if(typeof row[k] !== 'number')
      									error(t('db.messages.parser.error-sqldump-invalid-type', {line: e.codeInfo.line}));
      								break;

      							case 'string':
      								if(typeof row[k] !== 'string')
      									error(t('db.messages.parser.error-sqldump-invalid-type', {line: e.codeInfo.line}));
      								break;

      							case 'date':
      								if(row[k] instanceof Date === false)
      									error(t('db.messages.parser.error-sqldump-invalid-type', {line: e.codeInfo.line}));
      								break;
      						}
      					}

      					tables[e.name].rows.push(row);
      				}

      			}
      		}

      		var assignments = [];
      		for(var name in tables){
      			assignments.push({
      				type: 'assignment',
      				name: name,
      				child: tables[name],

      				codeInfo: getCodeInfo()
      			});
      		}

      		var root = {
      			type: 'groupRoot',
      			groups: [
      				{
      					type: 'tableGroup',
      					headers: {
      						group: groupName
      					},
      					assignments: assignments,

      					codeInfo: getCodeInfo()
      				}
      			],

      			codeInfo: getCodeInfo()
      		};
      		return root;

      	},
      peg$c275 = "use",
      peg$c276 = peg$literalExpectation("use", true),
      peg$c277 = /^[a-zA-Z_0-9\-]/,
      peg$c278 = peg$classExpectation([["a", "z"], ["A", "Z"], "_", ["0", "9"], "-"], false, false),
      peg$c279 = function(name) { 
      		return {
      			type: 'groupName', 
      			name: name
      		}; 
      	},
      peg$c280 = "decimal",
      peg$c281 = peg$literalExpectation("decimal", true),
      peg$c282 = function() { return 'number'; },
      peg$c283 = "tinyint",
      peg$c284 = peg$literalExpectation("tinyint", true),
      peg$c285 = "smallint",
      peg$c286 = peg$literalExpectation("smallint", true),
      peg$c287 = "mediumint",
      peg$c288 = peg$literalExpectation("mediumint", true),
      peg$c289 = "bigint",
      peg$c290 = peg$literalExpectation("bigint", true),
      peg$c291 = "integer",
      peg$c292 = peg$literalExpectation("integer", true),
      peg$c293 = "int",
      peg$c294 = peg$literalExpectation("int", true),
      peg$c295 = "float",
      peg$c296 = peg$literalExpectation("float", true),
      peg$c297 = "double",
      peg$c298 = peg$literalExpectation("double", true),
      peg$c299 = "varchar",
      peg$c300 = peg$literalExpectation("varchar", true),
      peg$c301 = "char",
      peg$c302 = peg$literalExpectation("char", true),
      peg$c303 = "text",
      peg$c304 = peg$literalExpectation("text", true),
      peg$c305 = function() { return 'string'; },
      peg$c306 = "datetime",
      peg$c307 = peg$literalExpectation("datetime", true),
      peg$c308 = function() { return 'date'; },
      peg$c309 = /^[a-zA-Z0-9_=]/,
      peg$c310 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "="], false, false),
      peg$c311 = function() { return null; },
      peg$c312 = function(name, type) {
      		return {
      			name: name,
      			type: type,
      			relAlias: null
      		};
      	},
      peg$c313 = function(first, rest) {
      		var a = [];
      		if(first !== null && first.type)
      			a.push(first);

      		for(var i = 0; i < rest.length; i++){
      			if(rest[i][3] !== null && rest[i][3].type)
      				a.push(rest[i][3]);
      		}

      		return a;
      	},
      peg$c314 = "create",
      peg$c315 = peg$literalExpectation("create", true),
      peg$c316 = peg$literalExpectation("exists", false),
      peg$c317 = function(name, columns) {
      		var table = {
      			type: 'table',
      			name: name,
      			columns: columns, //{name: '', relAlias: null, type: ''}
      			rows: [],

      			codeInfo: getCodeInfo()
      		};



      		return table;
      	},
      peg$c318 = "null",
      peg$c319 = peg$literalExpectation("null", true),
      peg$c320 = function(first, rest) {
      		var a = [first];
      		for(var i = 0; i < rest.length; i++){
      			a.push(rest[i][3]);
      		}
      		return a;
      	},
      peg$c321 = "insert",
      peg$c322 = peg$literalExpectation("insert", true),
      peg$c323 = "into",
      peg$c324 = peg$literalExpectation("into", true),
      peg$c325 = "values",
      peg$c326 = peg$literalExpectation("values", true),
      peg$c327 = function(name, cols, value_first, value_rest) {
      		var i;
      		var insert = {
      			type: 'insert',
      			name: name,
      			columns: [],
      			values: [value_first],

      			codeInfo: getCodeInfo()
      		};

      		if(value_rest){
      			for(i = 0; i < value_rest.length; i++){
      				insert.values.push(value_rest[i][3]);
      			}
      		}

      		if(cols){
      			// first
      			insert.columns.push(cols[3]);

      			// rest
      			for(var i = 0; i < cols[4].length; i++){
      				insert.columns.push(cols[4][i][3]);
      			}
      		}


      		// check number of columns
      		var numCols = insert.values[0].length;

      		for(i = 1; i < insert.values.length; i++){
      			if(insert.values[i].length !== numCols)
      				error(t('db.messages.parser.error-sqldump-insert-wrong-number-columns'));
      		}

      		if(cols && insert.columns.length !== numCols)
      			error(t('db.messages.parser.error-sqldump-insert-wrong-number-columns'));


      		return insert;
      	},
      peg$c328 = peg$otherExpectation("boolean expression"),
      peg$c329 = function(right) {
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: 'or',
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c330 = "||",
      peg$c331 = peg$literalExpectation("||", false),
      peg$c332 = function(right) {
      		return {
      			type: 'valueExpr',
      			datatype: 'string',
      			func: 'concat',
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c333 = function(right) {
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: 'xor',
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c334 = function(right) {
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: 'and',
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c335 = function(o, right) {
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: o,
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c336 = "like",
      peg$c337 = peg$literalExpectation("like", true),
      peg$c338 = "ilike",
      peg$c339 = peg$literalExpectation("ilike", true),
      peg$c340 = function(o, right) {
      		if(right.datatype !== 'string'){
      			error(t('db.messages.parser.error-valueexpr-like-operand-no-string'));
      		}
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: o.toLowerCase(),
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c341 = "+",
      peg$c342 = peg$literalExpectation("+", false),
      peg$c343 = function(o, right) {
      		o = {
      			'+': 'add',
      			'-': 'sub'
      		}[o];

      		return {
      			type: 'valueExpr',
      			datatype: 'number',
      			func: o,
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c344 = "/",
      peg$c345 = peg$literalExpectation("/", false),
      peg$c346 = "%",
      peg$c347 = peg$literalExpectation("%", false),
      peg$c348 = function(o, right) {
      		o = {
      			'*': 'mul',
      			'/': 'div',
      			'%': 'mod'
      		}[o];

      		return {
      			type: 'valueExpr',
      			datatype: 'number',
      			func: o,
      			args: [undefined, right],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c349 = function(a) {
      		return {
      			type: 'valueExpr',
      			datatype: 'number',
      			func: 'minus',
      			args: [a],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c350 = function(a) {
      		return {
      			type: 'valueExpr',
      			datatype: 'boolean',
      			func: 'not',
      			args: [a],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c351 = "coalesce",
      peg$c352 = peg$literalExpectation("coalesce", true),
      peg$c353 = function() { return ['coalesce', 'null']; },
      peg$c354 = "concat",
      peg$c355 = peg$literalExpectation("concat", true),
      peg$c356 = function() { return ['concat', 'string']; },
      peg$c357 = function(func, arg0, argn) {
      		var args = [arg0];
      		for(var i = 0; i < argn.length; i++){
      			args.push(argn[i][2]);
      		}

      		return {
      			type: 'valueExpr',
      			datatype: func[1],
      			func: func[0],
      			args: args,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c358 = "adddate",
      peg$c359 = peg$literalExpectation("adddate", true),
      peg$c360 = function() { return ['adddate', 'date']; },
      peg$c361 = "subdate",
      peg$c362 = peg$literalExpectation("subdate", true),
      peg$c363 = function() { return ['subdate', 'date']; },
      peg$c364 = "mod",
      peg$c365 = peg$literalExpectation("mod", true),
      peg$c366 = function() { return ['mod', 'number']; },
      peg$c367 = "add",
      peg$c368 = peg$literalExpectation("add", true),
      peg$c369 = function() { return ['add', 'number']; },
      peg$c370 = "sub",
      peg$c371 = peg$literalExpectation("sub", true),
      peg$c372 = function() { return ['sub', 'number']; },
      peg$c373 = "mul",
      peg$c374 = peg$literalExpectation("mul", true),
      peg$c375 = function() { return ['mul', 'number']; },
      peg$c376 = "div",
      peg$c377 = peg$literalExpectation("div", true),
      peg$c378 = function() { return ['div', 'number']; },
      peg$c379 = function(func, arg0, arg1) {
      		return {
      			type: 'valueExpr',
      			datatype: func[1],
      			func: func[0],
      			args: [arg0, arg1],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c380 = "upper",
      peg$c381 = peg$literalExpectation("upper", true),
      peg$c382 = function() { return ['upper', 'string']; },
      peg$c383 = "ucase",
      peg$c384 = peg$literalExpectation("ucase", true),
      peg$c385 = "lower",
      peg$c386 = peg$literalExpectation("lower", true),
      peg$c387 = function() { return ['lower', 'string']; },
      peg$c388 = "lcase",
      peg$c389 = peg$literalExpectation("lcase", true),
      peg$c390 = "length",
      peg$c391 = peg$literalExpectation("length", true),
      peg$c392 = function() { return ['strlen', 'number']; },
      peg$c393 = "abs",
      peg$c394 = peg$literalExpectation("abs", true),
      peg$c395 = function() { return ['abs', 'number']; },
      peg$c396 = "floor",
      peg$c397 = peg$literalExpectation("floor", true),
      peg$c398 = function() { return ['floor', 'number']; },
      peg$c399 = "ceil",
      peg$c400 = peg$literalExpectation("ceil", true),
      peg$c401 = function() { return ['ceil', 'number']; },
      peg$c402 = "round",
      peg$c403 = peg$literalExpectation("round", true),
      peg$c404 = function() { return ['round', 'number']; },
      peg$c405 = function() { return ['date', 'date']; },
      peg$c406 = "year",
      peg$c407 = peg$literalExpectation("year", true),
      peg$c408 = function() { return ['year', 'number']; },
      peg$c409 = "month",
      peg$c410 = peg$literalExpectation("month", true),
      peg$c411 = function() { return ['month', 'number']; },
      peg$c412 = "day",
      peg$c413 = peg$literalExpectation("day", true),
      peg$c414 = function() { return ['dayofmonth', 'number']; },
      peg$c415 = "hour",
      peg$c416 = peg$literalExpectation("hour", true),
      peg$c417 = function() { return ['hour', 'number']; },
      peg$c418 = "minute",
      peg$c419 = peg$literalExpectation("minute", true),
      peg$c420 = function() { return ['minute', 'number']; },
      peg$c421 = "second",
      peg$c422 = peg$literalExpectation("second", true),
      peg$c423 = function() { return ['second', 'number']; },
      peg$c424 = "dayofmonth",
      peg$c425 = peg$literalExpectation("dayofmonth", true),
      peg$c426 = function(func, arg0) {
      		return {
      			type: 'valueExpr',
      			datatype: func[1],
      			func: func[0],
      			args: [arg0],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c427 = "rand",
      peg$c428 = peg$literalExpectation("rand", true),
      peg$c429 = function() { return ['rand', 'number']; },
      peg$c430 = "rownum",
      peg$c431 = peg$literalExpectation("rownum", true),
      peg$c432 = function() { return ['rownum', 'number']; },
      peg$c433 = "now",
      peg$c434 = peg$literalExpectation("now", true),
      peg$c435 = function() { return ['now', 'date']; },
      peg$c436 = "current_timestamp",
      peg$c437 = peg$literalExpectation("current_timestamp", true),
      peg$c438 = "transaction_timestamp",
      peg$c439 = peg$literalExpectation("transaction_timestamp", true),
      peg$c440 = function() { return ['transaction_timestamp', 'date']; },
      peg$c441 = "statement_timestamp",
      peg$c442 = peg$literalExpectation("statement_timestamp", true),
      peg$c443 = function() { return ['statement_timestamp', 'date']; },
      peg$c444 = "clock_timestamp",
      peg$c445 = peg$literalExpectation("clock_timestamp", true),
      peg$c446 = function() { return ['clock_timestamp', 'date']; },
      peg$c447 = "sysdate",
      peg$c448 = peg$literalExpectation("sysdate", true),
      peg$c449 = function(func) {
      		return {
      			type: 'valueExpr',
      			datatype: func[1],
      			func: func[0],
      			args: [],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c450 = function(v) { return [v, 'number']; },
      peg$c451 = function(v) { return [v, 'boolean']; },
      peg$c452 = function(v) { return [v, 'string']; },
      peg$c453 = function(a) {
      		return {
      			type: 'valueExpr',
      			datatype: a[1],
      			func: 'constant',
      			args: [a[0]],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c454 = function(a) {
      		return {
      			type: 'valueExpr',
      			datatype: 'null',
      			func: 'constant',
      			args: [null],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c455 = function(a) {
      		return {
      			type: 'valueExpr',
      			datatype: 'null',
      			func: 'columnValue',
      			args: [a.name, a.relAlias],

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c456 = "case",
      peg$c457 = peg$literalExpectation("case", true),
      peg$c458 = "when",
      peg$c459 = peg$literalExpectation("when", true),
      peg$c460 = "then",
      peg$c461 = peg$literalExpectation("then", true),
      peg$c462 = function(c, r) { return {w: c, t:r} },
      peg$c463 = "else",
      peg$c464 = peg$literalExpectation("else", true),
      peg$c465 = function(wt, r) { return r },
      peg$c466 = "end",
      peg$c467 = peg$literalExpectation("end", true),
      peg$c468 = function(wt, e) {
      		var args = [], i;
      		for(i = 0; i < wt.length; i++){
      			// when on i%2 === 0
      			args.push(wt[i].w);

      			// then on i%2 === 1
      			args.push(wt[i].t);
      		}

      		// else part
      		if(e !== null){
      			// when on i%2 === 0
      			// constant true is used to give all args a unified interface
      			args.push({
      				type: 'valueExpr',
      				datatype: 'boolean',
      				func: 'constant',
      				args: [true],

      				codeInfo: getCodeInfo()
      			});

      			// then on i%2 === 1
      			args.push(e);
      		}

      		return {
      			type: 'valueExpr',
      			datatype: 'null',
      			func: e === null ? 'caseWhen' : 'caseWhenElse',
      			args: args,

      			codeInfo: getCodeInfo()
      		};
      	},
      peg$c469 = function(first, rest) { return buildBinaryValueExpr(first, rest); },
      peg$c470 = "pi",
      peg$c471 = peg$literalExpectation("pi", true),
      peg$c472 = "sigma",
      peg$c473 = peg$literalExpectation("sigma", true),
      peg$c474 = "rho",
      peg$c475 = peg$literalExpectation("rho", true),
      peg$c476 = "tau",
      peg$c477 = peg$literalExpectation("tau", true),
      peg$c478 = "gamma",
      peg$c479 = peg$literalExpectation("gamma", true),
      peg$c480 = "natual",
      peg$c481 = peg$literalExpectation("natual", true),
      peg$c482 = "semi",
      peg$c483 = peg$literalExpectation("semi", true),
      peg$c484 = "anti",
      peg$c485 = peg$literalExpectation("anti", true),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsestart() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseroot();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseroot();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse__();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseroot();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parseEOF() {
    var s0, s1;

    s0 = peg$currPos;
    peg$silentFails++;
    if (input.length > peg$currPos) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1); }
    }
    peg$silentFails--;
    if (s1 === peg$FAILED) {
      s0 = void 0;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseendOfLine() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c2) {
      s0 = peg$c2;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c3); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c4;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
    }

    return s0;
  }

  function peg$parsecomment() {
    var s0;

    s0 = peg$parsesingleLineComment();
    if (s0 === peg$FAILED) {
      s0 = peg$parsemultiLineComment();
    }

    return s0;
  }

  function peg$parsesingleLineComment() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c7) {
      s1 = peg$c7;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c8); }
    }
    if (s1 !== peg$FAILED) {
      if (peg$c9.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c10); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseendOfLine();
        if (s4 === peg$FAILED) {
          s4 = peg$parseEOF();
        }
        peg$silentFails--;
        if (s4 !== peg$FAILED) {
          peg$currPos = s3;
          s3 = void 0;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c7) {
        s1 = peg$c7;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseendOfLine();
        if (s3 === peg$FAILED) {
          s3 = peg$parseEOF();
        }
        peg$silentFails--;
        if (s3 !== peg$FAILED) {
          peg$currPos = s2;
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c7) {
          s1 = peg$c7;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        if (s1 !== peg$FAILED) {
          if (peg$c9.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c10); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseendOfLine();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c1); }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parseendOfLine();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c1); }
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            if (s4 !== peg$FAILED) {
              s3 = input.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseendOfLine();
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              peg$silentFails--;
              if (s5 !== peg$FAILED) {
                peg$currPos = s4;
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c6); }
    }

    return s0;
  }

  function peg$parsemultiLineComment() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c11) {
      s1 = peg$c11;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c12); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (input.substr(peg$currPos, 2) === peg$c13) {
        s5 = peg$c13;
        peg$currPos += 2;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1); }
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c13) {
          s5 = peg$c13;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c14); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c1); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c13) {
          s3 = peg$c13;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c14); }
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parse__() {
    var s0, s1, s2, s3, s4, s5, s6;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = [];
    s4 = peg$parsecomment();
    while (s4 !== peg$FAILED) {
      s3.push(s4);
      s4 = peg$parsecomment();
    }
    if (s3 !== peg$FAILED) {
      s4 = [];
      if (peg$c16.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c17); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c16.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c17); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = [];
        s6 = peg$parsecomment();
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          s6 = peg$parsecomment();
        }
        if (s5 !== peg$FAILED) {
          s3 = [s3, s4, s5];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$parsecomment();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsecomment();
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c16.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c17); }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c16.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c17); }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsecomment();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsecomment();
            }
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c18();
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c15); }
    }

    return s0;
  }

  function peg$parse_() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    s1 = peg$parsecomment();
    if (s1 === peg$FAILED) {
      if (peg$c16.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c17); }
      }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parsecomment();
      if (s1 === peg$FAILED) {
        if (peg$c16.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c17); }
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c19); }
    }

    return s0;
  }

  function peg$parse__nc() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c21.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c22); }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c21.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c22); }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c20); }
    }

    return s0;
  }

  function peg$parse_nc() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c21.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c22); }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      if (peg$c21.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c22); }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c23); }
    }

    return s0;
  }

  function peg$parsestring() {
    var s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c25;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c26); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c27.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (peg$c27.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c25;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c29();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c30;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c31); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        if (peg$c32.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c33); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c32.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c33); }
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = input.substring(s2, peg$currPos);
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c30;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c31); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c34(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c24); }
    }

    return s0;
  }

  function peg$parseinteger() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s3 = peg$c35;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c36); }
    }
    if (s3 === peg$FAILED) {
      s3 = null;
    }
    if (s3 !== peg$FAILED) {
      s4 = [];
      if (peg$c37.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c37.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c39(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsefloat() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s3 = peg$c35;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c36); }
    }
    if (s3 === peg$FAILED) {
      s3 = null;
    }
    if (s3 !== peg$FAILED) {
      s4 = [];
      if (peg$c37.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c37.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s5 = peg$c40;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c41); }
        }
        if (s5 !== peg$FAILED) {
          s6 = [];
          if (peg$c37.test(input.charAt(peg$currPos))) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s7 !== peg$FAILED) {
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              if (peg$c37.test(input.charAt(peg$currPos))) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
            }
          } else {
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            s3 = [s3, s4, s5, s6];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c42(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsenumber() {
    var s0;

    s0 = peg$parsefloat();
    if (s0 === peg$FAILED) {
      s0 = peg$parseinteger();
    }

    return s0;
  }

  function peg$parseboolean() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c43) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c44); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c45();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c46) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c48();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parserelationName() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parseRESERVED_KEYWORD_RELALG();
    if (s3 !== peg$FAILED) {
      s4 = peg$currPos;
      peg$silentFails++;
      s5 = [];
      if (peg$c50.test(input.charAt(peg$currPos))) {
        s6 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s6 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s6 !== peg$FAILED) {
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
        }
      } else {
        s5 = peg$FAILED;
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = [];
      if (peg$c52.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c52.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$currPos;
        s6 = [];
        if (peg$c50.test(input.charAt(peg$currPos))) {
          s7 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s7 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c51); }
        }
        while (s7 !== peg$FAILED) {
          s6.push(s7);
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
        }
        if (s6 !== peg$FAILED) {
          s5 = input.substring(s5, peg$currPos);
        } else {
          s5 = s6;
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c49); }
    }

    return s0;
  }

  function peg$parseunqualifiedColumnName() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parseRESERVED_KEYWORD_RELALG();
    if (s3 !== peg$FAILED) {
      s4 = peg$currPos;
      peg$silentFails++;
      s5 = [];
      if (peg$c50.test(input.charAt(peg$currPos))) {
        s6 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s6 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s6 !== peg$FAILED) {
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
        }
      } else {
        s5 = peg$FAILED;
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = [];
      if (peg$c52.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c52.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$currPos;
        s6 = [];
        if (peg$c50.test(input.charAt(peg$currPos))) {
          s7 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s7 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c51); }
        }
        while (s7 !== peg$FAILED) {
          s6.push(s7);
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
        }
        if (s6 !== peg$FAILED) {
          s5 = input.substring(s5, peg$currPos);
        } else {
          s5 = s6;
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c55(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parserelation() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parserelationName();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c56(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsedateStr() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c57) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c58); }
    }
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c59) {
        s2 = peg$c59;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c60); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedate();
        if (s3 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c61) {
            s4 = peg$c61;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c62); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c63(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsedate() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$currPos;
    if (peg$c37.test(input.charAt(peg$currPos))) {
      s3 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c38); }
    }
    if (s3 !== peg$FAILED) {
      if (peg$c37.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s4 !== peg$FAILED) {
        if (peg$c37.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s5 !== peg$FAILED) {
          if (peg$c37.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s6 !== peg$FAILED) {
            s3 = [s3, s4, s5, s6];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c35;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$currPos;
        if (peg$c37.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s5 !== peg$FAILED) {
          if (peg$c37.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = input.substring(s3, peg$currPos);
        } else {
          s3 = s4;
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s4 = peg$c35;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$currPos;
            if (peg$c37.test(input.charAt(peg$currPos))) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c38); }
            }
            if (s7 !== peg$FAILED) {
              if (peg$c37.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s5 = input.substring(s5, peg$currPos);
            } else {
              s5 = s6;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c65(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c64); }
    }

    return s0;
  }

  function peg$parsecolumnName() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parserelationName();
    if (s2 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 46) {
        s3 = peg$c40;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c41); }
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseunqualifiedColumnName();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c66(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecolumnAsterisk() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parserelationName();
    if (s2 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 46) {
        s3 = peg$c40;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c41); }
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 42) {
        s2 = peg$c67;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c68); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c69(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecolumnIndex() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = [];
    if (peg$c37.test(input.charAt(peg$currPos))) {
      s3 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c38); }
    }
    if (s3 !== peg$FAILED) {
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (peg$c37.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
      }
    } else {
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c70(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseaggFunction() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c71) {
      s2 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c72); }
    }
    if (s2 === peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c73) {
        s2 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c74); }
      }
      if (s2 === peg$FAILED) {
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c75) {
          s2 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c76); }
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c77) {
            s2 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c78); }
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c79) {
              s2 = input.substr(peg$currPos, 3);
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c80); }
            }
          }
        }
      }
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c81;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {
            s5 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c84); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecolumnName();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s7 = peg$c85;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c86); }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c87(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c88) {
        s1 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c89); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c90();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsecolumnForSelect() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseaggFunction();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {
          s3 = input.substr(peg$currPos, 2);
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c92); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseunqualifiedColumnName();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c93(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseaggFunction();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c94(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsecolumnAsterisk();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c95(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecolumnName();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse__();
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {
                s3 = input.substr(peg$currPos, 2);
                peg$currPos += 2;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c92); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse__();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseunqualifiedColumnName();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c96(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseexpr_precedence9();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse__();
              if (s2 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {
                  s3 = input.substr(peg$currPos, 2);
                  peg$currPos += 2;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c92); }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse__();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseunqualifiedColumnName();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c97(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsecolumnName();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c95(s1);
              }
              s0 = s1;
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseselectArg() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parsecolumnForSelect();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c98;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c99); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecolumnForSelect();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c98;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c99); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecolumnForSelect();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c100(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parselistOfColumnNames() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parsecolumnName();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c98;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c99); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecolumnName();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c98;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c99); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecolumnName();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c101(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseorderDirection() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c102) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c103); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c104();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c105) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c106); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c107();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseorderByArg() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsecolumnName();
    if (s1 === peg$FAILED) {
      s1 = peg$parsecolumnIndex();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseorderDirection();
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c108(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parselistOfOrderByArgs() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseorderByArg();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c98;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c99); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseorderByArg();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c98;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c99); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseorderByArg();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c109(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parselistOfGroupByArgs() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parsecolumnName();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c98;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c99); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecolumnName();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c98;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c99); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecolumnName();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c110(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsewithClauseArgument() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parserelationName();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {
          s3 = input.substr(peg$currPos, 2);
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c92); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s5 = peg$c81;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c82); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsecompound_operator_precedence_3();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s7 = peg$c85;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c86); }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c111(s1, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseroot() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parsewithClause();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecompound_operator_precedence_3();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 59) {
              s5 = peg$c112;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c113); }
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c114(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsewithClause() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c116); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsewithClauseArgument();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s7 = peg$c98;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c99); }
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsewithClauseArgument();
                if (s9 !== peg$FAILED) {
                  s6 = [s6, s7, s8, s9];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c98;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c99); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsewithClauseArgument();
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c117(s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c118) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c119); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c120) {
          s4 = input.substr(peg$currPos, 8);
          peg$currPos += 8;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c121); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseselectArg();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c122(s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseorderBy() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c123) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c124); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c125) {
          s3 = input.substr(peg$currPos, 2);
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c126); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parselistOfOrderByArgs();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c127(s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecompound_operator_precedence_3() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parsecompound_operator_precedence_2();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseorderBy();
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parselimit();
          if (s5 === peg$FAILED) {
            s5 = peg$parsefetchFirst();
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c128(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsecompound_operator_precedence_2();
    }

    return s0;
  }

  function peg$parsecompound_operator_precedence_2() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsecompound_operator_precedence_1();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseunion();
      if (s3 === peg$FAILED) {
        s3 = peg$parseexcept();
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseunion();
          if (s3 === peg$FAILED) {
            s3 = peg$parseexcept();
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c129(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsecompound_operator_precedence_1();
    }

    return s0;
  }

  function peg$parsecompound_operator_precedence_1() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsecompound_operator_precedence_0();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseintersect();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseintersect();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c129(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsecompound_operator_precedence_0();
    }

    return s0;
  }

  function peg$parsecompound_operator_precedence_0() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

    s0 = peg$currPos;
    s1 = peg$parseselect();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c130) {
          s3 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c131); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsefrom_item_precedence_1();
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              s7 = peg$parse__();
              if (s7 !== peg$FAILED) {
                s8 = peg$parsewhere();
                if (s8 !== peg$FAILED) {
                  s7 = [s7, s8];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$currPos;
                s8 = peg$parse__();
                if (s8 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 5).toLowerCase() === peg$c132) {
                    s9 = input.substr(peg$currPos, 5);
                    peg$currPos += 5;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c133); }
                  }
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse__();
                    if (s10 !== peg$FAILED) {
                      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c125) {
                        s11 = input.substr(peg$currPos, 2);
                        peg$currPos += 2;
                      } else {
                        s11 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c126); }
                      }
                      if (s11 !== peg$FAILED) {
                        s12 = peg$parse__();
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parselistOfGroupByArgs();
                          if (s13 !== peg$FAILED) {
                            s8 = [s8, s9, s10, s11, s12, s13];
                            s7 = s8;
                          } else {
                            peg$currPos = s7;
                            s7 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$currPos;
                  s9 = peg$parse__();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parsehaving();
                    if (s10 !== peg$FAILED) {
                      s9 = [s9, s10];
                      s8 = s9;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 === peg$FAILED) {
                    s8 = null;
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c134(s1, s5, s6, s7, s8);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c81;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecompound_operator_precedence_3();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c85;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c86); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c135(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseunion() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c136) {
        s2 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c137); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {
            s5 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c138); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s4;
              s5 = peg$c45();
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            s4 = peg$currPos;
            if (input.substr(peg$currPos, 8).toLowerCase() === peg$c120) {
              s5 = input.substr(peg$currPos, 8);
              peg$currPos += 8;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c121); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s4;
                s5 = peg$c48();
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecompound_operator_precedence_1();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c139(s4, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexcept() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c140) {
        s2 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c141); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {
            s5 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c138); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s4;
              s5 = peg$c45();
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            s4 = peg$currPos;
            if (input.substr(peg$currPos, 8).toLowerCase() === peg$c120) {
              s5 = input.substr(peg$currPos, 8);
              peg$currPos += 8;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c121); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s4;
                s5 = peg$c48();
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecompound_operator_precedence_1();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c142(s4, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseintersect() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c143) {
        s2 = input.substr(peg$currPos, 9);
        peg$currPos += 9;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c144); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {
            s5 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c138); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s4;
              s5 = peg$c45();
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            s4 = peg$currPos;
            if (input.substr(peg$currPos, 8).toLowerCase() === peg$c120) {
              s5 = input.substr(peg$currPos, 8);
              peg$currPos += 8;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c121); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s4;
                s5 = peg$c48();
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecompound_operator_precedence_1();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c145(s4, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsefrom_item_precedence_1() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsefrom_item_precedence_0();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsecrossJoin();
      if (s3 === peg$FAILED) {
        s3 = peg$parsenaturalJoin();
        if (s3 === peg$FAILED) {
          s3 = peg$parseinnerAndOuterJoins();
        }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsecrossJoin();
          if (s3 === peg$FAILED) {
            s3 = peg$parsenaturalJoin();
            if (s3 === peg$FAILED) {
              s3 = peg$parseinnerAndOuterJoins();
            }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c129(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsefrom_item_precedence_0();
    }

    return s0;
  }

  function peg$parsefrom_item_precedence_0() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    s0 = peg$currPos;
    s1 = peg$parserelationName();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {
          s4 = input.substr(peg$currPos, 2);
          peg$currPos += 2;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c92); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            s6 = peg$parserelationName();
            if (s6 !== peg$FAILED) {
              s3 = [s3, s4, s5, s6];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c146(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c81;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecompound_operator_precedence_3();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c85;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c86); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {
                    s7 = input.substr(peg$currPos, 2);
                    peg$currPos += 2;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c92); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parserelationName();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c147(s3, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c81;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c82); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsefrom_item_precedence_1();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c85;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c86); }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c135(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parsecrossJoin() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parse__();
    if (s2 !== peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c148) {
        s3 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c149); }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {
            s5 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c151); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s2 = [s2, s3, s4, s5, s6];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s3 = peg$c98;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c99); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsefrom_item_precedence_0();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c152(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenaturalJoin() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c153) {
        s2 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c154); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {
            s4 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c151); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsefrom_item_precedence_0();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c155(s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseinnerAndOuterJoins() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;

    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c156) {
        s4 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c157); }
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parse__();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      if (s3 !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {
          s4 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c151); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c158();
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c159) {
          s4 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c160); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {
              s7 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c162); }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {
                s7 = input.substr(peg$currPos, 4);
                peg$currPos += 4;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c151); }
              }
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c163();
        }
        s2 = s3;
        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c164) {
            s4 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c165); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {
                s7 = input.substr(peg$currPos, 5);
                peg$currPos += 5;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c162); }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {
                  s7 = input.substr(peg$currPos, 4);
                  peg$currPos += 4;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c151); }
                }
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c166();
          }
          s2 = s3;
          if (s2 === peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$currPos;
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c167) {
              s4 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c168); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {
                  s7 = input.substr(peg$currPos, 5);
                  peg$currPos += 5;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c162); }
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {
                    s7 = input.substr(peg$currPos, 4);
                    peg$currPos += 4;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c151); }
                  }
                  if (s7 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c169();
            }
            s2 = s3;
          }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsefrom_item_precedence_0();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              if (input.substr(peg$currPos, 2).toLowerCase() === peg$c170) {
                s7 = input.substr(peg$currPos, 2);
                peg$currPos += 2;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c171); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse__();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsebooleanExpr();
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s7 = peg$c172(s2, s4, s9);
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 === peg$FAILED) {
                s6 = peg$currPos;
                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c173) {
                  s7 = input.substr(peg$currPos, 5);
                  peg$currPos += 5;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c174); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 40) {
                      s9 = peg$c81;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c82); }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseunqualifiedColumnName();
                        if (s11 !== peg$FAILED) {
                          s12 = [];
                          s13 = peg$currPos;
                          s14 = peg$parse_();
                          if (s14 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                              s15 = peg$c98;
                              peg$currPos++;
                            } else {
                              s15 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c99); }
                            }
                            if (s15 !== peg$FAILED) {
                              s16 = peg$parse_();
                              if (s16 !== peg$FAILED) {
                                s17 = peg$parseunqualifiedColumnName();
                                if (s17 !== peg$FAILED) {
                                  s14 = [s14, s15, s16, s17];
                                  s13 = s14;
                                } else {
                                  peg$currPos = s13;
                                  s13 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s13;
                                s13 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s13;
                              s13 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s13;
                            s13 = peg$FAILED;
                          }
                          while (s13 !== peg$FAILED) {
                            s12.push(s13);
                            s13 = peg$currPos;
                            s14 = peg$parse_();
                            if (s14 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 44) {
                                s15 = peg$c98;
                                peg$currPos++;
                              } else {
                                s15 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c99); }
                              }
                              if (s15 !== peg$FAILED) {
                                s16 = peg$parse_();
                                if (s16 !== peg$FAILED) {
                                  s17 = peg$parseunqualifiedColumnName();
                                  if (s17 !== peg$FAILED) {
                                    s14 = [s14, s15, s16, s17];
                                    s13 = s14;
                                  } else {
                                    peg$currPos = s13;
                                    s13 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s13;
                                  s13 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s13;
                                s13 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s13;
                              s13 = peg$FAILED;
                            }
                          }
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse_();
                            if (s13 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 41) {
                                s14 = peg$c85;
                                peg$currPos++;
                              } else {
                                s14 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c86); }
                              }
                              if (s14 !== peg$FAILED) {
                                peg$savedPos = s6;
                                s7 = peg$c175(s2, s4, s11, s12);
                                s6 = s7;
                              } else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s6;
                              s6 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 === peg$FAILED) {
                  s6 = peg$currPos;
                  if (input.substr(peg$currPos, 7).toLowerCase() === peg$c153) {
                    s7 = input.substr(peg$currPos, 7);
                    peg$currPos += 7;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c154); }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s7 = peg$c176(s2, s4);
                  }
                  s6 = s7;
                }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c177(s2, s4, s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsewhere() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c178) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c179); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsebooleanExpr();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c180(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsehaving() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c181) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c182); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsebooleanExpr();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c183(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parselimitArg() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c138); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c184();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseinteger();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c185(s1);
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parselimit() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c186) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c187); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseinteger();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c98;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c99); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parselimitArg();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c188(s3, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c186) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c187); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parselimitArg();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 6).toLowerCase() === peg$c189) {
                s5 = input.substr(peg$currPos, 6);
                peg$currPos += 6;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c190); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseinteger();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c191(s3, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c186) {
          s1 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c187); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parselimitArg();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c192(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parsefetchFirstOffset() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c189) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c190); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseinteger();
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c193) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c194); }
            }
            if (s6 === peg$FAILED) {
              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c195) {
                s6 = input.substr(peg$currPos, 3);
                peg$currPos += 3;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c196); }
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c197(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsefetchFirstLimit() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c198) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c199); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c200) {
          s3 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c201); }
        }
        if (s3 === peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c202) {
            s3 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c203); }
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseinteger();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c193) {
                  s7 = input.substr(peg$currPos, 4);
                  peg$currPos += 4;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c194); }
                }
                if (s7 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3).toLowerCase() === peg$c195) {
                    s7 = input.substr(peg$currPos, 3);
                    peg$currPos += 3;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c196); }
                  }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c204) {
                      s9 = input.substr(peg$currPos, 4);
                      peg$currPos += 4;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c205); }
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c206(s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsefetchFirst() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parsefetchFirstOffset();
    if (s2 !== peg$FAILED) {
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsefetchFirstLimit();
        if (s4 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c207(s2, s4);
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      s2 = peg$parsefetchFirstOffset();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c208(s2);
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$parsefetchFirstLimit();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c209(s2);
        }
        s1 = s2;
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c210(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecomparisonOperators() {
    var s0;

    s0 = peg$parsecomparisonOperatorEquals();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecomparisonOperatorNotEquals();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecomparisonOperatorGreaterEquals();
        if (s0 === peg$FAILED) {
          s0 = peg$parsecomparisonOperatorLesserEquals();
          if (s0 === peg$FAILED) {
            s0 = peg$parsecomparisonOperatorGreater();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecomparisonOperatorLesser();
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsecomparisonOperatorsIsOrIsNot() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c211) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c212); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c213) {
          s3 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c214); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c215();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c211) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c212); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c216();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsecomparisonOperatorEquals() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 61) {
      s0 = peg$c217;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c218); }
    }

    return s0;
  }

  function peg$parsecomparisonOperatorNotEquals() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c219) {
      s1 = peg$c219;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c220); }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c221) {
        s1 = peg$c221;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c222); }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c215();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecomparisonOperatorGreaterEquals() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c223) {
      s1 = peg$c223;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c224); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c225();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecomparisonOperatorGreater() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 62) {
      s0 = peg$c226;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c227); }
    }

    return s0;
  }

  function peg$parsecomparisonOperatorLesserEquals() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c228) {
      s1 = peg$c228;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c229); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c230();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecomparisonOperatorLesser() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 60) {
      s0 = peg$c231;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c232); }
    }

    return s0;
  }

  function peg$parseand() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c234) {
        s2 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c235); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c236();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c233); }
    }

    return s0;
  }

  function peg$parsexor() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c238) {
        s2 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c239); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c237); }
    }

    return s0;
  }

  function peg$parseor() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c241) {
        s2 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c242); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c243();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c240); }
    }

    return s0;
  }

  function peg$parsenot() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 33) {
        s2 = peg$c245;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c246); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c247();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c244); }
    }

    return s0;
  }

  function peg$parsesubquery_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c213) {
      s2 = peg$c213;
      peg$currPos += 3;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c248); }
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c249) {
        s2 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c250); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s4 = peg$c81;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c82); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsecompound_operator_precedence_3();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s8 = peg$c85;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c86); }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c251(s1, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsedumpComment() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_nc();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecomment();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_nc();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 59) {
            s4 = peg$c112;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c113); }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c252();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c253;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c254); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_nc();
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c255.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c256); }
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c255.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c256); }
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
              s4 = peg$c4;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c5); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c252();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsedumpTableName() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 96) {
      s1 = peg$c257;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c258); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parserelationName();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 96) {
          s3 = peg$c257;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c258); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c34(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parserelationName();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c34(s1);
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsedropTable() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c259) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c260); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__nc();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c261) {
          s3 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c262); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__nc();
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            if (input.substr(peg$currPos, 2).toLowerCase() === peg$c263) {
              s6 = input.substr(peg$currPos, 2);
              peg$currPos += 2;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c264); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse__nc();
              if (s7 !== peg$FAILED) {
                if (input.substr(peg$currPos, 6).toLowerCase() === peg$c249) {
                  s8 = input.substr(peg$currPos, 6);
                  peg$currPos += 6;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c250); }
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse__nc();
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsedumpTableName();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_nc();
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s8 = peg$c112;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c113); }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c265();
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parselockTables() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c266) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c267); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__nc();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c268) {
          s3 = input.substr(peg$currPos, 6);
          peg$currPos += 6;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c269); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__nc();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsedumpTableName();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__nc();
              if (s6 !== peg$FAILED) {
                s7 = [];
                if (peg$c52.test(input.charAt(peg$currPos))) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c53); }
                }
                if (s8 !== peg$FAILED) {
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    if (peg$c52.test(input.charAt(peg$currPos))) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c53); }
                    }
                  }
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_nc();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 59) {
                      s9 = peg$c112;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c113); }
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c270();
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseunlockTables() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c271) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c272); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__nc();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c268) {
          s3 = input.substr(peg$currPos, 6);
          peg$currPos += 6;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c269); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_nc();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 59) {
              s5 = peg$c112;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c113); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c273();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsedbDumpRoot() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parse_nc();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseuseDbStatement();
      if (s4 === peg$FAILED) {
        s4 = peg$parselockTables();
        if (s4 === peg$FAILED) {
          s4 = peg$parseunlockTables();
          if (s4 === peg$FAILED) {
            s4 = peg$parsedumpComment();
            if (s4 === peg$FAILED) {
              s4 = peg$parsedropTable();
              if (s4 === peg$FAILED) {
                s4 = peg$parsecreateTableStmt();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseinsertStmt();
                }
              }
            }
          }
        }
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parse_nc();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseuseDbStatement();
          if (s4 === peg$FAILED) {
            s4 = peg$parselockTables();
            if (s4 === peg$FAILED) {
              s4 = peg$parseunlockTables();
              if (s4 === peg$FAILED) {
                s4 = peg$parsedumpComment();
                if (s4 === peg$FAILED) {
                  s4 = peg$parsedropTable();
                  if (s4 === peg$FAILED) {
                    s4 = peg$parsecreateTableStmt();
                    if (s4 === peg$FAILED) {
                      s4 = peg$parseinsertStmt();
                    }
                  }
                }
              }
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_nc();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_nc();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c274(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseuseDbStatement() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c275) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c276); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        if (peg$c277.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c278); }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c277.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c278); }
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = input.substring(s3, peg$currPos);
        } else {
          s3 = s4;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 59) {
              s5 = peg$c112;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c113); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c279(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreateTableStmt_columnType() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c280) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c281); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s3 = peg$c81;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parse_nc();
        if (s4 !== peg$FAILED) {
          s5 = [];
          if (peg$c37.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s6 !== peg$FAILED) {
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              if (peg$c37.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
            }
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_nc();
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c98;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c99); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_nc();
                if (s8 !== peg$FAILED) {
                  s9 = [];
                  if (peg$c37.test(input.charAt(peg$currPos))) {
                    s10 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
                  }
                  if (s10 !== peg$FAILED) {
                    while (s10 !== peg$FAILED) {
                      s9.push(s10);
                      if (peg$c37.test(input.charAt(peg$currPos))) {
                        s10 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c38); }
                      }
                    }
                  } else {
                    s9 = peg$FAILED;
                  }
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse_nc();
                    if (s10 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s11 = peg$c85;
                        peg$currPos++;
                      } else {
                        s11 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c86); }
                      }
                      if (s11 !== peg$FAILED) {
                        s3 = [s3, s4, s5, s6, s7, s8, s9, s10, s11];
                        s2 = s3;
                      } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c282();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c283) {
        s1 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c284); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c285) {
          s1 = input.substr(peg$currPos, 8);
          peg$currPos += 8;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c286); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 9).toLowerCase() === peg$c287) {
            s1 = input.substr(peg$currPos, 9);
            peg$currPos += 9;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c288); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c289) {
              s1 = input.substr(peg$currPos, 6);
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c290); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 7).toLowerCase() === peg$c291) {
                s1 = input.substr(peg$currPos, 7);
                peg$currPos += 7;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c292); }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c293) {
                  s1 = input.substr(peg$currPos, 3);
                  peg$currPos += 3;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c294); }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7).toLowerCase() === peg$c280) {
                    s1 = input.substr(peg$currPos, 7);
                    peg$currPos += 7;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c281); }
                  }
                }
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c81;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c82); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_nc();
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$c37.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c38); }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$c37.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c38); }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_nc();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s7 = peg$c85;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c86); }
                }
                if (s7 !== peg$FAILED) {
                  s3 = [s3, s4, s5, s6, s7];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c282();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c295) {
          s1 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c296); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 6).toLowerCase() === peg$c297) {
            s1 = input.substr(peg$currPos, 6);
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c298); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c280) {
              s1 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c281); }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c81;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c82); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            if (peg$c37.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c38); }
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$c37.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c38); }
                }
              }
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s6 = peg$c98;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c99); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = [];
                    if (peg$c37.test(input.charAt(peg$currPos))) {
                      s9 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c38); }
                    }
                    if (s9 !== peg$FAILED) {
                      while (s9 !== peg$FAILED) {
                        s8.push(s9);
                        if (peg$c37.test(input.charAt(peg$currPos))) {
                          s9 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c38); }
                        }
                      }
                    } else {
                      s8 = peg$FAILED;
                    }
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s9 = peg$c85;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c86); }
                      }
                      if (s9 !== peg$FAILED) {
                        s3 = [s3, s4, s5, s6, s7, s8, s9];
                        s2 = s3;
                      } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c282();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7).toLowerCase() === peg$c299) {
            s1 = input.substr(peg$currPos, 7);
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c300); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c301) {
              s1 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c302); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c303) {
                s1 = input.substr(peg$currPos, 4);
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c304); }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
              s3 = peg$c81;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c82); }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              if (peg$c37.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  if (peg$c37.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
                  }
                }
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c85;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c86); }
                }
                if (s5 !== peg$FAILED) {
                  s3 = [s3, s4, s5];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c305();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 8).toLowerCase() === peg$c306) {
              s0 = input.substr(peg$currPos, 8);
              peg$currPos += 8;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c307); }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c57) {
                s1 = input.substr(peg$currPos, 4);
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c58); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c308();
              }
              s0 = s1;
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsecreateTableStmt_ignore() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c309.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c310); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c309.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c310); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c311();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c81;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_nc();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsedumpTableName();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_nc();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c98;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c99); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_nc();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsedumpTableName();
                  if (s9 !== peg$FAILED) {
                    s7 = [s7, s8, s9];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c98;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c99); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_nc();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsedumpTableName();
                    if (s9 !== peg$FAILED) {
                      s7 = [s7, s8, s9];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_nc();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c85;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c86); }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c311();
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedumpTableName();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c311();
        }
        s0 = s1;
      }
    }

    return s0;
  }

  function peg$parsecreateTableStmt_column() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parsedumpTableName();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__nc();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecreateTableStmt_columnType();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parse__nc();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecreateTableStmt_ignore();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$parse__nc();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecreateTableStmt_ignore();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c312(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreateTableStmt_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      s1 = peg$c81;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c82); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_nc();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecreateTableStmt_column();
        if (s3 === peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parse_nc();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsecreateTableStmt_ignore();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              s5 = peg$parse_nc();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsecreateTableStmt_ignore();
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }
          } else {
            s3 = peg$FAILED;
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parse_nc();
          if (s6 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s7 = peg$c98;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c99); }
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_nc();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsecreateTableStmt_column();
                if (s9 === peg$FAILED) {
                  s9 = [];
                  s10 = peg$currPos;
                  s11 = peg$parse_nc();
                  if (s11 !== peg$FAILED) {
                    s12 = peg$parsecreateTableStmt_ignore();
                    if (s12 !== peg$FAILED) {
                      s11 = [s11, s12];
                      s10 = s11;
                    } else {
                      peg$currPos = s10;
                      s10 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s10;
                    s10 = peg$FAILED;
                  }
                  if (s10 !== peg$FAILED) {
                    while (s10 !== peg$FAILED) {
                      s9.push(s10);
                      s10 = peg$currPos;
                      s11 = peg$parse_nc();
                      if (s11 !== peg$FAILED) {
                        s12 = peg$parsecreateTableStmt_ignore();
                        if (s12 !== peg$FAILED) {
                          s11 = [s11, s12];
                          s10 = s11;
                        } else {
                          peg$currPos = s10;
                          s10 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s10;
                        s10 = peg$FAILED;
                      }
                    }
                  } else {
                    s9 = peg$FAILED;
                  }
                }
                if (s9 !== peg$FAILED) {
                  s6 = [s6, s7, s8, s9];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$parse_nc();
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c98;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c99); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_nc();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsecreateTableStmt_column();
                  if (s9 === peg$FAILED) {
                    s9 = [];
                    s10 = peg$currPos;
                    s11 = peg$parse_nc();
                    if (s11 !== peg$FAILED) {
                      s12 = peg$parsecreateTableStmt_ignore();
                      if (s12 !== peg$FAILED) {
                        s11 = [s11, s12];
                        s10 = s11;
                      } else {
                        peg$currPos = s10;
                        s10 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s10;
                      s10 = peg$FAILED;
                    }
                    if (s10 !== peg$FAILED) {
                      while (s10 !== peg$FAILED) {
                        s9.push(s10);
                        s10 = peg$currPos;
                        s11 = peg$parse_nc();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parsecreateTableStmt_ignore();
                          if (s12 !== peg$FAILED) {
                            s11 = [s11, s12];
                            s10 = s11;
                          } else {
                            peg$currPos = s10;
                            s10 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s10;
                          s10 = peg$FAILED;
                        }
                      }
                    } else {
                      s9 = peg$FAILED;
                    }
                  }
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_nc();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c85;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c86); }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c313(s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreateTableStmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c314) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c315); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c261) {
          s3 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c262); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            if (input.substr(peg$currPos, 2).toLowerCase() === peg$c263) {
              s6 = input.substr(peg$currPos, 2);
              peg$currPos += 2;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c264); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse__();
              if (s7 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c213) {
                  s8 = input.substr(peg$currPos, 3);
                  peg$currPos += 3;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c214); }
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse__();
                  if (s9 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c249) {
                      s10 = peg$c249;
                      peg$currPos += 6;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c316); }
                    }
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse__();
                      if (s11 !== peg$FAILED) {
                        s6 = [s6, s7, s8, s9, s10, s11];
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsedumpTableName();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_nc();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsecreateTableStmt_list();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_nc();
                    if (s9 !== peg$FAILED) {
                      s10 = [];
                      s11 = peg$currPos;
                      s12 = peg$parse_nc();
                      if (s12 !== peg$FAILED) {
                        s13 = peg$parsecreateTableStmt_ignore();
                        if (s13 !== peg$FAILED) {
                          s12 = [s12, s13];
                          s11 = s12;
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s11;
                        s11 = peg$FAILED;
                      }
                      while (s11 !== peg$FAILED) {
                        s10.push(s11);
                        s11 = peg$currPos;
                        s12 = peg$parse_nc();
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parsecreateTableStmt_ignore();
                          if (s13 !== peg$FAILED) {
                            s12 = [s12, s13];
                            s11 = s12;
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                      }
                      if (s10 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 59) {
                          s11 = peg$c112;
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c113); }
                        }
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c317(s6, s8);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseinsertStmt_value_null() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c318) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c319); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c311();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseinsertStmt_values() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      s1 = peg$c81;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c82); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsenumber();
        if (s3 === peg$FAILED) {
          s3 = peg$parsestring();
          if (s3 === peg$FAILED) {
            s3 = peg$parsedateStr();
            if (s3 === peg$FAILED) {
              s3 = peg$parseinsertStmt_value_null();
            }
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s7 = peg$c98;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c99); }
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsenumber();
                if (s9 === peg$FAILED) {
                  s9 = peg$parsestring();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parsedateStr();
                    if (s9 === peg$FAILED) {
                      s9 = peg$parseinsertStmt_value_null();
                    }
                  }
                }
                if (s9 !== peg$FAILED) {
                  s6 = [s6, s7, s8, s9];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c98;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c99); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsenumber();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parsestring();
                    if (s9 === peg$FAILED) {
                      s9 = peg$parsedateStr();
                      if (s9 === peg$FAILED) {
                        s9 = peg$parseinsertStmt_value_null();
                      }
                    }
                  }
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c85;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c86); }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c320(s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseinsertStmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c321) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c322); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c323) {
          s3 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c324); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsedumpTableName();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$currPos;
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 40) {
                    s9 = peg$c81;
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c82); }
                  }
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse_();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parsedumpTableName();
                      if (s11 !== peg$FAILED) {
                        s12 = [];
                        s13 = peg$currPos;
                        s14 = peg$parse_();
                        if (s14 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 44) {
                            s15 = peg$c98;
                            peg$currPos++;
                          } else {
                            s15 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c99); }
                          }
                          if (s15 !== peg$FAILED) {
                            s16 = peg$parse_();
                            if (s16 !== peg$FAILED) {
                              s17 = peg$parsedumpTableName();
                              if (s17 !== peg$FAILED) {
                                s14 = [s14, s15, s16, s17];
                                s13 = s14;
                              } else {
                                peg$currPos = s13;
                                s13 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s13;
                              s13 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s13;
                            s13 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s13;
                          s13 = peg$FAILED;
                        }
                        if (s13 !== peg$FAILED) {
                          while (s13 !== peg$FAILED) {
                            s12.push(s13);
                            s13 = peg$currPos;
                            s14 = peg$parse_();
                            if (s14 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 44) {
                                s15 = peg$c98;
                                peg$currPos++;
                              } else {
                                s15 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c99); }
                              }
                              if (s15 !== peg$FAILED) {
                                s16 = peg$parse_();
                                if (s16 !== peg$FAILED) {
                                  s17 = peg$parsedumpTableName();
                                  if (s17 !== peg$FAILED) {
                                    s14 = [s14, s15, s16, s17];
                                    s13 = s14;
                                  } else {
                                    peg$currPos = s13;
                                    s13 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s13;
                                  s13 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s13;
                                s13 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s13;
                              s13 = peg$FAILED;
                            }
                          }
                        } else {
                          s12 = peg$FAILED;
                        }
                        if (s12 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s13 = peg$c85;
                            peg$currPos++;
                          } else {
                            s13 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c86); }
                          }
                          if (s13 !== peg$FAILED) {
                            s14 = peg$parse__();
                            if (s14 !== peg$FAILED) {
                              s8 = [s8, s9, s10, s11, s12, s13, s14];
                              s7 = s8;
                            } else {
                              peg$currPos = s7;
                              s7 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s7;
                            s7 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 6).toLowerCase() === peg$c325) {
                    s8 = input.substr(peg$currPos, 6);
                    peg$currPos += 6;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c326); }
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseinsertStmt_values();
                      if (s10 !== peg$FAILED) {
                        s11 = [];
                        s12 = peg$currPos;
                        s13 = peg$parse_();
                        if (s13 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 44) {
                            s14 = peg$c98;
                            peg$currPos++;
                          } else {
                            s14 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c99); }
                          }
                          if (s14 !== peg$FAILED) {
                            s15 = peg$parse_();
                            if (s15 !== peg$FAILED) {
                              s16 = peg$parseinsertStmt_values();
                              if (s16 !== peg$FAILED) {
                                s13 = [s13, s14, s15, s16];
                                s12 = s13;
                              } else {
                                peg$currPos = s12;
                                s12 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s12;
                              s12 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s12;
                            s12 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s12;
                          s12 = peg$FAILED;
                        }
                        while (s12 !== peg$FAILED) {
                          s11.push(s12);
                          s12 = peg$currPos;
                          s13 = peg$parse_();
                          if (s13 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                              s14 = peg$c98;
                              peg$currPos++;
                            } else {
                              s14 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c99); }
                            }
                            if (s14 !== peg$FAILED) {
                              s15 = peg$parse_();
                              if (s15 !== peg$FAILED) {
                                s16 = peg$parseinsertStmt_values();
                                if (s16 !== peg$FAILED) {
                                  s13 = [s13, s14, s15, s16];
                                  s12 = s13;
                                } else {
                                  peg$currPos = s12;
                                  s12 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s12;
                                s12 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s12;
                              s12 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s12;
                            s12 = peg$FAILED;
                          }
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 59) {
                              s13 = peg$c112;
                              peg$currPos++;
                            } else {
                              s13 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c113); }
                            }
                            if (s13 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c327(s5, s7, s10, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsebooleanExpr() {
    var s0, s1;

    peg$silentFails++;
    s0 = peg$parseexpr_precedence9();
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c328); }
    }

    return s0;
  }

  function peg$parseexpr_rest_boolean_disj() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseor();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpr_precedence8();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c329(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_rest_string_concat() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c330) {
        s2 = peg$c330;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c331); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence8();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c332(s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_rest_boolean_xdisj() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsexor();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpr_precedence7();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c333(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_rest_boolean_conj() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseand();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpr_precedence6();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c334(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_rest_boolean_comparison() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecomparisonOperatorsIsOrIsNot();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsevalueExprConstantNull();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c335(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecomparisonOperators();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseexpr_precedence4();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c335(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c336) {
            s2 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c337); }
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c338) {
              s2 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c339); }
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsevalueExprConstants();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c340(s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parseexpr_rest_number_add() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c35;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s2 = peg$c341;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c342); }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence3();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c343(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_rest_number_mul() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 42) {
        s2 = peg$c67;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c68); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s2 = peg$c344;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c345); }
        }
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 37) {
            s2 = peg$c346;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c347); }
          }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence2();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c348(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_number_minus() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c35;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpr_precedence1();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c349(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_boolean_negation() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsenot();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpr_precedence0();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c350(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprFunctionsNary() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c351) {
      s2 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c352); }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = s1;
      s2 = peg$c353();
    }
    s1 = s2;
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c354) {
        s2 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c355); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c356();
      }
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c81;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence9();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s8 = peg$c98;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c99); }
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parseexpr_precedence9();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parse_();
                    if (s11 !== peg$FAILED) {
                      s8 = [s8, s9, s10, s11];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s8 = peg$c98;
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c99); }
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse_();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parseexpr_precedence9();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse_();
                      if (s11 !== peg$FAILED) {
                        s8 = [s8, s9, s10, s11];
                        s7 = s8;
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              }
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s7 = peg$c85;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c86); }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c357(s1, s4, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprFunctionsBinary() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c358) {
      s2 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c359); }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = s1;
      s2 = peg$c360();
    }
    s1 = s2;
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c361) {
        s2 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c362); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c363();
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c364) {
          s2 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c365); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c366();
        }
        s1 = s2;
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c367) {
            s2 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c368); }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c369();
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c370) {
              s2 = input.substr(peg$currPos, 3);
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c371); }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s1;
              s2 = peg$c372();
            }
            s1 = s2;
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c373) {
                s2 = input.substr(peg$currPos, 3);
                peg$currPos += 3;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c374); }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c375();
              }
              s1 = s2;
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c376) {
                  s2 = input.substr(peg$currPos, 3);
                  peg$currPos += 3;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c377); }
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c378();
                }
                s1 = s2;
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c81;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence9();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s6 = peg$c98;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c99); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseexpr_precedence9();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s10 = peg$c85;
                        peg$currPos++;
                      } else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c86); }
                      }
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c379(s1, s4, s8);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprFunctionsUnary() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c380) {
      s2 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c381); }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = s1;
      s2 = peg$c382();
    }
    s1 = s2;
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c383) {
        s2 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c384); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c382();
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c385) {
          s2 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c386); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c387();
        }
        s1 = s2;
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c388) {
            s2 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c389); }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c387();
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c390) {
              s2 = input.substr(peg$currPos, 6);
              peg$currPos += 6;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c391); }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s1;
              s2 = peg$c392();
            }
            s1 = s2;
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c393) {
                s2 = input.substr(peg$currPos, 3);
                peg$currPos += 3;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c394); }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c395();
              }
              s1 = s2;
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c396) {
                  s2 = input.substr(peg$currPos, 5);
                  peg$currPos += 5;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c397); }
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c398();
                }
                s1 = s2;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c399) {
                    s2 = input.substr(peg$currPos, 4);
                    peg$currPos += 4;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c400); }
                  }
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s2 = peg$c401();
                  }
                  s1 = s2;
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c402) {
                      s2 = input.substr(peg$currPos, 5);
                      peg$currPos += 5;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c403); }
                    }
                    if (s2 !== peg$FAILED) {
                      peg$savedPos = s1;
                      s2 = peg$c404();
                    }
                    s1 = s2;
                    if (s1 === peg$FAILED) {
                      s1 = peg$currPos;
                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c57) {
                        s2 = input.substr(peg$currPos, 4);
                        peg$currPos += 4;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c58); }
                      }
                      if (s2 !== peg$FAILED) {
                        peg$savedPos = s1;
                        s2 = peg$c405();
                      }
                      s1 = s2;
                      if (s1 === peg$FAILED) {
                        s1 = peg$currPos;
                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c406) {
                          s2 = input.substr(peg$currPos, 4);
                          peg$currPos += 4;
                        } else {
                          s2 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c407); }
                        }
                        if (s2 !== peg$FAILED) {
                          peg$savedPos = s1;
                          s2 = peg$c408();
                        }
                        s1 = s2;
                        if (s1 === peg$FAILED) {
                          s1 = peg$currPos;
                          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c409) {
                            s2 = input.substr(peg$currPos, 5);
                            peg$currPos += 5;
                          } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c410); }
                          }
                          if (s2 !== peg$FAILED) {
                            peg$savedPos = s1;
                            s2 = peg$c411();
                          }
                          s1 = s2;
                          if (s1 === peg$FAILED) {
                            s1 = peg$currPos;
                            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c412) {
                              s2 = input.substr(peg$currPos, 3);
                              peg$currPos += 3;
                            } else {
                              s2 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c413); }
                            }
                            if (s2 !== peg$FAILED) {
                              peg$savedPos = s1;
                              s2 = peg$c414();
                            }
                            s1 = s2;
                            if (s1 === peg$FAILED) {
                              s1 = peg$currPos;
                              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c415) {
                                s2 = input.substr(peg$currPos, 4);
                                peg$currPos += 4;
                              } else {
                                s2 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c416); }
                              }
                              if (s2 !== peg$FAILED) {
                                peg$savedPos = s1;
                                s2 = peg$c417();
                              }
                              s1 = s2;
                              if (s1 === peg$FAILED) {
                                s1 = peg$currPos;
                                if (input.substr(peg$currPos, 6).toLowerCase() === peg$c418) {
                                  s2 = input.substr(peg$currPos, 6);
                                  peg$currPos += 6;
                                } else {
                                  s2 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c419); }
                                }
                                if (s2 !== peg$FAILED) {
                                  peg$savedPos = s1;
                                  s2 = peg$c420();
                                }
                                s1 = s2;
                                if (s1 === peg$FAILED) {
                                  s1 = peg$currPos;
                                  if (input.substr(peg$currPos, 6).toLowerCase() === peg$c421) {
                                    s2 = input.substr(peg$currPos, 6);
                                    peg$currPos += 6;
                                  } else {
                                    s2 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c422); }
                                  }
                                  if (s2 !== peg$FAILED) {
                                    peg$savedPos = s1;
                                    s2 = peg$c423();
                                  }
                                  s1 = s2;
                                  if (s1 === peg$FAILED) {
                                    s1 = peg$currPos;
                                    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c424) {
                                      s2 = input.substr(peg$currPos, 10);
                                      peg$currPos += 10;
                                    } else {
                                      s2 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c425); }
                                    }
                                    if (s2 !== peg$FAILED) {
                                      peg$savedPos = s1;
                                      s2 = peg$c414();
                                    }
                                    s1 = s2;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c81;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpr_precedence9();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c85;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c86); }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c426(s1, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprFunctionsNullary() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c427) {
      s2 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c428); }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = s1;
      s2 = peg$c429();
    }
    s1 = s2;
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c430) {
        s2 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c431); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c432();
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c433) {
          s2 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c434); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c435();
        }
        s1 = s2;
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 17).toLowerCase() === peg$c436) {
            s2 = input.substr(peg$currPos, 17);
            peg$currPos += 17;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c437); }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c435();
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.substr(peg$currPos, 21).toLowerCase() === peg$c438) {
              s2 = input.substr(peg$currPos, 21);
              peg$currPos += 21;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c439); }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s1;
              s2 = peg$c440();
            }
            s1 = s2;
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.substr(peg$currPos, 19).toLowerCase() === peg$c441) {
                s2 = input.substr(peg$currPos, 19);
                peg$currPos += 19;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c442); }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c443();
              }
              s1 = s2;
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.substr(peg$currPos, 15).toLowerCase() === peg$c444) {
                  s2 = input.substr(peg$currPos, 15);
                  peg$currPos += 15;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c445); }
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c446();
                }
                s1 = s2;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  if (input.substr(peg$currPos, 7).toLowerCase() === peg$c447) {
                    s2 = input.substr(peg$currPos, 7);
                    peg$currPos += 7;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c448); }
                  }
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s2 = peg$c446();
                  }
                  s1 = s2;
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c81;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s4 = peg$c85;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c86); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c449(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprConstants() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parsenumber();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s1;
      s2 = peg$c450(s2);
    }
    s1 = s2;
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      s2 = peg$parseboolean();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c451(s2);
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$parsestring();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c452(s2);
        }
        s1 = s2;
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c453(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parsevalueExprConstantNull();
    }

    return s0;
  }

  function peg$parsevalueExprConstantNull() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c318) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c319); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c454(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsevalueExprColumn() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsecolumnName();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 40) {
        s3 = peg$c81;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c455(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevalueExprCaseWhen() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c456) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c457); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c458) {
          s5 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c459); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseexpr_precedence5();
            if (s7 !== peg$FAILED) {
              s8 = peg$parse__();
              if (s8 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c460) {
                  s9 = input.substr(peg$currPos, 4);
                  peg$currPos += 4;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c461); }
                }
                if (s9 !== peg$FAILED) {
                  s10 = peg$parse__();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parseexpr_precedence5();
                    if (s11 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c462(s7, s11);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c458) {
              s5 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c459); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseexpr_precedence5();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c460) {
                      s9 = input.substr(peg$currPos, 4);
                      peg$currPos += 4;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c461); }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseexpr_precedence5();
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c462(s7, s11);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c463) {
            s5 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c464); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseexpr_precedence5();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c465(s2, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c466) {
              s5 = input.substr(peg$currPos, 3);
              peg$currPos += 3;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c467); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c468(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpr_precedence9() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence8();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_boolean_disj();
      if (s3 === peg$FAILED) {
        s3 = peg$parseexpr_rest_string_concat();
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_boolean_disj();
          if (s3 === peg$FAILED) {
            s3 = peg$parseexpr_rest_string_concat();
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c469(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence8();
    }

    return s0;
  }

  function peg$parseexpr_precedence8() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence7();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_boolean_xdisj();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_boolean_xdisj();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c469(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence7();
    }

    return s0;
  }

  function peg$parseexpr_precedence7() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence6();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_boolean_conj();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_boolean_conj();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c469(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence6();
    }

    return s0;
  }

  function peg$parseexpr_precedence6() {
    var s0;

    s0 = peg$parsevalueExprCaseWhen();
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence5();
    }

    return s0;
  }

  function peg$parseexpr_precedence5() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence4();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_boolean_comparison();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_boolean_comparison();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c469(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence4();
    }

    return s0;
  }

  function peg$parseexpr_precedence4() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence3();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_number_add();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_number_add();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c469(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence3();
    }

    return s0;
  }

  function peg$parseexpr_precedence3() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpr_precedence2();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpr_rest_number_mul();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseexpr_rest_number_mul();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c469(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence2();
    }

    return s0;
  }

  function peg$parseexpr_precedence2() {
    var s0;

    s0 = peg$parseexpr_number_minus();
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence1();
    }

    return s0;
  }

  function peg$parseexpr_precedence1() {
    var s0;

    s0 = peg$parseexpr_boolean_negation();
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpr_precedence0();
    }

    return s0;
  }

  function peg$parseexpr_precedence0() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$parsevalueExprConstants();
    if (s0 === peg$FAILED) {
      s0 = peg$parsevalueExprCaseWhen();
      if (s0 === peg$FAILED) {
        s0 = peg$parsevalueExprFunctionsNullary();
        if (s0 === peg$FAILED) {
          s0 = peg$parsevalueExprFunctionsUnary();
          if (s0 === peg$FAILED) {
            s0 = peg$parsevalueExprFunctionsBinary();
            if (s0 === peg$FAILED) {
              s0 = peg$parsevalueExprFunctionsNary();
              if (s0 === peg$FAILED) {
                s0 = peg$parsevalueExprColumn();
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 40) {
                    s1 = peg$c81;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c82); }
                  }
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parseexpr_precedence9();
                      if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s5 = peg$c85;
                            peg$currPos++;
                          } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c86); }
                          }
                          if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c135(s3);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseRESERVED_KEYWORD_RELALG() {
    var s0;

    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c470) {
      s0 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c471); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c472) {
        s0 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c473); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c474) {
          s0 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c475); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c476) {
            s0 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c477); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c478) {
              s0 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c479); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c234) {
                s0 = input.substr(peg$currPos, 3);
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c235); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2).toLowerCase() === peg$c241) {
                  s0 = input.substr(peg$currPos, 2);
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c242); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3).toLowerCase() === peg$c213) {
                    s0 = input.substr(peg$currPos, 3);
                    peg$currPos += 3;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c214); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c136) {
                      s0 = input.substr(peg$currPos, 5);
                      peg$currPos += 5;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c137); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c143) {
                        s0 = input.substr(peg$currPos, 9);
                        peg$currPos += 9;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c144); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c140) {
                          s0 = input.substr(peg$currPos, 6);
                          peg$currPos += 6;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c141); }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {
                            s0 = input.substr(peg$currPos, 4);
                            peg$currPos += 4;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c151); }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c148) {
                              s0 = input.substr(peg$currPos, 5);
                              peg$currPos += 5;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c149); }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {
                                s0 = input.substr(peg$currPos, 4);
                                peg$currPos += 4;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c151); }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c159) {
                                  s0 = input.substr(peg$currPos, 4);
                                  peg$currPos += 4;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c160); }
                                }
                                if (s0 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 5).toLowerCase() === peg$c164) {
                                    s0 = input.substr(peg$currPos, 5);
                                    peg$currPos += 5;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c165); }
                                  }
                                  if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {
                                      s0 = input.substr(peg$currPos, 5);
                                      peg$currPos += 5;
                                    } else {
                                      s0 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c162); }
                                    }
                                    if (s0 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c167) {
                                        s0 = input.substr(peg$currPos, 4);
                                        peg$currPos += 4;
                                      } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c168); }
                                      }
                                      if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c480) {
                                          s0 = input.substr(peg$currPos, 6);
                                          peg$currPos += 6;
                                        } else {
                                          s0 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$c481); }
                                        }
                                        if (s0 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c482) {
                                            s0 = input.substr(peg$currPos, 4);
                                            peg$currPos += 4;
                                          } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$c483); }
                                          }
                                          if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c484) {
                                              s0 = input.substr(peg$currPos, 4);
                                              peg$currPos += 4;
                                            } else {
                                              s0 = peg$FAILED;
                                              if (peg$silentFails === 0) { peg$fail(peg$c485); }
                                            }
                                            if (s0 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c105) {
                                                s0 = input.substr(peg$currPos, 4);
                                                peg$currPos += 4;
                                              } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) { peg$fail(peg$c106); }
                                              }
                                              if (s0 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c102) {
                                                  s0 = input.substr(peg$currPos, 3);
                                                  peg$currPos += 3;
                                                } else {
                                                  s0 = peg$FAILED;
                                                  if (peg$silentFails === 0) { peg$fail(peg$c103); }
                                                }
                                                if (s0 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c456) {
                                                    s0 = input.substr(peg$currPos, 4);
                                                    peg$currPos += 4;
                                                  } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) { peg$fail(peg$c457); }
                                                  }
                                                  if (s0 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c458) {
                                                      s0 = input.substr(peg$currPos, 4);
                                                      peg$currPos += 4;
                                                    } else {
                                                      s0 = peg$FAILED;
                                                      if (peg$silentFails === 0) { peg$fail(peg$c459); }
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c460) {
                                                        s0 = input.substr(peg$currPos, 4);
                                                        peg$currPos += 4;
                                                      } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) { peg$fail(peg$c461); }
                                                      }
                                                      if (s0 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c463) {
                                                          s0 = input.substr(peg$currPos, 4);
                                                          peg$currPos += 4;
                                                        } else {
                                                          s0 = peg$FAILED;
                                                          if (peg$silentFails === 0) { peg$fail(peg$c464); }
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c466) {
                                                            s0 = input.substr(peg$currPos, 3);
                                                            peg$currPos += 3;
                                                          } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) { peg$fail(peg$c467); }
                                                          }
                                                          if (s0 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c43) {
                                                              s0 = input.substr(peg$currPos, 4);
                                                              peg$currPos += 4;
                                                            } else {
                                                              s0 = peg$FAILED;
                                                              if (peg$silentFails === 0) { peg$fail(peg$c44); }
                                                            }
                                                            if (s0 === peg$FAILED) {
                                                              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c46) {
                                                                s0 = input.substr(peg$currPos, 5);
                                                                peg$currPos += 5;
                                                              } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) { peg$fail(peg$c47); }
                                                              }
                                                              if (s0 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c318) {
                                                                  s0 = input.substr(peg$currPos, 4);
                                                                  peg$currPos += 4;
                                                                } else {
                                                                  s0 = peg$FAILED;
                                                                  if (peg$silentFails === 0) { peg$fail(peg$c319); }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }


  	function t(key, obj){
  		obj = obj || {};

  		if(options.i18n){
  			return options.i18n.t(key, obj);
  		}

  		// fallback
  		return key+' '+JSON.stringify(obj);
  	}

  	function getCodeInfo(){
  		return {
  			location: location(),
  			text: text()
  		};
  	}

  	function checkAssignments(assignments){
  		// check if the defined variable names are unique
  		var tmp = {}, name;

  		for(var i = 0; i < assignments.length; i++){
  			name = assignments[i].name;
  			if(tmp[name])
  				error(t('db.messages.parser.error-duplicate-variable', {name: name}));

  			tmp[name] = true;
  		}
  	};

  	// builds a binary valueExpression (fills the args array)
  	function buildBinaryValueExpr(first, rest){
  		// all members of rest have a member args in the form [undefined, child2]

  		var root = rest[0];
  		root.args[0] = first;
  		root.codeInfo = getCodeInfo();

  		var n;
  		for(var i = 1; i < rest.length; i++){
  			n = rest[i];

  			n.args[0] = root;
  			n.codeInfo = getCodeInfo();

  			root = n;
  		}

  		return root;
  	}

  	function buildBinary(first, rest){
  		// all members of rest have a child2

  		var root = rest[0];
  		root.child = first;
  		root.codeInfo = getCodeInfo();

  		var n;
  		for(var i = 1; i < rest.length; i++){
  			n = rest[i];

  			n.child = root;
  			n.codeInfo = getCodeInfo();

  			root = n;
  		}

  		return root;
  	}


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};

},{}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRelalgGroup = exports.parseRelalg = void 0;
const pegParserRelalg = require('./grammar_ra');
function parseRelalg(text, relationNames = []) {
    const ast = pegParserRelalg.parse(text, {
        startRule: 'start',
        relationNames: relationNames,
    });
    return ast;
}
exports.parseRelalg = parseRelalg;
function parseRelalgGroup(text) {
    return pegParserRelalg.parse(text, {
        startRule: 'groupStart',
    });
}
exports.parseRelalgGroup = parseRelalgGroup;

},{"./grammar_ra":43}],46:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeRelalg = exports.parseSQLDump = exports.parseSQLSelect = exports.queryWithReplacedOperatorsFromAst = exports.textFromRelalgAstRoot = exports.textFromRelalgAstNode = exports.textFromGroupAstRoot = exports.replaceVariables = exports.relalgFromSQLAstRoot = exports.relalgFromRelalgAstRoot = exports.relalgFromRelalgAstNode = exports.parseRelalgGroup = exports.parseRelalg = void 0;
const parser_ra_1 = require("./parser/parser_ra");
const relalgFromAst_1 = require("./translate/relalgFromAst");
const replaceVariables_1 = require("./translate/replaceVariables");
var parser_ra_2 = require("./parser/parser_ra");
Object.defineProperty(exports, "parseRelalg", { enumerable: true, get: function () { return parser_ra_2.parseRelalg; } });
Object.defineProperty(exports, "parseRelalgGroup", { enumerable: true, get: function () { return parser_ra_2.parseRelalgGroup; } });
var relalgFromAst_2 = require("./translate/relalgFromAst");
Object.defineProperty(exports, "relalgFromRelalgAstNode", { enumerable: true, get: function () { return relalgFromAst_2.relalgFromRelalgAstNode; } });
Object.defineProperty(exports, "relalgFromRelalgAstRoot", { enumerable: true, get: function () { return relalgFromAst_2.relalgFromRelalgAstRoot; } });
Object.defineProperty(exports, "relalgFromSQLAstRoot", { enumerable: true, get: function () { return relalgFromAst_2.relalgFromSQLAstRoot; } });
var replaceVariables_2 = require("./translate/replaceVariables");
Object.defineProperty(exports, "replaceVariables", { enumerable: true, get: function () { return replaceVariables_2.replaceVariables; } });
var textFromAst_1 = require("./translate/textFromAst");
Object.defineProperty(exports, "textFromGroupAstRoot", { enumerable: true, get: function () { return textFromAst_1.textFromGroupAstRoot; } });
Object.defineProperty(exports, "textFromRelalgAstNode", { enumerable: true, get: function () { return textFromAst_1.textFromRelalgAstNode; } });
Object.defineProperty(exports, "textFromRelalgAstRoot", { enumerable: true, get: function () { return textFromAst_1.textFromRelalgAstRoot; } });
function queryWithReplacedOperatorsFromAst(query, operatorPositions, cursor, mode) {
    if (mode === 'none') {
        return {
            query,
            cursor,
        };
    }
    const newOperators = {
        'math2plain': {
            'pi': 'pi',
            'sigma': 'sigma',
            'rho': 'rho',
            'arrowLeft': '<-',
            'arrowRight': '->',
            'psi': 'psi',
            'tau': 'tau',
            'gamma': 'gamma',
            'unionOperator': 'union',
            'intersectOperator': 'intersect',
            'divisionOperator': '/',
            'differenceOperator': '-',
            'crossJoinOperator': 'cross join',
            'innerJoinOperator': 'inner join',
            'naturalJoinOperator': 'natural join',
            'leftSemiJoinOperator': 'left semi join',
            'rightSemiJoinOperator': 'right semi join',
            'antiJoinOperator': 'anti join',
            'leftOuterJoinOperator': 'left outer join',
            'rightOuterJoinOperator': 'right outer join',
            'fullOuterJoinOperator': 'full outer join',
        },
        'plain2math': {
            'pi': '',
            'sigma': '',
            'rho': '',
            'arrowLeft': '',
            'arrowRight': '',
            'psi': '',
            'tau': '',
            'gamma': '',
            'unionOperator': '',
            'intersectOperator': '',
            'divisionOperator': '',
            'differenceOperator': '-',
            'crossJoinOperator': '',
            'innerJoinOperator': '',
            'naturalJoinOperator': '',
            'leftSemiJoinOperator': '',
            'rightSemiJoinOperator': '',
            'antiJoinOperator': '',
            'leftOuterJoinOperator': '',
            'rightOuterJoinOperator': '',
            'fullOuterJoinOperator': '',
        },
    };
    for (let i = operatorPositions.length - 1; i >= 0; i--) {
        const op = operatorPositions[i];
        const location = op.location; // = location without surrounding whitespace
        const left = query.substr(0, location.start.offset - 1); // fixed offset | #174
        const right = query.substring(location.end.offset);
        const newOperator = newOperators[mode][op.name]; // TODO: fix typings
        const oldOperator = query.substring(location.start.offset, location.end.offset);
        if (oldOperator === newOperator) {
            continue;
        }
        // handle cursor position (all new operators are single-lined!)
        if (cursor) {
            // cursor was in the same line(s) (old operator could be split across multiple lines)
            if (cursor.line >= location.start.line && cursor.line <= location.end.line) {
                // cursor is in operator => skip replacement!
                if (cursor.column > location.start.column && cursor.column < location.end.column) {
                    continue;
                }
                else if (cursor.column >= location.end.column) {
                    cursor.line -= location.end.line - location.start.line;
                    const oldLength = op.location.end.offset - op.location.start.offset;
                    const newLength = newOperator.length;
                    cursor.column -= oldLength - newLength;
                }
            }
            // cursor was above of old operator
            else if (cursor.line < location.start.line) {
                // noop;
            }
            // cursor was below the old operator 
            else if (cursor.line > location.end.line) {
                // just update the line; column is unchanged
                cursor.line -= location.end.line - location.start.line;
            }
        }
        // update query
        query = left + newOperator + right;
    }
    return {
        query,
        cursor,
    };
}
exports.queryWithReplacedOperatorsFromAst = queryWithReplacedOperatorsFromAst;
const pegParserSql = require('./parser/grammar_sql');
function parseSQLSelect(text) {
    return pegParserSql.parse(text, {
        startRule: 'start',
        tracer: undefined,
    });
}
exports.parseSQLSelect = parseSQLSelect;
function parseSQLDump(text) {
    return pegParserSql.parse(text, {
        startRule: 'dbDumpStart',
        tracer: undefined,
    });
}
exports.parseSQLDump = parseSQLDump;
function executeRelalg(text, relations = {}) {
    relations = relations || {};
    const ast = (0, parser_ra_1.parseRelalg)(text, Object.keys(relations));
    (0, replaceVariables_1.replaceVariables)(ast, relations);
    const root = (0, relalgFromAst_1.relalgFromRelalgAstRoot)(ast, relations);
    root.check();
    return root;
}
exports.executeRelalg = executeRelalg;

},{"./parser/grammar_sql":44,"./parser/parser_ra":45,"./translate/relalgFromAst":48,"./translate/replaceVariables":49,"./translate/textFromAst":50}],47:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./relalg"), exports);

},{"./relalg":46}],48:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.relalgFromRelalgAstNode = exports.relalgFromRelalgAstRoot = exports.relalgFromSQLAstRoot = void 0;
const i18n = require("i18next");
const Column_1 = require("../exec/Column");
const Difference_1 = require("../exec/Difference");
const Division_1 = require("../exec/Division");
const ExecutionError_1 = require("../exec/ExecutionError");
const GroupBy_1 = require("../exec/GroupBy");
const Intersect_1 = require("../exec/Intersect");
const AntiJoin_1 = require("../exec/joins/AntiJoin");
const CrossJoin_1 = require("../exec/joins/CrossJoin");
const FullOuterJoin_1 = require("../exec/joins/FullOuterJoin");
const InnerJoin_1 = require("../exec/joins/InnerJoin");
const LeftOuterJoin_1 = require("../exec/joins/LeftOuterJoin");
const RightOuterJoin_1 = require("../exec/joins/RightOuterJoin");
const SemiJoin_1 = require("../exec/joins/SemiJoin");
const OrderBy_1 = require("../exec/OrderBy");
const Projection_1 = require("../exec/Projection");
const Relation_1 = require("../exec/Relation");
const RenameColumns_1 = require("../exec/RenameColumns");
const RenameRelation_1 = require("../exec/RenameRelation");
const Schema_1 = require("../exec/Schema");
const Selection_1 = require("../exec/Selection");
const Union_1 = require("../exec/Union");
const ValueExpr = require("../exec/ValueExpr");
function parseJoinCondition(condition) {
    if (condition === null) {
        return {
            type: 'natural',
            restrictToColumns: null,
        };
    }
    else if (Array.isArray(condition)) {
        return {
            type: 'natural',
            restrictToColumns: condition,
        };
    }
    else {
        return {
            type: 'theta',
            joinExpression: recValueExpr(condition),
        };
    }
}
// translate a SQL-AST to RA
function relalgFromSQLAstRoot(astRoot, relations) {
    'use strict';
    function setCodeInfoFromNode(raNode, astNode) {
        if (!astNode.codeInfo) {
            throw new Error('should not happen');
        }
        raNode.setCodeInfoObject(astNode.codeInfo);
    }
    function rec(nRaw) {
        let node = null;
        switch (nRaw.type) {
            case 'relation':
                {
                    const n = nRaw;
                    const start = Date.now();
                    if (typeof (relations[n.name]) === 'undefined') {
                        throw new ExecutionError_1.ExecutionError(i18n.t('db.messages.translate.error-relation-not-found', { name: n.name }), n.codeInfo);
                    }
                    const rel = relations[n.name].copy();
                    if (n.relAlias === null) {
                        node = rel;
                        node._execTime = Date.now() - start;
                        break;
                    }
                    node = new RenameRelation_1.RenameRelation(rel, n.relAlias);
                    node._execTime = Date.now() - start;
                }
                break;
            case 'statement':
                {
                    const start = Date.now();
                    const n = nRaw;
                    node = parseStatement(n);
                    node._execTime = Date.now() - start;
                    if (n.select.distinct === false) {
                        node.addWarning(i18n.t('db.messages.translate.warning-distinct-missing'), n.codeInfo);
                    }
                }
                break;
            case 'renameRelation':
                {
                    const start = Date.now();
                    const n = nRaw;
                    node = new RenameRelation_1.RenameRelation(rec(n.child), n.newRelAlias);
                    node._execTime = Date.now() - start;
                }
                break;
            case 'relationFromSubstatement':
                {
                    const start = Date.now();
                    const n = nRaw;
                    const rel = rec(n.statement);
                    node = new RenameRelation_1.RenameRelation(rel, n.relAlias);
                    node._execTime = Date.now() - start;
                }
                break;
            case 'innerJoin':
            case 'leftOuterJoin':
            case 'rightOuterJoin':
            case 'fullOuterJoin':
                {
                    const start = Date.now();
                    const n = nRaw;
                    const condition = parseJoinCondition(n.cond);
                    switch (n.type) {
                        case 'innerJoin':
                            node = new InnerJoin_1.InnerJoin(rec(n.child), rec(n.child2), condition);
                            node._execTime = Date.now() - start;
                            break;
                        case 'leftOuterJoin':
                            node = new LeftOuterJoin_1.LeftOuterJoin(rec(n.child), rec(n.child2), condition);
                            node._execTime = Date.now() - start;
                            break;
                        case 'rightOuterJoin':
                            node = new RightOuterJoin_1.RightOuterJoin(rec(n.child), rec(n.child2), condition);
                            node._execTime = Date.now() - start;
                            break;
                        case 'fullOuterJoin':
                            node = new FullOuterJoin_1.FullOuterJoin(rec(n.child), rec(n.child2), condition);
                            node._execTime = Date.now() - start;
                            break;
                    }
                }
                break;
            case 'crossJoin':
                {
                    const start = Date.now();
                    const n = nRaw;
                    // check out size of resulting cross join!
                    const rec1 = rec(n.child);
                    const rec2 = rec(n.child2);
                    const probableJoinCount = getRowLength(rec1) * getRowLength(rec2);
                    // tried and tested with multiple devices / browsers
                    // this seems to be where the browser starts to freeze up
                    if (probableJoinCount > 1000000) {
                        alert('The CrossJoin may cause the browser to crash. Alternatively try using an INNER JOIN');
                    }
                    node = new CrossJoin_1.CrossJoin(rec(n.child), rec(n.child2));
                    node._execTime = Date.now() - start;
                }
                break;
            case 'naturalJoin':
                {
                    const start = Date.now();
                    const n = nRaw;
                    node = new InnerJoin_1.InnerJoin(rec(n.child), rec(n.child2), {
                        type: 'natural',
                        restrictToColumns: null,
                    });
                    node._execTime = Date.now() - start;
                }
                break;
            case 'union':
            case 'intersect':
            case 'except':
                {
                    const start = Date.now();
                    const n = nRaw;
                    switch (n.type) {
                        case 'union':
                            node = new Union_1.Union(rec(n.child), rec(n.child2));
                            node._execTime = Date.now() - start;
                            break;
                        case 'intersect':
                            node = new Intersect_1.Intersect(rec(n.child), rec(n.child2));
                            node._execTime = Date.now() - start;
                            break;
                        case 'except':
                            node = new Difference_1.Difference(rec(n.child), rec(n.child2));
                            node._execTime = Date.now() - start;
                            break;
                    }
                    if (n.all === true) {
                        if (!node) {
                            throw new Error(`should not happen`);
                        }
                        node.addWarning(i18n.t('db.messages.translate.warning-ignored-all-on-set-operators'), n.codeInfo);
                    }
                }
                break;
            case 'orderBy':
                {
                    const start = Date.now();
                    const n = nRaw;
                    const orderCols = [];
                    const orderAsc = [];
                    for (let i = 0; i < n.arg.value.length; i++) {
                        const e = n.arg.value[i];
                        orderAsc.push(e.asc);
                        orderCols.push(new Column_1.Column(e.col.name, e.col.relAlias));
                    }
                    node = new OrderBy_1.OrderBy(rec(n.child), orderCols, orderAsc);
                    node._execTime = Date.now() - start;
                }
                break;
            case 'limit':
                {
                    const start = Date.now();
                    const n = nRaw;
                    const limit = n.limit;
                    const offset = n.offset;
                    const conditionOffset = new ValueExpr.ValueExprGeneric('boolean', '>', [
                        new ValueExpr.ValueExprGeneric('number', 'rownum', []),
                        new ValueExpr.ValueExprGeneric('number', 'constant', [offset]),
                    ]);
                    if (limit === -1) {
                        // === LIMIT ALL => only offset
                        node = new Selection_1.Selection(rec(n.child), conditionOffset);
                        node._execTime = Date.now() - start;
                    }
                    else {
                        // limit and offset
                        const conditionLimit = new ValueExpr.ValueExprGeneric('boolean', '<=', [
                            new ValueExpr.ValueExprGeneric('number', 'rownum', []),
                            new ValueExpr.ValueExprGeneric('number', 'constant', [limit + offset]),
                        ]);
                        node = new Selection_1.Selection(rec(n.child), new ValueExpr.ValueExprGeneric('boolean', 'and', [conditionOffset, conditionLimit]));
                        node._execTime = Date.now() - start;
                    }
                    break;
                }
            default:
                throw new Error(`type ${nRaw.type} not implemented`);
        }
        if (!node) {
            throw new Error(`should not happen`);
        }
        if (nRaw.wrappedInParentheses === true) {
            node.setWrappedInParentheses(true);
        }
        setCodeInfoFromNode(node, nRaw);
        return node;
    }
    function getSelection(root, condition, codeInfo) {
        root.check();
        const node = new Selection_1.Selection(root, recValueExpr(condition));
        node.setCodeInfoObject(codeInfo);
        return node;
    }
    function isNamedColumn(arg) {
        return arg.type === 'column' && arg.alias;
    }
    function parseStatement(statement) {
        const projectionArgs = statement.select.arg;
        // from-CLAUSE
        let root = rec(statement.from);
        setCodeInfoFromNode(root, statement.from);
        root.check();
        // selection
        if (statement.where !== null) {
            root = getSelection(root, statement.where.arg, statement.where.codeInfo);
            setCodeInfoFromNode(root, statement.where);
        }
        // group-by + aggregation
        if (statement.groupBy !== null || statement.numAggregationColumns > 0) {
            const aggregateFunctions = [];
            const groupByCols = statement.groupBy || [];
            // filter aggFunctions from SELECT list
            for (let i = 0; i < projectionArgs.length; i++) {
                const col = projectionArgs[i];
                if (col.type === 'aggFunction') {
                    aggregateFunctions.push(col);
                }
            }
            if (aggregateFunctions.length > 0) {
                root = new GroupBy_1.GroupBy(root, groupByCols, aggregateFunctions);
            }
            else {
                // use projection if no aggregation is used
                const projections = [];
                for (let i = 0; i < groupByCols.length; i++) {
                    const col = groupByCols[i];
                    projections.push(new Column_1.Column(col.name, col.relAlias));
                }
                root = new Projection_1.Projection(root, projections);
            }
        }
        // having
        if (statement.having !== null) {
            root = getSelection(root, statement.having.arg, statement.having.codeInfo);
            setCodeInfoFromNode(root, statement.having);
        }
        // projection
        let colsRenamed = false;
        if (projectionArgs.length === 1 && projectionArgs[0].type === 'column' && projectionArgs[0].name === '*' && projectionArgs[0].relAlias === null) {
            // select * => no projection needed
        }
        else {
            const projections = [];
            for (let i = 0; i < projectionArgs.length; i++) {
                const col = projectionArgs[i];
                if (col.type === 'aggFunction') {
                    projections.push(new Column_1.Column(col.name, null)); // has been renamed by gamma
                }
                else if (col.type === 'namedColumnExpr') {
                    projections.push({
                        name: col.name,
                        relAlias: col.relAlias,
                        child: recValueExpr(col.child),
                    });
                }
                else if (col.type === 'column') {
                    // normal columns
                    projections.push(new Column_1.Column(col.name, col.relAlias));
                    if (isNamedColumn(col)) {
                        colsRenamed = true;
                    }
                }
                else {
                    throw new Error('this should not happen');
                }
            }
            root = new Projection_1.Projection(root, projections);
            setCodeInfoFromNode(root, statement.select);
        }
        // rename columns
        if (colsRenamed === true) {
            const tmp = new RenameColumns_1.RenameColumns(root);
            for (let i = 0; i < projectionArgs.length; i++) {
                const arg = projectionArgs[i];
                if (isNamedColumn(arg)) {
                    tmp.addRenaming(arg.alias, arg.name, arg.relAlias);
                }
            }
            root = tmp;
        }
        return root;
    }
    return rec(astRoot.child);
}
exports.relalgFromSQLAstRoot = relalgFromSQLAstRoot;
function recValueExpr(n) {
    let node;
    if (n.datatype === 'null' && n.func === 'columnValue') {
        node = new ValueExpr.ValueExprColumnValue(n.args[0], n.args[1]);
    }
    else {
        switch (n.datatype) {
            case 'string':
            case 'number':
            case 'boolean':
            case 'date':
            case 'null': // all with unknown type
                const tmp = [];
                for (let i = 0; i < n.args.length; i++) {
                    if (n.func === 'constant') {
                        tmp.push(n.args[i]);
                    }
                    else {
                        tmp.push(recValueExpr(n.args[i]));
                    }
                }
                node = new ValueExpr.ValueExprGeneric(n.datatype, n.func, tmp);
                break;
            default:
                throw new Error('not implemented yet');
        }
    }
    node.setCodeInfoObject(n.codeInfo);
    if (n.wrappedInParentheses === true) {
        node.setWrappedInParentheses(true);
    }
    return node;
}
function getRowLength(node, length = 0) {
    if (!node) {
        return 0;
    }
    if (node._table) {
        return node._table._rows.length;
    }
    if (node._child) {
        return getRowLength(node._child) * getRowLength(node._child2);
    }
    return 0;
}
function setAdditionalData(astNode, node) {
    node.setCodeInfoObject(astNode.codeInfo);
    if (typeof (astNode.metaData) !== 'undefined') {
        for (const key in astNode.metaData) {
            if (!astNode.metaData.hasOwnProperty(key)) {
                continue;
            }
            node.setMetaData(key, astNode.metaData[key]);
        }
    }
    if (astNode.wrappedInParentheses === true) {
        node.setWrappedInParentheses(true);
    }
}
// translates a RA-AST to RA
function relalgFromRelalgAstRoot(astRoot, relations) {
    // root is the real root node! of a statement
    return relalgFromRelalgAstNode(astRoot.child, relations);
}
exports.relalgFromRelalgAstRoot = relalgFromRelalgAstRoot;
/**
 * translates a RA-AST node to RA
 * @param   {Object} astNode   a node of a RA-AST
 * @param   {Object} relations hash of the relations that could be used in the statement
 * @returns {Object} an actual RA-expression
 */
function relalgFromRelalgAstNode(astNode, relations) {
    function recRANode(n) {
        switch (n.type) {
            case 'relation':
                {
                    if (typeof (relations[n.name]) === 'undefined') {
                        throw new ExecutionError_1.ExecutionError(i18n.t('db.messages.translate.error-relation-not-found', { name: n.name }), n.codeInfo);
                    }
                    const node = relations[n.name].copy();
                    setAdditionalData(n, node);
                    return node;
                }
            case 'table':
                {
                    const schema = new Schema_1.Schema();
                    for (let i = 0; i < n.columns.length; i++) {
                        const col = n.columns[i];
                        schema.addColumn(col.name, col.relAlias, col.type);
                    }
                    const start = Date.now();
                    const rel = new Relation_1.Relation(n.name);
                    rel.setSchema(schema, true);
                    rel.addRows(n.rows);
                    rel.setMetaData('isInlineRelation', true);
                    rel.setMetaData('inlineRelationDefinition', n.codeInfo.text);
                    // TODO: inlineRelationDefinition should be replaced; there should be a generic way to get the definition of a node
                    const node = rel;
                    node._execTime = Date.now() - start;
                    setAdditionalData(n, node);
                    return node;
                }
            case 'selection':
                {
                    // TODO: Missing here...
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const condition = recValueExpr(n.arg);
                    const node = new Selection_1.Selection(child, condition);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'projection':
                {
                    const child = recRANode(n.child);
                    const start = Date.now();
                    const projections = [];
                    for (let i = 0; i < n.arg.length; i++) {
                        const el = n.arg[i];
                        if (el.type === 'columnName') {
                            const e = el;
                            projections.push(new Column_1.Column(e.name, e.relAlias));
                        }
                        else if (el.type === 'namedColumnExpr') {
                            const e = el;
                            // namedColumnExpr
                            projections.push({
                                name: e.name,
                                relAlias: e.relAlias,
                                child: recValueExpr(e.child),
                            });
                        }
                        else {
                            throw new Error('should not happen');
                        }
                    }
                    const node = new Projection_1.Projection(child, projections);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'orderBy':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const orderCols = [];
                    const orderAsc = [];
                    for (let i = 0; i < n.arg.length; i++) {
                        const e = n.arg[i];
                        orderAsc.push(e.asc);
                        orderCols.push(new Column_1.Column(e.col.name, e.col.relAlias));
                    }
                    const node = new OrderBy_1.OrderBy(child, orderCols, orderAsc);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'groupBy':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const aggregateFunctions = n.aggregate;
                    const groupByCols = n.group;
                    const node = new GroupBy_1.GroupBy(child, groupByCols, aggregateFunctions);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'union':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const node = new Union_1.Union(child, child2);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'intersect':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const node = new Intersect_1.Intersect(child, child2);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'division':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const node = new Division_1.Division(child, child2);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'difference':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const node = new Difference_1.Difference(child, child2);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'renameColumns':
                {
                    const start = Date.now();
                    const ren = new RenameColumns_1.RenameColumns(recRANode(n.child));
                    for (let i = 0; i < n.arg.length; i++) {
                        const e = n.arg[i];
                        ren.addRenaming(e.dst, e.src.name, e.src.relAlias);
                    }
                    const node = ren;
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'renameRelation':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const node = new RenameRelation_1.RenameRelation(child, n.newRelAlias);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'thetaJoin':
                {
                    const start = Date.now();
                    const condition = {
                        type: 'theta',
                        joinExpression: recValueExpr(n.arg),
                    };
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const node = new InnerJoin_1.InnerJoin(child, child2, condition);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'crossJoin':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const node = new CrossJoin_1.CrossJoin(child, child2);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'naturalJoin':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const node = new InnerJoin_1.InnerJoin(child, child2, {
                        type: 'natural',
                        restrictToColumns: null,
                    });
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'leftSemiJoin':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const node = new SemiJoin_1.SemiJoin(child, child2, true);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'rightSemiJoin':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const node = new SemiJoin_1.SemiJoin(child, child2, false);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'antiJoin':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const condition = parseJoinCondition(n.arg);
                    const node = new AntiJoin_1.AntiJoin(child, child2, condition);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'leftOuterJoin':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const condition = parseJoinCondition(n.arg);
                    const node = new LeftOuterJoin_1.LeftOuterJoin(child, child2, condition);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'rightOuterJoin':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const condition = parseJoinCondition(n.arg);
                    const node = new RightOuterJoin_1.RightOuterJoin(child, child2, condition);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
            case 'fullOuterJoin':
                {
                    const start = Date.now();
                    const child = recRANode(n.child);
                    const child2 = recRANode(n.child2);
                    const condition = parseJoinCondition(n.arg);
                    const node = new FullOuterJoin_1.FullOuterJoin(child, child2, condition);
                    setAdditionalData(n, node);
                    node._execTime = Date.now() - start;
                    return node;
                }
        }
    }
    return recRANode(astNode);
}
exports.relalgFromRelalgAstNode = relalgFromRelalgAstNode;

},{"../exec/Column":18,"../exec/Difference":19,"../exec/Division":20,"../exec/ExecutionError":21,"../exec/GroupBy":22,"../exec/Intersect":23,"../exec/OrderBy":24,"../exec/Projection":25,"../exec/Relation":27,"../exec/RenameColumns":28,"../exec/RenameRelation":29,"../exec/Schema":30,"../exec/Selection":31,"../exec/Union":33,"../exec/ValueExpr":34,"../exec/joins/AntiJoin":35,"../exec/joins/CrossJoin":36,"../exec/joins/FullOuterJoin":37,"../exec/joins/InnerJoin":38,"../exec/joins/LeftOuterJoin":40,"../exec/joins/RightOuterJoin":41,"../exec/joins/SemiJoin":42,"i18next":16}],49:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceVariables = void 0;
const i18n = require("i18next");
const Immutable = require("immutable");
const ExecutionError_1 = require("../exec/ExecutionError");
const utils_1 = require("./utils");
// find all relations used in this branch (recursively)
function getRelationsIn(root, ignore) {
    const relations = [];
    (0, utils_1.forEachPreOrder)(root, node => {
        if (node.type === 'relation' && (ignore === undefined || ignore.has(node.name) === false)) {
            // replace
            relations.push({
                name: node.name,
                line: node.codeInfo.location.start.line,
                column: node.codeInfo.location.start.column,
            });
        }
    });
    return relations;
}
/**
 * replaces all variables with their definition in the assignments of a RA statement
 * @param root
 * @param predefinedRelations
 */
function replaceVariables(root, _predefinedRelations) {
    // root is the real root node! of a statement
    const predefinedRelations = (Immutable.Map.isMap(_predefinedRelations)
        ? _predefinedRelations
        : Immutable.Map().withMutations(map => {
            for (const name of Object.keys(_predefinedRelations)) {
                map.set(name, _predefinedRelations[name]);
            }
        }).asImmutable());
    if (root.assignments.length === 0) {
        return;
    }
    const variables = new Map();
    const variableNames = Immutable.Set().withMutations(set => {
        // names of declared variables
        for (let i = 0; i < root.assignments.length; i++) {
            set.add(root.assignments[i].name);
        }
    });
    for (let i = 0; i < root.assignments.length; i++) {
        const assignment = root.assignments[i];
        const { name, child } = assignment;
        const childRelations = getRelationsIn(assignment.child);
        if (predefinedRelations.has(name) || variables.has(name)) {
            const e = new ExecutionError_1.ExecutionError(i18n.t('db.messages.translate.error-variable-name-conflict', { name }), assignment.codeInfo);
            throw e;
        }
        // save the origin of the node
        child.metaData = Object.assign(Object.assign({}, child.metaData), { fromVariable: name });
        variables.set(name, {
            name: name,
            child: child,
            assignmentIndex: i,
            childRelations, // variables/relations used in definition
        });
    }
    // check for cycles with Depth-first search
    const visited = new Map();
    const finished = new Map();
    // initialize
    for (const [varName] of variables) {
        visited.set(varName, false);
        finished.set(varName, false);
    }
    const dfs = (varName) => {
        if (finished.get(varName) === true) {
            return;
        }
        if (visited.get(varName) === true) {
            throw new Error(i18n.t('db.messages.translate.error-variable-cyclic-usage', { name: varName }));
        }
        visited.set(varName, true);
        const variable = variables.get(varName);
        if (variable !== undefined) {
            const { childRelations } = variable;
            for (let i = 0; i < childRelations.length; i++) {
                dfs(childRelations[i].name);
            }
        }
        finished.set(varName, true);
    };
    // start dfs for all variables
    for (const [varName] of variables) {
        dfs(varName);
    }
    // => variables are cycle free
    // replace vars in the variables themselves (as they are tested to be cycle free)
    for (let [, i] of variables) {
        for (const [, j] of variables) {
            if (i.name === j.name) {
                // except it selves
                continue;
            }
            // replace all occurrence of var j in i by the definition of j
            const child = (0, utils_1.mapPostOrder)(i.child, n => {
                if (n.type === 'relation' && n.name === j.name) {
                    const newNode = Object.assign(Object.assign({}, j.child), { 
                        // save the origin of the node
                        metaData: Object.assign(Object.assign({}, j.child.metaData), { fromVariable: j.name }) });
                    return newNode;
                }
                else {
                    return n;
                }
            });
            // update definition of i
            i = Object.assign(Object.assign({}, i), { child });
        }
        variables.set(i.name, i);
    }
    for (const [, i] of variables) {
        // update variables in root node
        root.assignments[i.assignmentIndex].child = i.child;
    }
    // replace vars in the roots child == the statement (if there is one)
    if (root.type === 'relalgRoot' || root.type === 'sqlRoot') {
        if (root.child !== null && typeof (root.child) !== 'undefined') {
            for (const [varName, variable] of variables) {
                // replace the usage of each variable by its definition
                root.child = (0, utils_1.mapPostOrder)(root.child, n => {
                    if (n.type === 'relation' && n.name === varName) {
                        return Object.assign(Object.assign({}, variable.child), { 
                            // save the origin of the node
                            metaData: Object.assign(Object.assign({}, variable.child.metaData), { fromVariable: varName }) });
                    }
                    else {
                        return n;
                    }
                });
            }
        }
    }
}
exports.replaceVariables = replaceVariables;

},{"../exec/ExecutionError":21,"./utils":51,"i18next":16,"immutable":17}],50:[function(require,module,exports){
"use strict";
/*** Copyright 2016 Johannes Kessler 2016 Johannes Kessler
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.textFromRelalgAstNode = exports.textFromRelalgAstRoot = exports.textFromGroupAstRoot = void 0;
// builds the formated text version of a group
function textFromGroupAstRoot(astRoot) {
    if (astRoot.type !== 'groupRoot') {
        throw new Error('wrong ast!?');
    }
    let s = '';
    function group_to_text(group) {
        let s = '';
        // header
        const { headers } = group;
        for (const header of headers) {
            const { name, lang, text } = header;
            s += name;
            if (lang !== null) {
                s += '@' + lang;
            }
            s += ':';
            if (header.text.indexOf('\n') !== -1) {
                s += `[[${header.text}]]\n`;
            }
            else {
                s += header.text + '\n';
            }
        }
        s += '\n';
        // body
        for (let i = 0; i < group.assignments.length; i++) {
            s += group.assignments[i].name + ' = ';
            s += textFromRelalgAstNode(group.assignments[i].child);
            s += '\n\n';
        }
        return s;
    }
    for (let i = 0; i < astRoot.groups.length; i++) {
        s += group_to_text(astRoot.groups[i]);
        if (i !== astRoot.groups.length - 1) {
            s += '\n\n\n\n';
        }
    }
    return s;
}
exports.textFromGroupAstRoot = textFromGroupAstRoot;
// builds the formated text version of a relalg root
function textFromRelalgAstRoot(root) {
    'use strict';
    if (root.type !== 'relalgRoot') {
        throw new Error('wrong ast!?');
    }
    let s = '';
    // assignments
    for (let i = 0; i < root.assignments.length; i++) {
        s += root.assignments[i].name + ' = ';
        s += textFromRelalgAstNode(root.assignments[i].child);
        s += '\n\n';
    }
    s += textFromRelalgAstNode(root.child);
    return s;
}
exports.textFromRelalgAstRoot = textFromRelalgAstRoot;
function textFromRelalgAstNode(node) {
    'use strict';
    function unaryFormula(className, funcName, argument, body) {
        const s = $('<span>'); // TODO: remove jquery!
        if (className !== null) {
            s.addClass(className);
        }
        if (funcName !== null) {
            s.append(funcName);
        }
        if (argument !== null) {
            const sub = $('<sub>');
            sub.append(argument);
            s.append(' ').append(sub);
        }
        if (body !== null) {
            s.append(' ( ').append(body).append(' ) ');
        }
        return s.text();
    }
    function binaryFormula(className, funcName, argument, child, child2) {
        const s = $('<span>');
        if (className !== null) {
            s.addClass(className);
        }
        s.append('( ').append(child).append(' ) ');
        s.append(funcName);
        if (argument !== null) {
            const sub = $('<sub>');
            sub.append(argument);
            s.append(sub);
        }
        s.append(' ( ').append(child2).append(' ) ');
        return s.text();
    }
    function columnName(name, relAlias) {
        if (typeof name === 'number') {
            name = `[${name}]`;
        }
        if (relAlias === null) {
            return name;
        }
        return `${relAlias}.${name}`;
    }
    function comparison(className, comparator, child, child2, ltr) {
        const s = $('<span>');
        if (className !== null) {
            s.addClass(className);
        }
        if (ltr === true) {
            s.append(child);
        }
        else {
            s.append(child2);
        }
        let c = comparator;
        // nice comparator symbol
        switch (comparator) {
            case '!=':
                c = '';
                break;
            case '>=':
                c = '';
                break;
            case '<=':
                c = '';
                break;
        }
        s.append(c);
        if (ltr === true) {
            s.append(child2);
        }
        else {
            s.append(child);
        }
        return s.text();
    }
    function booleanOp(className, operator, child, child2) {
        const s = $('<span>');
        if (className !== null) {
            s.addClass(className);
        }
        s.append('(').append(child).append(') ');
        s.append(operator);
        s.append(' (').append(child2).append(')');
        return s.text();
    }
    function dateFormatISO(val) {
        const month = (val.getMonth() + 1 < 10
            ? '0' + (val.getMonth() + 1)
            : (val.getMonth() + 1));
        const day = (val.getDate() < 10
            ? '0' + val.getDate()
            : val.getDate());
        return `${val.getFullYear()}-${month}-${day}`;
    }
    function value(val, type) {
        if (val === null || type === 'null') {
            return 'null';
        }
        if (val instanceof Date) {
            return dateFormatISO(val);
        }
        else if (typeof val === 'string') {
            return `'${val}'`;
        }
        else if (typeof val === 'number') {
            return val.toString();
        }
        else {
            throw new Error('unknown type ' + type);
        }
    }
    function variable(name) {
        const s = $('<span>');
        s.append(name);
        return s.text();
    }
    function formatInlineTable(rows, delimiter, compact) {
        // calculate max length per column
        const colLengths = [];
        if (compact === false) {
            for (let i = 0; i < rows.length; i++) {
                for (let j = 0; j < rows[i].length; j++) {
                    const length = rows[i][j].length;
                    if (i === 0 || length > colLengths[j]) {
                        colLengths[j] = length;
                    }
                }
            }
        }
        // build output
        let s = '{\n';
        for (let i = 0; i < rows.length; i++) {
            for (let j = 0; j < rows[i].length; j++) {
                if (compact === false) {
                    // pad with spaces (right)
                    rows[i][j] = (rows[i][j] + (new Array(colLengths[j] + 1 - rows[i][j].length)).join(' '));
                }
            }
            if (compact === false) {
                s += '\t';
            }
            s += rows[i].join(delimiter) + '\n';
        }
        return s + '}';
    }
    function rec(n) {
        //            =         -         
        switch (n.type) {
            case 'relation':
                return unaryFormula(n.type, n.name, null, null);
            case 'table':
                {
                    const rows = [];
                    // header
                    let row = [];
                    for (let i = 0; i < n.columns.length; i++) {
                        const col = n.columns[i];
                        row.push(`${columnName(col.name, col.relAlias)}:${col.type}`);
                    }
                    rows.push(row);
                    // rows
                    for (let i = 0; i < n.rows.length; i++) {
                        row = [];
                        for (let j = 0; j < n.rows[i].length; j++) {
                            row.push(value(n.rows[i][j], n.columns[i].type));
                        }
                        rows.push(row);
                    }
                    return formatInlineTable(rows, ', ', false);
                }
            case 'selection':
                return unaryFormula(n.type, '', rec(n.arg), rec(n.child));
            case 'projection':
                {
                    const args = [];
                    for (let i = 0; i < n.arg.length; i++) {
                        args.push(columnName(n.arg[i].name, n.arg[i].relAlias));
                    }
                    return unaryFormula(n.type, '', args.join(', '), rec(n.child));
                }
            case 'union':
                return binaryFormula(n.type, '', null, rec(n.child), rec(n.child2));
            case 'intersect':
                return binaryFormula(n.type, '', null, rec(n.child), rec(n.child2));
            case 'division':
                return binaryFormula(n.type, '', null, rec(n.child), rec(n.child2));
            case 'difference':
                return binaryFormula(n.type, '-', null, rec(n.child), rec(n.child2));
            case 'renameColumns':
                {
                    const args = [];
                    for (let i = 0; i < n.arg.length; i++) {
                        const e = n.arg[i];
                        args.push(`${e.dst}${columnName(e.src.name, e.src.relAlias)}`);
                    }
                    return unaryFormula(n.type, '', args.join(', '), rec(n.child));
                }
            case 'renameRelation':
                return unaryFormula(n.type, '', n.newRelAlias, rec(n.child));
            case 'orderBy':
                {
                    const args = [];
                    for (let i = 0; i < n.arg.length; i++) {
                        const e = n.arg[i];
                        const s = `${columnName(e.col.name, e.col.relAlias)} ${e.asc ? 'asc' : 'desc'}`;
                        args.push(s);
                    }
                    return unaryFormula(n.type, '', args.join(', '), rec(n.child));
                }
            case 'groupBy':
                {
                    let argument = '';
                    let tmp = [];
                    // group
                    if (n.group.length > 0) {
                        for (let i = 0; i < n.group.length; i++) {
                            tmp.push(columnName(n.group[i].name, n.group[i].relAlias));
                        }
                        argument += tmp.join(', ') + ' ; ';
                    }
                    // aggregate
                    tmp = [];
                    for (let i = 0; i < n.aggregate.length; i++) {
                        const f = n.aggregate[i];
                        // tmp.push(f.name + '');
                        if (f.aggFunction === 'COUNT_ALL') {
                            tmp.push(f.name + '  COUNT(*)');
                        }
                        else {
                            tmp.push(`${f.name}  ${f.aggFunction}(${columnName(f.col.name, f.col.relAlias)})`);
                        }
                    }
                    argument += tmp.join(', ');
                    return unaryFormula(n.type, '', argument, rec(n.child));
                }
            case 'thetaJoin':
                return binaryFormula(n.type, '', rec(n.arg), rec(n.child), rec(n.child2));
            case 'crossJoin':
                return binaryFormula(n.type, '', null, rec(n.child), rec(n.child2));
            case 'naturalJoin':
                return binaryFormula(n.type, '', null, rec(n.child), rec(n.child2));
            case 'leftSemiJoin':
                return binaryFormula(n.type, '', null, rec(n.child), rec(n.child2));
            case 'rightSemiJoin':
                return binaryFormula(n.type, '', null, rec(n.child), rec(n.child2));
            case 'antiJoin':
                return binaryFormula(n.type, '', null, rec(n.child), rec(n.child2));
            case 'leftOuterJoin':
                {
                    const condition = (n.arg === null ? null : rec(n.arg));
                    return binaryFormula(n.type, '', condition, rec(n.child), rec(n.child2));
                }
            case 'rightOuterJoin':
                {
                    const condition = (n.arg === null ? null : rec(n.arg));
                    return binaryFormula(n.type, '', condition, rec(n.child), rec(n.child2));
                }
            case 'fullOuterJoin':
                {
                    const condition = (n.arg === null ? null : rec(n.arg));
                    return binaryFormula(n.type, '', condition, rec(n.child), rec(n.child2));
                }
            // FIXME: expression???
            /*case 'ConditionConst':
                return unaryFormula(n.type, n.value + '', null, null);

            case 'ConditionAnd':
                return booleanOp(n.type, '', rec(n.child), rec(n.child2));

            case 'ConditionNot':
                return unaryFormula(n.type, '', null, rec(n.child));

            case 'ConditionOr':
                return booleanOp(n.type, '', rec(n.child), rec(n.child2));

            case 'ConditionColEqualsValue':
                return comparison(n.type, n.comparator, columnName(n.col.name, n.col.relAlias), value(n.value, n.valType), n.ltr);

            case 'ConditionColEqualsCol':
                return comparison(n.type, n.comparator, columnName(n.col.name, n.col.relAlias), columnName(n.col2.name, n.col2.relAlias), false);

            case 'variable':
                return variable(n.name);*/
            default:
                throw new Error(`type ${n.type} not implemented`);
        }
    }
    return rec(node);
}
exports.textFromRelalgAstNode = textFromRelalgAstNode;

},{}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.forEachPreOrder = exports.mapPostOrder = void 0;
function mapPostOrder(node, func) {
    // let child: astNode | undefined = node.child;
    // let child2: astNode | undefined = node.child2;
    // let assignments: any[] | undefined = node.assignments;
    // let from: sqlAst.statement['from'] | undefined = node['from'];
    // let statement: sqlAst.relationFromSubstatement['statement'] | undefined = undefined;
    // 
    // let changed = false;
    // descent
    if (node.child !== undefined) {
        const child = mapPostOrder(node.child, func);
        if (child !== node.child) {
            node = Object.assign({}, node, { child });
        }
    }
    if (node.child2 !== undefined) {
        const child2 = mapPostOrder(node.child2, func);
        if (child2 !== node.child2) {
            node = Object.assign({}, node, { child2 });
        }
    }
    if (node.type === 'statement') {
        const from = mapPostOrder(node.from, func);
        if (from !== node.from) {
            node = Object.assign({}, node, { from });
        }
    }
    else if (node.type === 'relationFromSubstatement') {
        const statement = mapPostOrder(node.statement, func);
        if (statement !== node.statement) {
            node = Object.assign({}, node, { statement });
        }
    }
    else if (node.type === 'relalgRoot') {
        let changed = false;
        const assignments = node.assignments.map(a => {
            const x = mapPostOrder(a.child, func);
            if (x !== a.child) {
                changed = true;
                return Object.assign(Object.assign({}, a), { child: x });
            }
            else {
                return a;
            }
        });
        if (changed) {
            node = Object.assign({}, node, { assignments });
        }
    }
    else if (node.type === 'sqlRoot') {
        let changed = false;
        const assignments = node.assignments.map(a => {
            const x = mapPostOrder(a.child, func);
            if (x !== a.child) {
                changed = true;
                return Object.assign(Object.assign({}, a), { child: x });
            }
            else {
                return a;
            }
        });
        if (changed) {
            node = Object.assign({}, node, { assignments });
        }
    }
    const mapped = func(node);
    return mapped;
}
exports.mapPostOrder = mapPostOrder;
function forEachPreOrder(node, func, descentIntoAssignments = true) {
    func(node);
    if (node.type === 'statement') {
        forEachPreOrder(node.from, func, descentIntoAssignments);
    }
    else if (node.type === 'relationFromSubstatement') {
        forEachPreOrder(node.statement, func, descentIntoAssignments);
    }
    if (typeof node.child !== 'undefined') {
        forEachPreOrder(node.child, func, descentIntoAssignments);
    }
    if (typeof node.child2 !== 'undefined') {
        forEachPreOrder(node.child2, func, descentIntoAssignments);
    }
    if (typeof node.assignments !== 'undefined' && descentIntoAssignments === true) {
        for (const a of node.assignments) {
            forEachPreOrder(a, func, descentIntoAssignments);
        }
    }
}
exports.forEachPreOrder = forEachPreOrder;

},{}],52:[function(require,module,exports){
var relax_core = require('./db/relax-core');

var relation_core = require('./db/exec/Relation');

const executeRelalg = relax_core.executeRelalg;
const Relation = relation_core.Relation;

module.exports = {
	executeRelalg,
	Relation
}
},{"./db/exec/Relation":27,"./db/relax-core":47}]},{},[52])(52)
});
// });